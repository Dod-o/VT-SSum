{
    "id": "mk2ahi3wbfxcxchdgmmlwnz5zthxjis6",
    "title": "Online submodular minimization with combinatorial constraints",
    "info": {
        "author": [
            "Stefanie Jegelka, Max Planck Institute for Biological Cybernetics, Max Planck Institute"
        ],
        "published": "Jan. 13, 2011",
        "recorded": "December 2010",
        "category": [
            "Top->Computer Science->Machine Learning->Discrete Optimization",
            "Top->Computer Science->Machine Learning->On-line Learning"
        ]
    },
    "url": "http://videolectures.net/nipsworkshops2010_jegelka_osm/",
    "segmentation": [
        [
            "Nine algorithms and yeah, here are some ideas how you could do it."
        ],
        [
            "So let me start with the definition of the problem.",
            "We have a Crown set of elements E for example.",
            "This could be the edges in a graph in many cases, and we have feasible set.",
            "So for example we are looking for a spanning tree in the graph where we are looking for some minimal cut or something like that.",
            "And usually what we then have is a cost function."
        ],
        [
            "And this cost function is in general just the sum of edge weights in the graph.",
            "And this gives us problems like minimum SD card, minimum spanning tree, shortest path and such things that you're probably all familiar with.",
            "Now The thing is, with such a cost function that base."
        ],
        [
            "He means that.",
            "The cost of an edge is independent of what other edges I choose for my solution.",
            "So for example, if I choose a path, it doesn't really matter what else, what other parts of my path I choose, and in real life this actually does not always hold true.",
            "For example, when I came here, I booked a flight by an airline, and usually it's much cheaper to book like the same flight with different stops by the same company, then from different companies.",
            "So we will do something where you can actually do that, for example, or you are building some connections and then.",
            "You have just maybe you have some shared fixed costs or something like that and this kind of cost function actually cannot capture that, but.",
            "Then we've already heard a lot about submodular cost functions."
        ],
        [
            "And they can actually capture such kinds of costs.",
            "Where now we don't have diminishing returns, but diminishing costs, sort of, so we now allow the cost function to be a non monotone monotone.",
            "Sorry I'm submodular cost function non negative one.",
            "Also because we're talking about costs.",
            "So just for those."
        ],
        [
            "We weren't here this morning or as a reminder.",
            "The cost function is now a set function from take sets of elements.",
            "For example, sets of edges in my graph and it assigns a cost to those.",
            "Um?"
        ],
        [
            "And submodularity means that we have diminishing marginal costs, and here's just a simple example.",
            "If I have a set A and I add an element to it, and I have a super set P, then the cost increases when I added to the smaller set, the cost increases at least as much as when I add it to the larger set.",
            "So here is just a simple example.",
            "For example, my submodular function could count the colors and each element has a color, so each element is such as the ball in the turn, and we have red and green.",
            "I add a blue one.",
            "The cost increases by one and on the right hand side.",
            "I already have blue ones in there and the cost does not increase anymore, so this is just a very simple example of that.",
            "And."
        ],
        [
            "The other thing is that the cost function is monotone and that just means that as my set grows larger, the cost will not decrease, which is also natural assumption I guess.",
            "And what this also means is that a submodular function is not."
        ],
        [
            "Separable, so now I cannot write my cost function anymore.",
            "Is just the sum of weights of elements or something like that?",
            "This is in general not possible, so this sum of weights function is actually a special case of this, so it would satisfy the upper part just with equality, and that's sort of the simpler case.",
            "In general, this is not the case."
        ],
        [
            "Now this kind of problem.",
            "Has actually several applications, so just as a reminder, we want to find this kind of cut, for example with a submodular cost function.",
            "This has applications for example in computer security, where my graph is now a state graph and I would like the someone wants to get sort of from the initial state to the final state where the final state means that someone managed to break into my system and I want to prevent that and all the edges are now actions or they are labeled by actions and I want to find sort of the minimal set of actions that will prevent.",
            "Someone from breaking in and now you can not only take edge actions, you might have that each of the state changes depends on a number of features and they share features and you want to find the minimum number of features that you need to.",
            "Delimit.",
            "That you need to kill, sort of and other applications are for example in image segmentation.",
            "Or in network design.",
            "And one thing that Nina was mentioning this morning, is that now?",
            "Actually?",
            "It also makes sense to talk about a multi agent extension.",
            "So for example now then I have the added complexity that for example, I want to build a path and I have to assign each part of this path so each edge to some agents who will actually build this and each agent has now a submodular cost function.",
            "So I have two sort of optimally assignment that I get the maximum discount for that.",
            "And if I have just the sum of weights, this is still a linear function.",
            "So for submodular function that makes much more sense.",
            "So you see that basically this kind of problem is very, very general.",
            "You can model actually a lot of things with it.",
            "There's just a slight problem with that and that."
        ],
        [
            "Is that usually?",
            "These problems become suddenly very hard.",
            "So you know that for example, minimum St cut or minimum spanning trees actually not so difficult problem.",
            "There are algorithms for that, but for these kinds of problems actually you get lower bounds on the approximation factor and approximation factor means that my algorithm gives me a solution and it is guaranteed that the cost of that solution is at least at most by a factor Alpha verse.",
            "Stand the optimal solution and here like for many of those problems, it's sort of on the order of the number of nodes in the graph or something like that.",
            "So they are really difficult.",
            "But then on the other hand also there are approximation algorithms for that, and in practice they work much better than the first case bounds.",
            "So we've actually tried that, and so it's not that.",
            "One should completely get out, give up on that.",
            "So this was an introduction to the offline setting of the problem.",
            "Now let's look at the online setting."
        ],
        [
            "So we are actually considering the full information case.",
            "That means now we solve this problem repeatedly and in each round we have to find a solution.",
            "So we have to find a cut.",
            "And after that we actually only get the cost of that cut envy occur, the loss FT of St and we can use though the information that we've seen so far for cost functions to pick the next solution that we will play.",
            "So for example, one like slightly more complicated instance of that is your daily way to work, where every day.",
            "Basically you have to solve a shortest path problem.",
            "You are picking some kind of route to work and only afterwards you will see whether that was a good choice or not.",
            "But in general, there's some dependency between this."
        ],
        [
            "And the goal is now to minimize the so called regret.",
            "That means I sum up the costs over my different rounds and I compare it to the case when I would actually know all the cost functions in advance and I would.",
            "I could choose one solution, and since this is actually an NP hard problem and in polynomial time I could not even solve this minimization, we scale it by the factor Alpha.",
            "That means that sort of the best that I can expect in polynomial time.",
            "That's the standard thing.",
            "And Alpha here always means the approximation factor that I can achieve in an offline algorithm.",
            "Without the online setting.",
            "Is that clear?"
        ],
        [
            "So this is the setting that we will compare, and this has actually been looked at a lot also in machine learning, say online convex optimization.",
            "This is nothing new and there has also been work on combinatorial settings of those problems.",
            "So for example, this online shortest path or something like that.",
            "The only thing is that most of these algorithms actually have a separable cost function, so we have this kind of sum of weights cost function and you can exploit that.",
            "In many cases it makes things easier.",
            "So for examples in an expert setting or so you can actually exploit the separability of that cost function.",
            "Now I told you before that submodular functions are actually not separable, so we cannot really use these algorithms, just out of the box like that."
        ],
        [
            "On the other hand, if you just look at submodular functions, there's all."
        ],
        [
            "So there are online algorithms for minimizing submodular functions, but without any constraints.",
            "And then you can use as a subroutine your values just submodular function minimization, and the regret that you get with.",
            "That is the number of elements divided by the square root of T, and you have one thing I forgot to save us that you usually want to regret that scales sub linearly in T. So if you take the average regret you want something that goes to zero as the time goes to Infinity.",
            "That is sort of the goal, and with this kind of regret is OK.",
            "This will happen.",
            "Yeah, that's the average weekend.",
            "Estey grows, then it goes to 0.",
            "This is fine.",
            "The other thing is that these are actually problems that are not NP hard usually, so this could.",
            "You could use that for spanning tree or something that's not NP hard and also submodular function minimization is not an NP hard problem, so we don't actually need approximation algorithms here.",
            "Now people have also looked at online approximation algorithms."
        ],
        [
            "And one example is here.",
            "So actually one of the same standard algorithms for combinatorial online optimization is the follow follow the Leader framework where I take all the cost functions that I've seen so far, and I take the minimizer of those functions.",
            "And in addition, I also randomize, so I have this.",
            "Some of the functions that I've seen so far, and I have the R, which means I assign random weights to my edges.",
            "And.",
            "And that randomizes my choice in the end, so I minimize that term.",
            "Now the problem is that in our case this is actually again an NP hard problem and we can only solve it approximately and we if we use some black box approximation algorithm.",
            "It has been shown that this does not always work."
        ],
        [
            "So it can be that your regret will not go to zero, actually.",
            "This is for example the case if you just plug in the standard set cover algorithm.",
            "So just like that, we cannot also cannot really use it like that and."
        ],
        [
            "For that reason.",
            "Card and others developed some generic framework for turning an offline approximation algorithm to an online approximation algorithm.",
            "But again, this only works for cost functions that are modular.",
            "That means separable and otherwise you would get something like an exponential bound.",
            "And there are some other complications.",
            "So again, this is not really applicable, so we have to use something else."
        ],
        [
            "So just as a summary, yeah, we have this combinatorial problem with.",
            "Non separable cost function that makes it hard.",
            "We only have approximation algorithms, so we can't really say that.",
            "OK, we can use some sort of exact solution.",
            "And there's not really a black box conversion that we could use, so we have to think of something."
        ],
        [
            "And then the question is, can we still use the offline approximation algorithms to get online approximation algorithms?",
            "And of course you can.",
            "Otherwise I wouldn't give this talk."
        ],
        [
            "And the idea is basically that many of those approximation algorithms actually rely on solving a related problem and solving that exactly.",
            "So we will also make use of this property.",
            "Actually now we just have to look for approximation algorithms that satisfy this constraint and how we could then use that.",
            "So let's."
        ],
        [
            "Look back at our problem.",
            "We want to minimize F of S. And we have these combinatorial constraints and you can now say OK on the one hand, this problem is actually hard because the cost function is so difficult.",
            "If I had just a sum of weights cost function that would all be easy, so we can attack the problem from that side on the other side, we can say OK, the problem is hard because we have those constraints and if we didn't have any constraints, we can also solve it optimally."
        ],
        [
            "So that means on the one hand we can just replace the cost function by something that is actually more tractable, but it is still sort of good that captures that approximates the cost function well enough, and now the approximation depends on this F hat that we will choose.",
            "On the other side, OK?"
        ],
        [
            "So we can say just like for linear programming and integer programs, we just relax the constraints.",
            "And then we do a rounding and now everything depends on the rounding that you can have a good rounding procedure to get you to give you the approximations.",
            "And."
        ],
        [
            "That cost function approach is possible.",
            "For example for graph cuts, and you can also see some of the algorithms for perfect matching and spanning tree.",
            "Basically doing this kind of thing.",
            "On the other hand, for relaxations, yeah there, for there is running procedure for coverings that Professor Rivada has published.",
            "And you can do a similar things also for graph cuts, where you find a threshold where you can round it and then you truncate it to a cut and that gives you an approximation guarantee.",
            "Now the question is OK. What kind of online algorithms can we use with that and?",
            "Um?"
        ],
        [
            "Well, the answer is that if I relax my constraints, I basically have a continuous optimization problem and I can use something like an online gradient descent.",
            "So in each step I take the I compute the subgradient of the previous function that I've seen and computing the subgradient in that cases of the so called vast extension and that can be done displaced by basically a sorting routine and linear number of Oracle queries, and that gives you.",
            "Then I projected back onto my constraints.",
            "And then I do the rounding and I used the rounding that I have from the offline approximation algorithms and then I basically integrate this into my analysis and the regret that I get with that is.",
            "Basically, on the order of what I would get with the gradient descent for this kind of problem.",
            "So here little M is the number of elements, capital M is the maximal value that my function can take, and it all scales by Alpha.",
            "This is also normal for this type of Alpha regret.",
            "On the other hand, if I approximate my function, I can use exactly that follow the Leader framework that I showed you before.",
            "That fails in general.",
            "And there I get a regret that also basically scales with Alpha and is now linear in the number of elements.",
            "And I've since I don't have that much time, I'll just show you the idea behind the approximation of the cost function."
        ],
        [
            "So this is.",
            "This is the standard algorithm for follow the leader.",
            "That means in each step, as I said, you just take the optimizer of your cost function plus a random perturbation, and this is the NP hard problem that we cannot solve.",
            "However, if we now plug it in."
        ],
        [
            "Proximation of all function and we do some scalings.",
            "If that is a good effect, then we can solve this problem.",
            "So we have two constraints now.",
            "On the one hand, we want that of course the problem is now polynomial time solvable so that we actually have some kind of gain of using this other cost function.",
            "And on the other hand, we want that F head does not deviate too much from F, so we want it to be sent, which by a factor of Alpha and this Alpha is then also the approximation factor.",
            "So the question is now only OK. What is his head?",
            "And yeah, for spanning trees you can take sort of the simplest possible and it will always already give you the theoretically best approximation for graph cuts."
        ],
        [
            "You can do a little better.",
            "So let me show you this illustrated this with a simple example up there.",
            "I have the regret and yeah, as a reminder, the regret scales linearly with the approximation factor.",
            "So we want something that's actually very good approximation factor.",
            "And as a simple example, we could again have that the cost function counts the number of types of edges that we have.",
            "So here we have the straight edges, the dashed and the dotted ones.",
            "So we have a cost of three in this kind of graph cut.",
            "And this is the exact function, and this is intractable, so this is not really solvable.",
            "So the question is, what do we do well?"
        ],
        [
            "We could just take each edge by itself and then we count the number of types.",
            "Well then we have like a black.",
            "One in the red one etc and we get a cost of 6 instead of three.",
            "This this is sort of the simplest approximation that you could do, and of course it's not always that each always counts one, so sometimes this approximation might make a little more sense, but in general.",
            "OK, this is very is actually not such a good approximation."
        ],
        [
            "And the factor that you will get is in the worst case on the order of the square of the number of nodes.",
            "Well, maybe we can do a little better than that.",
            "And we can.",
            "And now we say OK, instead of counting each edge by itself or taking actually counting all the edges together, we take something in between so."
        ],
        [
            "We grouped the edges.",
            "And now we take the black edges together and if they have the same type then we count that as one and just take the types in the Black Group and then the right group and then the Blue Group.",
            "And by that we can tighten the approximation factor.",
            "And now the questions, of course, what are the groups?",
            "And we restrain the groups.",
            "That way that we say the edges in one group should share a note.",
            "So now."
        ],
        [
            "Now we index the groups by nodes.",
            "And you see that yeah, it's already like that.",
            "The black edges are incident to the same node and the red ones etc.",
            "Now there are still some.",
            "It's still not exact clear because we can assign each edge either to its head model to its tail node.",
            "It has two nodes.",
            "And the other question is, is that now solved?"
        ],
        [
            "Apple at all?",
            "So yeah, the question is which partition?",
            "And actually in the offline case.",
            "We used the tightest possible partition so that basically the smallest value for each cut that is possible.",
            "And in the online case, this is not really possible because we have a sum of functions, But then you just randomize, so you'd say OK."
        ],
        [
            "Before I run the algorithm, I actually decide 5050, either as I assign each edge to its head or to its tail.",
            "And then I stick with that and in expectation that gives you the same approximation factor.",
            "The other question is, is distractible, and it turns out, yes.",
            "So if you take the dual of this of this problem, it's the same as Max flow and min cut.",
            "This is actually a generalized Max flow problem."
        ],
        [
            "And it's the actual problem is called polymatroid.",
            "Max flows and this is a kind of network flow where we don't have capacity constraints on each edge, but also on sets of edges.",
            "And this is can still be solved in polynomial time because I'm locally restricted and we can use that kind of algorithm then.",
            "And yeah, the last question is the approximation fact."
        ],
        [
            "So we still remain on the order of the number of nodes divided by two versus number of nodes square.",
            "That would be the last.",
            "So that case we can still sort of save the regret.",
            "This is 1 example how you could do it.",
            "That was for the graph cuts and.",
            "Think I'm."
        ],
        [
            "Sort of running out of time, so let me come to the summary.",
            "I showed you two ideas how you could develop online algorithms for these combinatorial problems with submodular costs.",
            "One was on a subgradient descent and one was that approximation of the cost function.",
            "We're basically we had to solve the difficulties that we have only approximations and we have non separable cost functions and combinatorial constraints.",
            "There was no black box conversion that we could use and the key was to solve a related problem that can be solved exactly and built on that.",
            "Thank you.",
            "So what happens if they use the vertex cover instead of just picking each node, right?",
            "Would probably ask.",
            "Edge for assignments randomly.",
            "So one of his own, correct, yes.",
            "What you mean?",
            "The algorithm for vertex covered or just the vertex cover have to count all edges in my cart, right?",
            "Yeah.",
            "All the neighbors of those vertices would get the same problem.",
            "OK, yeah, you could also do that and.",
            "I think it would give you the same balance or the.",
            "The thing is that this bound is actually sort of.",
            "It's the number of nodes either on the side or on the T side of the cut.",
            "So in that case it sort of depends if there are more edges on the side or on the T side of the cut and you don't know that in advance.",
            "So if you again randomize, it's fine, otherwise you would value it at most, get something on the order of end, so you could also do that kind of thing is possible.",
            "Any other questions?",
            "There's some work on the proxy meeting submodular functions by simpler.",
            "I mean the goal Network recommends that.",
            "So the problem is actually with this affecting that I use you have the sum of the approximations and if you use romances approximation it's the square root of a sum of weights and you actually usually solve just the square of the function.",
            "So you would have to use the either the sum of the squared functions or something else.",
            "Otherwise you have again a sum of squares of weights and then it's not.",
            "So easy anymore, so that is sort of the.",
            "You can still solve it, but getting the approximation bound is like all the regret.",
            "Bound is then little more difficult.",
            "Just as an offline approximation without the sum, you could use it of course.",
            "It gives good bounds for that also.",
            "Any other questions?",
            "OK, thank you."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Nine algorithms and yeah, here are some ideas how you could do it.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So let me start with the definition of the problem.",
                    "label": 0
                },
                {
                    "sent": "We have a Crown set of elements E for example.",
                    "label": 0
                },
                {
                    "sent": "This could be the edges in a graph in many cases, and we have feasible set.",
                    "label": 1
                },
                {
                    "sent": "So for example we are looking for a spanning tree in the graph where we are looking for some minimal cut or something like that.",
                    "label": 0
                },
                {
                    "sent": "And usually what we then have is a cost function.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And this cost function is in general just the sum of edge weights in the graph.",
                    "label": 0
                },
                {
                    "sent": "And this gives us problems like minimum SD card, minimum spanning tree, shortest path and such things that you're probably all familiar with.",
                    "label": 0
                },
                {
                    "sent": "Now The thing is, with such a cost function that base.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "He means that.",
                    "label": 0
                },
                {
                    "sent": "The cost of an edge is independent of what other edges I choose for my solution.",
                    "label": 1
                },
                {
                    "sent": "So for example, if I choose a path, it doesn't really matter what else, what other parts of my path I choose, and in real life this actually does not always hold true.",
                    "label": 0
                },
                {
                    "sent": "For example, when I came here, I booked a flight by an airline, and usually it's much cheaper to book like the same flight with different stops by the same company, then from different companies.",
                    "label": 0
                },
                {
                    "sent": "So we will do something where you can actually do that, for example, or you are building some connections and then.",
                    "label": 0
                },
                {
                    "sent": "You have just maybe you have some shared fixed costs or something like that and this kind of cost function actually cannot capture that, but.",
                    "label": 0
                },
                {
                    "sent": "Then we've already heard a lot about submodular cost functions.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And they can actually capture such kinds of costs.",
                    "label": 0
                },
                {
                    "sent": "Where now we don't have diminishing returns, but diminishing costs, sort of, so we now allow the cost function to be a non monotone monotone.",
                    "label": 0
                },
                {
                    "sent": "Sorry I'm submodular cost function non negative one.",
                    "label": 0
                },
                {
                    "sent": "Also because we're talking about costs.",
                    "label": 0
                },
                {
                    "sent": "So just for those.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We weren't here this morning or as a reminder.",
                    "label": 0
                },
                {
                    "sent": "The cost function is now a set function from take sets of elements.",
                    "label": 1
                },
                {
                    "sent": "For example, sets of edges in my graph and it assigns a cost to those.",
                    "label": 0
                },
                {
                    "sent": "Um?",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And submodularity means that we have diminishing marginal costs, and here's just a simple example.",
                    "label": 1
                },
                {
                    "sent": "If I have a set A and I add an element to it, and I have a super set P, then the cost increases when I added to the smaller set, the cost increases at least as much as when I add it to the larger set.",
                    "label": 0
                },
                {
                    "sent": "So here is just a simple example.",
                    "label": 0
                },
                {
                    "sent": "For example, my submodular function could count the colors and each element has a color, so each element is such as the ball in the turn, and we have red and green.",
                    "label": 0
                },
                {
                    "sent": "I add a blue one.",
                    "label": 0
                },
                {
                    "sent": "The cost increases by one and on the right hand side.",
                    "label": 0
                },
                {
                    "sent": "I already have blue ones in there and the cost does not increase anymore, so this is just a very simple example of that.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The other thing is that the cost function is monotone and that just means that as my set grows larger, the cost will not decrease, which is also natural assumption I guess.",
                    "label": 0
                },
                {
                    "sent": "And what this also means is that a submodular function is not.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Separable, so now I cannot write my cost function anymore.",
                    "label": 0
                },
                {
                    "sent": "Is just the sum of weights of elements or something like that?",
                    "label": 0
                },
                {
                    "sent": "This is in general not possible, so this sum of weights function is actually a special case of this, so it would satisfy the upper part just with equality, and that's sort of the simpler case.",
                    "label": 0
                },
                {
                    "sent": "In general, this is not the case.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now this kind of problem.",
                    "label": 0
                },
                {
                    "sent": "Has actually several applications, so just as a reminder, we want to find this kind of cut, for example with a submodular cost function.",
                    "label": 0
                },
                {
                    "sent": "This has applications for example in computer security, where my graph is now a state graph and I would like the someone wants to get sort of from the initial state to the final state where the final state means that someone managed to break into my system and I want to prevent that and all the edges are now actions or they are labeled by actions and I want to find sort of the minimal set of actions that will prevent.",
                    "label": 0
                },
                {
                    "sent": "Someone from breaking in and now you can not only take edge actions, you might have that each of the state changes depends on a number of features and they share features and you want to find the minimum number of features that you need to.",
                    "label": 0
                },
                {
                    "sent": "Delimit.",
                    "label": 0
                },
                {
                    "sent": "That you need to kill, sort of and other applications are for example in image segmentation.",
                    "label": 0
                },
                {
                    "sent": "Or in network design.",
                    "label": 0
                },
                {
                    "sent": "And one thing that Nina was mentioning this morning, is that now?",
                    "label": 0
                },
                {
                    "sent": "Actually?",
                    "label": 0
                },
                {
                    "sent": "It also makes sense to talk about a multi agent extension.",
                    "label": 0
                },
                {
                    "sent": "So for example now then I have the added complexity that for example, I want to build a path and I have to assign each part of this path so each edge to some agents who will actually build this and each agent has now a submodular cost function.",
                    "label": 0
                },
                {
                    "sent": "So I have two sort of optimally assignment that I get the maximum discount for that.",
                    "label": 0
                },
                {
                    "sent": "And if I have just the sum of weights, this is still a linear function.",
                    "label": 0
                },
                {
                    "sent": "So for submodular function that makes much more sense.",
                    "label": 0
                },
                {
                    "sent": "So you see that basically this kind of problem is very, very general.",
                    "label": 0
                },
                {
                    "sent": "You can model actually a lot of things with it.",
                    "label": 0
                },
                {
                    "sent": "There's just a slight problem with that and that.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is that usually?",
                    "label": 0
                },
                {
                    "sent": "These problems become suddenly very hard.",
                    "label": 0
                },
                {
                    "sent": "So you know that for example, minimum St cut or minimum spanning trees actually not so difficult problem.",
                    "label": 0
                },
                {
                    "sent": "There are algorithms for that, but for these kinds of problems actually you get lower bounds on the approximation factor and approximation factor means that my algorithm gives me a solution and it is guaranteed that the cost of that solution is at least at most by a factor Alpha verse.",
                    "label": 0
                },
                {
                    "sent": "Stand the optimal solution and here like for many of those problems, it's sort of on the order of the number of nodes in the graph or something like that.",
                    "label": 0
                },
                {
                    "sent": "So they are really difficult.",
                    "label": 0
                },
                {
                    "sent": "But then on the other hand also there are approximation algorithms for that, and in practice they work much better than the first case bounds.",
                    "label": 0
                },
                {
                    "sent": "So we've actually tried that, and so it's not that.",
                    "label": 0
                },
                {
                    "sent": "One should completely get out, give up on that.",
                    "label": 0
                },
                {
                    "sent": "So this was an introduction to the offline setting of the problem.",
                    "label": 0
                },
                {
                    "sent": "Now let's look at the online setting.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we are actually considering the full information case.",
                    "label": 0
                },
                {
                    "sent": "That means now we solve this problem repeatedly and in each round we have to find a solution.",
                    "label": 0
                },
                {
                    "sent": "So we have to find a cut.",
                    "label": 0
                },
                {
                    "sent": "And after that we actually only get the cost of that cut envy occur, the loss FT of St and we can use though the information that we've seen so far for cost functions to pick the next solution that we will play.",
                    "label": 0
                },
                {
                    "sent": "So for example, one like slightly more complicated instance of that is your daily way to work, where every day.",
                    "label": 0
                },
                {
                    "sent": "Basically you have to solve a shortest path problem.",
                    "label": 0
                },
                {
                    "sent": "You are picking some kind of route to work and only afterwards you will see whether that was a good choice or not.",
                    "label": 0
                },
                {
                    "sent": "But in general, there's some dependency between this.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And the goal is now to minimize the so called regret.",
                    "label": 0
                },
                {
                    "sent": "That means I sum up the costs over my different rounds and I compare it to the case when I would actually know all the cost functions in advance and I would.",
                    "label": 0
                },
                {
                    "sent": "I could choose one solution, and since this is actually an NP hard problem and in polynomial time I could not even solve this minimization, we scale it by the factor Alpha.",
                    "label": 0
                },
                {
                    "sent": "That means that sort of the best that I can expect in polynomial time.",
                    "label": 0
                },
                {
                    "sent": "That's the standard thing.",
                    "label": 0
                },
                {
                    "sent": "And Alpha here always means the approximation factor that I can achieve in an offline algorithm.",
                    "label": 0
                },
                {
                    "sent": "Without the online setting.",
                    "label": 0
                },
                {
                    "sent": "Is that clear?",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So this is the setting that we will compare, and this has actually been looked at a lot also in machine learning, say online convex optimization.",
                    "label": 0
                },
                {
                    "sent": "This is nothing new and there has also been work on combinatorial settings of those problems.",
                    "label": 0
                },
                {
                    "sent": "So for example, this online shortest path or something like that.",
                    "label": 0
                },
                {
                    "sent": "The only thing is that most of these algorithms actually have a separable cost function, so we have this kind of sum of weights cost function and you can exploit that.",
                    "label": 0
                },
                {
                    "sent": "In many cases it makes things easier.",
                    "label": 0
                },
                {
                    "sent": "So for examples in an expert setting or so you can actually exploit the separability of that cost function.",
                    "label": 0
                },
                {
                    "sent": "Now I told you before that submodular functions are actually not separable, so we cannot really use these algorithms, just out of the box like that.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "On the other hand, if you just look at submodular functions, there's all.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So there are online algorithms for minimizing submodular functions, but without any constraints.",
                    "label": 0
                },
                {
                    "sent": "And then you can use as a subroutine your values just submodular function minimization, and the regret that you get with.",
                    "label": 0
                },
                {
                    "sent": "That is the number of elements divided by the square root of T, and you have one thing I forgot to save us that you usually want to regret that scales sub linearly in T. So if you take the average regret you want something that goes to zero as the time goes to Infinity.",
                    "label": 0
                },
                {
                    "sent": "That is sort of the goal, and with this kind of regret is OK.",
                    "label": 0
                },
                {
                    "sent": "This will happen.",
                    "label": 0
                },
                {
                    "sent": "Yeah, that's the average weekend.",
                    "label": 0
                },
                {
                    "sent": "Estey grows, then it goes to 0.",
                    "label": 0
                },
                {
                    "sent": "This is fine.",
                    "label": 0
                },
                {
                    "sent": "The other thing is that these are actually problems that are not NP hard usually, so this could.",
                    "label": 0
                },
                {
                    "sent": "You could use that for spanning tree or something that's not NP hard and also submodular function minimization is not an NP hard problem, so we don't actually need approximation algorithms here.",
                    "label": 0
                },
                {
                    "sent": "Now people have also looked at online approximation algorithms.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And one example is here.",
                    "label": 0
                },
                {
                    "sent": "So actually one of the same standard algorithms for combinatorial online optimization is the follow follow the Leader framework where I take all the cost functions that I've seen so far, and I take the minimizer of those functions.",
                    "label": 0
                },
                {
                    "sent": "And in addition, I also randomize, so I have this.",
                    "label": 0
                },
                {
                    "sent": "Some of the functions that I've seen so far, and I have the R, which means I assign random weights to my edges.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "And that randomizes my choice in the end, so I minimize that term.",
                    "label": 0
                },
                {
                    "sent": "Now the problem is that in our case this is actually again an NP hard problem and we can only solve it approximately and we if we use some black box approximation algorithm.",
                    "label": 0
                },
                {
                    "sent": "It has been shown that this does not always work.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So it can be that your regret will not go to zero, actually.",
                    "label": 0
                },
                {
                    "sent": "This is for example the case if you just plug in the standard set cover algorithm.",
                    "label": 0
                },
                {
                    "sent": "So just like that, we cannot also cannot really use it like that and.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "For that reason.",
                    "label": 0
                },
                {
                    "sent": "Card and others developed some generic framework for turning an offline approximation algorithm to an online approximation algorithm.",
                    "label": 0
                },
                {
                    "sent": "But again, this only works for cost functions that are modular.",
                    "label": 0
                },
                {
                    "sent": "That means separable and otherwise you would get something like an exponential bound.",
                    "label": 0
                },
                {
                    "sent": "And there are some other complications.",
                    "label": 0
                },
                {
                    "sent": "So again, this is not really applicable, so we have to use something else.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So just as a summary, yeah, we have this combinatorial problem with.",
                    "label": 0
                },
                {
                    "sent": "Non separable cost function that makes it hard.",
                    "label": 1
                },
                {
                    "sent": "We only have approximation algorithms, so we can't really say that.",
                    "label": 0
                },
                {
                    "sent": "OK, we can use some sort of exact solution.",
                    "label": 0
                },
                {
                    "sent": "And there's not really a black box conversion that we could use, so we have to think of something.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And then the question is, can we still use the offline approximation algorithms to get online approximation algorithms?",
                    "label": 1
                },
                {
                    "sent": "And of course you can.",
                    "label": 0
                },
                {
                    "sent": "Otherwise I wouldn't give this talk.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And the idea is basically that many of those approximation algorithms actually rely on solving a related problem and solving that exactly.",
                    "label": 1
                },
                {
                    "sent": "So we will also make use of this property.",
                    "label": 1
                },
                {
                    "sent": "Actually now we just have to look for approximation algorithms that satisfy this constraint and how we could then use that.",
                    "label": 0
                },
                {
                    "sent": "So let's.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Look back at our problem.",
                    "label": 0
                },
                {
                    "sent": "We want to minimize F of S. And we have these combinatorial constraints and you can now say OK on the one hand, this problem is actually hard because the cost function is so difficult.",
                    "label": 1
                },
                {
                    "sent": "If I had just a sum of weights cost function that would all be easy, so we can attack the problem from that side on the other side, we can say OK, the problem is hard because we have those constraints and if we didn't have any constraints, we can also solve it optimally.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So that means on the one hand we can just replace the cost function by something that is actually more tractable, but it is still sort of good that captures that approximates the cost function well enough, and now the approximation depends on this F hat that we will choose.",
                    "label": 0
                },
                {
                    "sent": "On the other side, OK?",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we can say just like for linear programming and integer programs, we just relax the constraints.",
                    "label": 0
                },
                {
                    "sent": "And then we do a rounding and now everything depends on the rounding that you can have a good rounding procedure to get you to give you the approximations.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "That cost function approach is possible.",
                    "label": 1
                },
                {
                    "sent": "For example for graph cuts, and you can also see some of the algorithms for perfect matching and spanning tree.",
                    "label": 1
                },
                {
                    "sent": "Basically doing this kind of thing.",
                    "label": 0
                },
                {
                    "sent": "On the other hand, for relaxations, yeah there, for there is running procedure for coverings that Professor Rivada has published.",
                    "label": 0
                },
                {
                    "sent": "And you can do a similar things also for graph cuts, where you find a threshold where you can round it and then you truncate it to a cut and that gives you an approximation guarantee.",
                    "label": 0
                },
                {
                    "sent": "Now the question is OK. What kind of online algorithms can we use with that and?",
                    "label": 0
                },
                {
                    "sent": "Um?",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Well, the answer is that if I relax my constraints, I basically have a continuous optimization problem and I can use something like an online gradient descent.",
                    "label": 0
                },
                {
                    "sent": "So in each step I take the I compute the subgradient of the previous function that I've seen and computing the subgradient in that cases of the so called vast extension and that can be done displaced by basically a sorting routine and linear number of Oracle queries, and that gives you.",
                    "label": 0
                },
                {
                    "sent": "Then I projected back onto my constraints.",
                    "label": 0
                },
                {
                    "sent": "And then I do the rounding and I used the rounding that I have from the offline approximation algorithms and then I basically integrate this into my analysis and the regret that I get with that is.",
                    "label": 0
                },
                {
                    "sent": "Basically, on the order of what I would get with the gradient descent for this kind of problem.",
                    "label": 0
                },
                {
                    "sent": "So here little M is the number of elements, capital M is the maximal value that my function can take, and it all scales by Alpha.",
                    "label": 0
                },
                {
                    "sent": "This is also normal for this type of Alpha regret.",
                    "label": 0
                },
                {
                    "sent": "On the other hand, if I approximate my function, I can use exactly that follow the Leader framework that I showed you before.",
                    "label": 0
                },
                {
                    "sent": "That fails in general.",
                    "label": 0
                },
                {
                    "sent": "And there I get a regret that also basically scales with Alpha and is now linear in the number of elements.",
                    "label": 0
                },
                {
                    "sent": "And I've since I don't have that much time, I'll just show you the idea behind the approximation of the cost function.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So this is.",
                    "label": 0
                },
                {
                    "sent": "This is the standard algorithm for follow the leader.",
                    "label": 0
                },
                {
                    "sent": "That means in each step, as I said, you just take the optimizer of your cost function plus a random perturbation, and this is the NP hard problem that we cannot solve.",
                    "label": 0
                },
                {
                    "sent": "However, if we now plug it in.",
                    "label": 0
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Proximation of all function and we do some scalings.",
                    "label": 0
                },
                {
                    "sent": "If that is a good effect, then we can solve this problem.",
                    "label": 0
                },
                {
                    "sent": "So we have two constraints now.",
                    "label": 0
                },
                {
                    "sent": "On the one hand, we want that of course the problem is now polynomial time solvable so that we actually have some kind of gain of using this other cost function.",
                    "label": 0
                },
                {
                    "sent": "And on the other hand, we want that F head does not deviate too much from F, so we want it to be sent, which by a factor of Alpha and this Alpha is then also the approximation factor.",
                    "label": 0
                },
                {
                    "sent": "So the question is now only OK. What is his head?",
                    "label": 0
                },
                {
                    "sent": "And yeah, for spanning trees you can take sort of the simplest possible and it will always already give you the theoretically best approximation for graph cuts.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "You can do a little better.",
                    "label": 0
                },
                {
                    "sent": "So let me show you this illustrated this with a simple example up there.",
                    "label": 0
                },
                {
                    "sent": "I have the regret and yeah, as a reminder, the regret scales linearly with the approximation factor.",
                    "label": 0
                },
                {
                    "sent": "So we want something that's actually very good approximation factor.",
                    "label": 0
                },
                {
                    "sent": "And as a simple example, we could again have that the cost function counts the number of types of edges that we have.",
                    "label": 0
                },
                {
                    "sent": "So here we have the straight edges, the dashed and the dotted ones.",
                    "label": 0
                },
                {
                    "sent": "So we have a cost of three in this kind of graph cut.",
                    "label": 0
                },
                {
                    "sent": "And this is the exact function, and this is intractable, so this is not really solvable.",
                    "label": 0
                },
                {
                    "sent": "So the question is, what do we do well?",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We could just take each edge by itself and then we count the number of types.",
                    "label": 0
                },
                {
                    "sent": "Well then we have like a black.",
                    "label": 0
                },
                {
                    "sent": "One in the red one etc and we get a cost of 6 instead of three.",
                    "label": 0
                },
                {
                    "sent": "This this is sort of the simplest approximation that you could do, and of course it's not always that each always counts one, so sometimes this approximation might make a little more sense, but in general.",
                    "label": 0
                },
                {
                    "sent": "OK, this is very is actually not such a good approximation.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And the factor that you will get is in the worst case on the order of the square of the number of nodes.",
                    "label": 0
                },
                {
                    "sent": "Well, maybe we can do a little better than that.",
                    "label": 0
                },
                {
                    "sent": "And we can.",
                    "label": 0
                },
                {
                    "sent": "And now we say OK, instead of counting each edge by itself or taking actually counting all the edges together, we take something in between so.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We grouped the edges.",
                    "label": 0
                },
                {
                    "sent": "And now we take the black edges together and if they have the same type then we count that as one and just take the types in the Black Group and then the right group and then the Blue Group.",
                    "label": 0
                },
                {
                    "sent": "And by that we can tighten the approximation factor.",
                    "label": 0
                },
                {
                    "sent": "And now the questions, of course, what are the groups?",
                    "label": 0
                },
                {
                    "sent": "And we restrain the groups.",
                    "label": 0
                },
                {
                    "sent": "That way that we say the edges in one group should share a note.",
                    "label": 0
                },
                {
                    "sent": "So now.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now we index the groups by nodes.",
                    "label": 0
                },
                {
                    "sent": "And you see that yeah, it's already like that.",
                    "label": 0
                },
                {
                    "sent": "The black edges are incident to the same node and the red ones etc.",
                    "label": 0
                },
                {
                    "sent": "Now there are still some.",
                    "label": 0
                },
                {
                    "sent": "It's still not exact clear because we can assign each edge either to its head model to its tail node.",
                    "label": 0
                },
                {
                    "sent": "It has two nodes.",
                    "label": 0
                },
                {
                    "sent": "And the other question is, is that now solved?",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Apple at all?",
                    "label": 0
                },
                {
                    "sent": "So yeah, the question is which partition?",
                    "label": 1
                },
                {
                    "sent": "And actually in the offline case.",
                    "label": 0
                },
                {
                    "sent": "We used the tightest possible partition so that basically the smallest value for each cut that is possible.",
                    "label": 0
                },
                {
                    "sent": "And in the online case, this is not really possible because we have a sum of functions, But then you just randomize, so you'd say OK.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Before I run the algorithm, I actually decide 5050, either as I assign each edge to its head or to its tail.",
                    "label": 0
                },
                {
                    "sent": "And then I stick with that and in expectation that gives you the same approximation factor.",
                    "label": 0
                },
                {
                    "sent": "The other question is, is distractible, and it turns out, yes.",
                    "label": 0
                },
                {
                    "sent": "So if you take the dual of this of this problem, it's the same as Max flow and min cut.",
                    "label": 0
                },
                {
                    "sent": "This is actually a generalized Max flow problem.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And it's the actual problem is called polymatroid.",
                    "label": 0
                },
                {
                    "sent": "Max flows and this is a kind of network flow where we don't have capacity constraints on each edge, but also on sets of edges.",
                    "label": 0
                },
                {
                    "sent": "And this is can still be solved in polynomial time because I'm locally restricted and we can use that kind of algorithm then.",
                    "label": 0
                },
                {
                    "sent": "And yeah, the last question is the approximation fact.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we still remain on the order of the number of nodes divided by two versus number of nodes square.",
                    "label": 0
                },
                {
                    "sent": "That would be the last.",
                    "label": 0
                },
                {
                    "sent": "So that case we can still sort of save the regret.",
                    "label": 0
                },
                {
                    "sent": "This is 1 example how you could do it.",
                    "label": 0
                },
                {
                    "sent": "That was for the graph cuts and.",
                    "label": 0
                },
                {
                    "sent": "Think I'm.",
                    "label": 0
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Sort of running out of time, so let me come to the summary.",
                    "label": 0
                },
                {
                    "sent": "I showed you two ideas how you could develop online algorithms for these combinatorial problems with submodular costs.",
                    "label": 1
                },
                {
                    "sent": "One was on a subgradient descent and one was that approximation of the cost function.",
                    "label": 0
                },
                {
                    "sent": "We're basically we had to solve the difficulties that we have only approximations and we have non separable cost functions and combinatorial constraints.",
                    "label": 0
                },
                {
                    "sent": "There was no black box conversion that we could use and the key was to solve a related problem that can be solved exactly and built on that.",
                    "label": 1
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "So what happens if they use the vertex cover instead of just picking each node, right?",
                    "label": 0
                },
                {
                    "sent": "Would probably ask.",
                    "label": 0
                },
                {
                    "sent": "Edge for assignments randomly.",
                    "label": 0
                },
                {
                    "sent": "So one of his own, correct, yes.",
                    "label": 0
                },
                {
                    "sent": "What you mean?",
                    "label": 0
                },
                {
                    "sent": "The algorithm for vertex covered or just the vertex cover have to count all edges in my cart, right?",
                    "label": 0
                },
                {
                    "sent": "Yeah.",
                    "label": 0
                },
                {
                    "sent": "All the neighbors of those vertices would get the same problem.",
                    "label": 0
                },
                {
                    "sent": "OK, yeah, you could also do that and.",
                    "label": 0
                },
                {
                    "sent": "I think it would give you the same balance or the.",
                    "label": 0
                },
                {
                    "sent": "The thing is that this bound is actually sort of.",
                    "label": 0
                },
                {
                    "sent": "It's the number of nodes either on the side or on the T side of the cut.",
                    "label": 0
                },
                {
                    "sent": "So in that case it sort of depends if there are more edges on the side or on the T side of the cut and you don't know that in advance.",
                    "label": 0
                },
                {
                    "sent": "So if you again randomize, it's fine, otherwise you would value it at most, get something on the order of end, so you could also do that kind of thing is possible.",
                    "label": 0
                },
                {
                    "sent": "Any other questions?",
                    "label": 0
                },
                {
                    "sent": "There's some work on the proxy meeting submodular functions by simpler.",
                    "label": 0
                },
                {
                    "sent": "I mean the goal Network recommends that.",
                    "label": 0
                },
                {
                    "sent": "So the problem is actually with this affecting that I use you have the sum of the approximations and if you use romances approximation it's the square root of a sum of weights and you actually usually solve just the square of the function.",
                    "label": 0
                },
                {
                    "sent": "So you would have to use the either the sum of the squared functions or something else.",
                    "label": 0
                },
                {
                    "sent": "Otherwise you have again a sum of squares of weights and then it's not.",
                    "label": 0
                },
                {
                    "sent": "So easy anymore, so that is sort of the.",
                    "label": 0
                },
                {
                    "sent": "You can still solve it, but getting the approximation bound is like all the regret.",
                    "label": 0
                },
                {
                    "sent": "Bound is then little more difficult.",
                    "label": 0
                },
                {
                    "sent": "Just as an offline approximation without the sum, you could use it of course.",
                    "label": 0
                },
                {
                    "sent": "It gives good bounds for that also.",
                    "label": 0
                },
                {
                    "sent": "Any other questions?",
                    "label": 0
                },
                {
                    "sent": "OK, thank you.",
                    "label": 0
                }
            ]
        }
    }
}