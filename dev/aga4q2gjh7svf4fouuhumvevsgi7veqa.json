{
    "id": "aga4q2gjh7svf4fouuhumvevsgi7veqa",
    "title": "Practical RDF Schema reasoning with annotated Semantic Web data",
    "info": {
        "author": [
            "Filipe Ferreira, Faculdade de Ci\u00eancias e Tecnologia, Universidade Nova de Lisboa"
        ],
        "published": "Nov. 25, 2011",
        "recorded": "October 2011",
        "category": [
            "Top->Computer Science->Semantic Web->RDF - Resource Description Framework",
            "Top->Computer Science->Semantic Web->Annotation"
        ]
    },
    "url": "http://videolectures.net/iswc2011_ferreira_practical/",
    "segmentation": [
        [
            "So if you think about RDS later, which is expressing true."
        ],
        [
            "Sometimes it's not enough to express the data use in triples.",
            "Sometimes we want to add data to the triples themselves, and this map information can have different natures depending of what we wish.",
            "For example, it can be useful to add meta information of the temporal domain.",
            "We can say when the triple was created, displayed applications can choose the most recent triples.",
            "Or we can add and EXPAREL dates to triple so after that date triples will no longer be useful.",
            "We can also add confidence meta information for triples, in which each triple has a value with the confidence degree.",
            "In this way we can choose only to use more trustworthy triples, and the RDF Fest definition already has a way to admit information to triples, called replication, and the idea in replication is to assign an identifier to identify.",
            "Certain triple and then we can make statements using that identifier, adding meta information to the triple.",
            "However, this has some drawbacks, specially when it comes to inference."
        ],
        [
            "An alternative is to extend the triples and with an annotation value and then becoming quads, and for the annotated or the FS there is already a semantic specification for inference which was presented last year in this conference.",
            "And this specification does not use the RDF subset, but rather I'm sorry there are DFS language but rather subset called raw DF which has five properties.",
            "There's a property subclass type, domain and range and also has a set of inference rules that uses these properties.",
            "For example of a rule, we can see that if.",
            "We have a is a property of B and we have two resources that share the property a.",
            "We can say they also share the property be extending this with annotations we can it's we can see that in the premise each Ripple has an annotation value and the new triple that we conclude as an annotation value equal to the two norm of the annotations of the premise."
        ],
        [
            "So.",
            "Injective of our work was to implement in the relational database using SQL.",
            "The full sets of rodef inference rules for annotated data, where the 1st four groups of interest rules are exactly the same wind classical reasoning road F and the fifth group.",
            "The generalization rule is specific for undetected data, and I will speak about it.",
            "Later."
        ],
        [
            "In our work we considered only annotations for confidence values where each triple has an annotation with the real number between zero and one where zero is means that the triple is completely false, and one that it's absolutely truth and the normal operation which can have different specifications.",
            "In our case, what's the minimum G?",
            "Normally, the meaning that the normal 2 numbers in here.",
            "It's the equal to the smaller number.",
            "So too.",
            "Before."
        ],
        [
            "Implementation first we need to find a way to permanently store triples with annotations and define the way to perform the closure of the annotated graphs.",
            "And finally, we can graft onto the implementation in SQL and finally also some results."
        ],
        [
            "Now for storing the triples we use the schema.",
            "If you look at the rules we can see that we will need to search for very specific patterns, will either need to search for triples that have specific Roddy of vocabulary property or a triple that has any other property.",
            "We can call them general Triples in this case.",
            "Now this general triples will be stored in a table called triples in which triple has an ID belongs to graph.",
            "And as an annotation, and every triple that has a property that is specific to Roddy F is stored in its own different table.",
            "As we have here as an example, the table type.",
            "No."
        ],
        [
            "Another important thing is how we will perform the closure and naive way to do this is to apply all the rules several times and will, until we have nothing you after we conclude after we apply all the rules.",
            "However, in other works in particular the system web PY.",
            "We can look at the rule and we see that the rules have dependency relations among them.",
            "For example, this rule, the subclass inheritance rule.",
            "If we want this rule to infer all triples that it can possible infer, we need to guarantee that the patterns that we need to find in the premise are all already in the graph.",
            "So before we apply, this rule will need to apply the same questions.",
            "Even to rule, which is the only rule that infers hookless triples, and for example the the range duplication rule, which is one of the rules that infers triples with the property type.",
            "Now in web by they suggested a graph that showed dependency relations between rules for the RDF's inference rules.",
            "In our case we proposed one for the road DF rules.",
            "An important thing to look at in this graph is that if we look at rule to be, we can see that it concludes triples with a predicate type, but it also needs.",
            "The premise triples of the type property, so normally this would mean that this rule is recursive, but we concluded that the both the inheritance rules are important, so we can perform them only once.",
            "And so the only recursive rules are the transitivity rules.",
            "We also include the dependencies where non standard use of the road F vocabulary is used.",
            "This is when property of raw DF is used either in the subject or the object of graph.",
            "And so if we follow if we respect the dependency relations and we applied rules from the bottom to the top of the graph, we are guaranteed to reach fixed points after we apply it once every rule."
        ],
        [
            "Now for the implementation of rules.",
            "The most simple rules to implement in SQL Arden recursive and the idea is to perform a query that will return all triples that we can conclude and research those triples in the right place.",
            "In this case in the table triples and if we look at rule we can see that the the triple that we want to conclude has as the same subject and object.",
            "Then the general triple in the premise and has the predicate equal to the objects of the SU property triple and so in this query we can select these attributes and after that we need to join the places where I either Sue property triples or general to process sorts using as a condition the condition that exists or reading the rule that.",
            "Subjects of this property is equal to the predicate of the general triple.",
            "And finally, we also need to guarantee that we do not insert duplicate triples with the not exists clause."
        ],
        [
            "To extend this for annotated reasoning, we have to look at three different things.",
            "The first of all is the generalization rule, which states that if we can.",
            "Infer the same, similar to equal triples with different annotation values.",
            "We only need to store one of them, the one with in this case, with the larger annotation value.",
            "And this will we implement this in SQL with the Max aggregate function.",
            "We also need to take care of the tenorm operations so that we can calculate the annotation value for the new.",
            "For triples, we do this with the user defined function that has gets 2 double values and returns the minimum number.",
            "And finally we need also to update the annotations of existing triples.",
            "So we want to make sure that after we.",
            "Perform graft closure.",
            "All the triples have not only correct annotation values, but also the best annotation values that can.",
            "They can have.",
            "Part of this is guaranteed by the generalization rule, where if we conclude the new triple, why different paths in the graph we choose only the one that has the best annotation value, but it is also possible sometimes to conclude triple that already exists in the graph.",
            "Prior to the application of the rule and we can conclude it with a different annotation, possibly better.",
            "So we need to make sure that even existing triples have the best annotation updating."
        ],
        [
            "When it is necessary.",
            "So this is just a skeleton of implementation for annotated reasoning and first of all, we performed that update phase where we perform the query representing the rule and we select only the triples that we can conclude that already exists in the graph and if the triples that we concluded have best better.",
            "Annotation value we applied to the existing triples.",
            "After that we can perform the insertion of the triples that we can infer and do not exist, and we can make sure that every triple has the maximum value that's possible.",
            "So we conclude the new annotation values using the two norm for calculating the value and the Max for selecting only the maximum value of all."
        ],
        [
            "Possible.",
            "Now another thing to be aware of is that is there recursive rules which for large amounts of data if not implemented properly, can can get tricky and the transitive closure.",
            "Of a graph is a problem that has been studied for for some years now, and there are several iterative algorithms and naive way to perform the transitive closure of a graph is to having R as the original graph or the original relation.",
            "'cause of the database and R Plus the transitive closure in each iteration the transitive closure it's equal to all the.",
            "The two poles are everything that is in the original relation, plus every triple or every path in the graph that we can conclude in this iteration.",
            "And there is this matrix algorithm that is an improvement to the naive algorithm where we do not use.",
            "We do not keep using the original relation, but we always use the transitive closure relation, so we can infer we we perform joins with.",
            "For larger graphs, we can infer more triples, or in each iteration, and we can form the transitive closure in lesser."
        ],
        [
            "Rationes we also implemented semi naive method which is a bit more complex.",
            "The differentials me naive which is a different version that the system DLV uses and a log arhythmic algorithm which tries to perform the closure in even less iterations and the metrics algorithm.",
            "And finally we also used recursive queries.",
            "The construct from the post crash.",
            "A relational database system."
        ],
        [
            "So this is a example of the implementation of the matrix algorithm.",
            "We we have cycle.",
            "In each iteration we insert in this case in the food class.",
            "Table since we want to do the the transitive closure of the subclass, triples the new tuples that we can conclude in this situation we check if we inserted anything and if we didn't, then we've reached fixed points and the transitive closure is going."
        ],
        [
            "Computers for annotated version.",
            "The same principles for non recursive rule stands.",
            "We need to perform updates to check if we can improve the annotations of existing triples and we can we calculate the new annotations with the Max and the general functions."
        ],
        [
            "And finally we perform several tests.",
            "I will only present 4 here and for testing we use mostly Yago knowledge base.",
            "Data that knowledge base information data.",
            "Since this is base knowledge base that has lots of triples and it is real world data.",
            "Since it is extracted from Wikipedia and that is already annotated with confidence values.",
            "And the first 2 tests only includes triples with the subclass property and only the questions activity rule will be applied to them, so we can see.",
            "How do different methods to perform the transitive closure behave the five?",
            "Tests has a Yahoo data graph in which we will apply all the rules in the annotated draw, DF, and test six.",
            "Also, the full graph closure will be performed, but it has word net 2.0 data."
        ],
        [
            "Now for.",
            "The classical reasoning we can see there that the recursive queries from post Crash, where we're actually faster.",
            "And As for the 2nd test, which is larger, and that's in the first both matrix differential and logarithmic have similar performance.",
            "We also tested for classical reasoning that delved system which uses the differential.",
            "To see how the esquiuel and the system could compare."
        ],
        [
            "For annotated reasoning, we can first of all we can see that the recursive methods for post crash was really good in classical reasoning, but for annotated it performs really bad.",
            "In the first Test it took about 2 hours to end, while the others take less than five minutes.",
            "And for the second tests, it's actually timed out.",
            "We can see.",
            "Again, that the best methods to perform the transitive closure seemed to be the matrix log rhythmic and the differential and the logarithmic seem to scale better."
        ],
        [
            "For full graph closure, we can see once again that the although the differential algorithm does not behave that well.",
            "That's the matrix and logarithmic, keep better."
        ],
        [
            "And for annotated reasoning, once again the recursive is good for classical, but bad for annotated.",
            "Also important is that the differences between the reasoning in classical reasoning and annotated the annotated reasoning includes a large overhead."
        ],
        [
            "So in conclusion, we before we presented full relational database implementation for the annotated raw DF close rules, and we presented also the dependency graph for this rules, concluding that we only need to apply the transitive closure as recursive.",
            "We also concluded that the matrix and logarithmic seem to be better when performing the transitive closure, and that's annotated reasoning has an overhead of.",
            "Between 150 and 250% in posterior tests, we also concluded that if we.",
            "Optimize the way that the configuration of the database server, which for these tests were the default when we install post crash that if we modify and we optimized some parameters that we can have a large improvement of the times and.",
            "That concludes."
        ],
        [
            "This what you are doing is reasoning RDF schema reasoning on on a datasets.",
            "Now are they have datasets and you are doing this by storing.",
            "They are their data into Postgres or yes, yes we have all the triples in a Postgres yes relational schema that you presented on you do reasoning on that by applying the rules.",
            "Yes, OK, then I. I would wonder how how.",
            "This could be used, I mean.",
            "Well, about possible applications because if you have already an RDF data store.",
            "So in order to do this reasoning I should load in all the data in Postgres.",
            "In a relational database onto the reasoning or well.",
            "In our case we wanted to experiment how inference could be performed using.",
            "Database technology and there are including stripple stores that perform inference.",
            "Listening in.",
            "I mean they do in two different ways, one like.",
            "When curing, I mean on the others.",
            "Calculating all of this, yes, yes.",
            "Yes, we actually in the 1st place.",
            "When we started thinking about trying to implement reasoning for annotated data, we started by checking the look at the triple stores.",
            "And.",
            "Some triple stores have performed inference and some of them precompute.",
            "Yes, the triples, but some of them also have to load the triples into memory, and for very large graphs this can be a problem.",
            "And actually in this test we did not include some large graphs that we experimented.",
            "Afterwards, the submission of the paper, but since we try to implement this directly in the relational database, since databases can have properties that can make easier or more or faster the performance of inference in really large graphs with several millions of triples, that is discussable, because this is what you are.",
            "This this young metrics method is on.",
            "It's like their method for graph search.",
            "I mean they they have been.",
            "They have been known for years like yes for search and read for certain I mean some graph databases can do really this very effective.",
            "So I don't even know where the relational database can do this faster.",
            "That they are recursive?",
            "Curious, that's wrong there.",
            "Then you usually work.",
            "I'm sorry.",
            "Wondering about the application of this.",
            "Thank you, thank you.",
            "So I have two quick questions.",
            "The first one is about portability.",
            "It seems that it would be fairly easy to port your solution to my SQL or vertical database system.",
            "Yeah, so have you tried, or if not, why we didn't try yet?",
            "Because this this kind of work.",
            "It's very recently.",
            "Recently this is the first things that we tried, but yes, the actual schema was not to be.",
            "Original angle that we can't.",
            "Modify where it is implemented and we're.",
            "We used Postgres, but it's actually in future work to try to implement for example in Oracle and use all the different capabilities that this.",
            "Database systems have to improve the way that the inferences is performed.",
            "I think it would be interesting to report this to sort of vertical databases like the corner store, because the query executions would be very different and I guess the tradeoffs will be different and quick question is still are going to open source this or do you have any plans open source, open source disclosed?",
            "Well, the code is actually valuable in the link is in the the paper.",
            "The all the client for classical reasoning.",
            "For annotated reasons, everything that I said.",
            "Any final question?",
            "I don't think so, so let's thank the speaker again."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So if you think about RDS later, which is expressing true.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Sometimes it's not enough to express the data use in triples.",
                    "label": 0
                },
                {
                    "sent": "Sometimes we want to add data to the triples themselves, and this map information can have different natures depending of what we wish.",
                    "label": 0
                },
                {
                    "sent": "For example, it can be useful to add meta information of the temporal domain.",
                    "label": 1
                },
                {
                    "sent": "We can say when the triple was created, displayed applications can choose the most recent triples.",
                    "label": 0
                },
                {
                    "sent": "Or we can add and EXPAREL dates to triple so after that date triples will no longer be useful.",
                    "label": 0
                },
                {
                    "sent": "We can also add confidence meta information for triples, in which each triple has a value with the confidence degree.",
                    "label": 1
                },
                {
                    "sent": "In this way we can choose only to use more trustworthy triples, and the RDF Fest definition already has a way to admit information to triples, called replication, and the idea in replication is to assign an identifier to identify.",
                    "label": 0
                },
                {
                    "sent": "Certain triple and then we can make statements using that identifier, adding meta information to the triple.",
                    "label": 0
                },
                {
                    "sent": "However, this has some drawbacks, specially when it comes to inference.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "An alternative is to extend the triples and with an annotation value and then becoming quads, and for the annotated or the FS there is already a semantic specification for inference which was presented last year in this conference.",
                    "label": 1
                },
                {
                    "sent": "And this specification does not use the RDF subset, but rather I'm sorry there are DFS language but rather subset called raw DF which has five properties.",
                    "label": 0
                },
                {
                    "sent": "There's a property subclass type, domain and range and also has a set of inference rules that uses these properties.",
                    "label": 0
                },
                {
                    "sent": "For example of a rule, we can see that if.",
                    "label": 0
                },
                {
                    "sent": "We have a is a property of B and we have two resources that share the property a.",
                    "label": 0
                },
                {
                    "sent": "We can say they also share the property be extending this with annotations we can it's we can see that in the premise each Ripple has an annotation value and the new triple that we conclude as an annotation value equal to the two norm of the annotations of the premise.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "Injective of our work was to implement in the relational database using SQL.",
                    "label": 0
                },
                {
                    "sent": "The full sets of rodef inference rules for annotated data, where the 1st four groups of interest rules are exactly the same wind classical reasoning road F and the fifth group.",
                    "label": 0
                },
                {
                    "sent": "The generalization rule is specific for undetected data, and I will speak about it.",
                    "label": 0
                },
                {
                    "sent": "Later.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In our work we considered only annotations for confidence values where each triple has an annotation with the real number between zero and one where zero is means that the triple is completely false, and one that it's absolutely truth and the normal operation which can have different specifications.",
                    "label": 0
                },
                {
                    "sent": "In our case, what's the minimum G?",
                    "label": 0
                },
                {
                    "sent": "Normally, the meaning that the normal 2 numbers in here.",
                    "label": 0
                },
                {
                    "sent": "It's the equal to the smaller number.",
                    "label": 0
                },
                {
                    "sent": "So too.",
                    "label": 0
                },
                {
                    "sent": "Before.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Implementation first we need to find a way to permanently store triples with annotations and define the way to perform the closure of the annotated graphs.",
                    "label": 0
                },
                {
                    "sent": "And finally, we can graft onto the implementation in SQL and finally also some results.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now for storing the triples we use the schema.",
                    "label": 0
                },
                {
                    "sent": "If you look at the rules we can see that we will need to search for very specific patterns, will either need to search for triples that have specific Roddy of vocabulary property or a triple that has any other property.",
                    "label": 0
                },
                {
                    "sent": "We can call them general Triples in this case.",
                    "label": 0
                },
                {
                    "sent": "Now this general triples will be stored in a table called triples in which triple has an ID belongs to graph.",
                    "label": 0
                },
                {
                    "sent": "And as an annotation, and every triple that has a property that is specific to Roddy F is stored in its own different table.",
                    "label": 0
                },
                {
                    "sent": "As we have here as an example, the table type.",
                    "label": 0
                },
                {
                    "sent": "No.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Another important thing is how we will perform the closure and naive way to do this is to apply all the rules several times and will, until we have nothing you after we conclude after we apply all the rules.",
                    "label": 0
                },
                {
                    "sent": "However, in other works in particular the system web PY.",
                    "label": 0
                },
                {
                    "sent": "We can look at the rule and we see that the rules have dependency relations among them.",
                    "label": 0
                },
                {
                    "sent": "For example, this rule, the subclass inheritance rule.",
                    "label": 0
                },
                {
                    "sent": "If we want this rule to infer all triples that it can possible infer, we need to guarantee that the patterns that we need to find in the premise are all already in the graph.",
                    "label": 0
                },
                {
                    "sent": "So before we apply, this rule will need to apply the same questions.",
                    "label": 0
                },
                {
                    "sent": "Even to rule, which is the only rule that infers hookless triples, and for example the the range duplication rule, which is one of the rules that infers triples with the property type.",
                    "label": 0
                },
                {
                    "sent": "Now in web by they suggested a graph that showed dependency relations between rules for the RDF's inference rules.",
                    "label": 0
                },
                {
                    "sent": "In our case we proposed one for the road DF rules.",
                    "label": 0
                },
                {
                    "sent": "An important thing to look at in this graph is that if we look at rule to be, we can see that it concludes triples with a predicate type, but it also needs.",
                    "label": 0
                },
                {
                    "sent": "The premise triples of the type property, so normally this would mean that this rule is recursive, but we concluded that the both the inheritance rules are important, so we can perform them only once.",
                    "label": 0
                },
                {
                    "sent": "And so the only recursive rules are the transitivity rules.",
                    "label": 0
                },
                {
                    "sent": "We also include the dependencies where non standard use of the road F vocabulary is used.",
                    "label": 0
                },
                {
                    "sent": "This is when property of raw DF is used either in the subject or the object of graph.",
                    "label": 0
                },
                {
                    "sent": "And so if we follow if we respect the dependency relations and we applied rules from the bottom to the top of the graph, we are guaranteed to reach fixed points after we apply it once every rule.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now for the implementation of rules.",
                    "label": 0
                },
                {
                    "sent": "The most simple rules to implement in SQL Arden recursive and the idea is to perform a query that will return all triples that we can conclude and research those triples in the right place.",
                    "label": 0
                },
                {
                    "sent": "In this case in the table triples and if we look at rule we can see that the the triple that we want to conclude has as the same subject and object.",
                    "label": 0
                },
                {
                    "sent": "Then the general triple in the premise and has the predicate equal to the objects of the SU property triple and so in this query we can select these attributes and after that we need to join the places where I either Sue property triples or general to process sorts using as a condition the condition that exists or reading the rule that.",
                    "label": 0
                },
                {
                    "sent": "Subjects of this property is equal to the predicate of the general triple.",
                    "label": 0
                },
                {
                    "sent": "And finally, we also need to guarantee that we do not insert duplicate triples with the not exists clause.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "To extend this for annotated reasoning, we have to look at three different things.",
                    "label": 0
                },
                {
                    "sent": "The first of all is the generalization rule, which states that if we can.",
                    "label": 0
                },
                {
                    "sent": "Infer the same, similar to equal triples with different annotation values.",
                    "label": 1
                },
                {
                    "sent": "We only need to store one of them, the one with in this case, with the larger annotation value.",
                    "label": 1
                },
                {
                    "sent": "And this will we implement this in SQL with the Max aggregate function.",
                    "label": 1
                },
                {
                    "sent": "We also need to take care of the tenorm operations so that we can calculate the annotation value for the new.",
                    "label": 0
                },
                {
                    "sent": "For triples, we do this with the user defined function that has gets 2 double values and returns the minimum number.",
                    "label": 0
                },
                {
                    "sent": "And finally we need also to update the annotations of existing triples.",
                    "label": 0
                },
                {
                    "sent": "So we want to make sure that after we.",
                    "label": 0
                },
                {
                    "sent": "Perform graft closure.",
                    "label": 0
                },
                {
                    "sent": "All the triples have not only correct annotation values, but also the best annotation values that can.",
                    "label": 0
                },
                {
                    "sent": "They can have.",
                    "label": 0
                },
                {
                    "sent": "Part of this is guaranteed by the generalization rule, where if we conclude the new triple, why different paths in the graph we choose only the one that has the best annotation value, but it is also possible sometimes to conclude triple that already exists in the graph.",
                    "label": 0
                },
                {
                    "sent": "Prior to the application of the rule and we can conclude it with a different annotation, possibly better.",
                    "label": 0
                },
                {
                    "sent": "So we need to make sure that even existing triples have the best annotation updating.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "When it is necessary.",
                    "label": 0
                },
                {
                    "sent": "So this is just a skeleton of implementation for annotated reasoning and first of all, we performed that update phase where we perform the query representing the rule and we select only the triples that we can conclude that already exists in the graph and if the triples that we concluded have best better.",
                    "label": 0
                },
                {
                    "sent": "Annotation value we applied to the existing triples.",
                    "label": 0
                },
                {
                    "sent": "After that we can perform the insertion of the triples that we can infer and do not exist, and we can make sure that every triple has the maximum value that's possible.",
                    "label": 0
                },
                {
                    "sent": "So we conclude the new annotation values using the two norm for calculating the value and the Max for selecting only the maximum value of all.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Possible.",
                    "label": 0
                },
                {
                    "sent": "Now another thing to be aware of is that is there recursive rules which for large amounts of data if not implemented properly, can can get tricky and the transitive closure.",
                    "label": 0
                },
                {
                    "sent": "Of a graph is a problem that has been studied for for some years now, and there are several iterative algorithms and naive way to perform the transitive closure of a graph is to having R as the original graph or the original relation.",
                    "label": 0
                },
                {
                    "sent": "'cause of the database and R Plus the transitive closure in each iteration the transitive closure it's equal to all the.",
                    "label": 1
                },
                {
                    "sent": "The two poles are everything that is in the original relation, plus every triple or every path in the graph that we can conclude in this iteration.",
                    "label": 0
                },
                {
                    "sent": "And there is this matrix algorithm that is an improvement to the naive algorithm where we do not use.",
                    "label": 1
                },
                {
                    "sent": "We do not keep using the original relation, but we always use the transitive closure relation, so we can infer we we perform joins with.",
                    "label": 0
                },
                {
                    "sent": "For larger graphs, we can infer more triples, or in each iteration, and we can form the transitive closure in lesser.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Rationes we also implemented semi naive method which is a bit more complex.",
                    "label": 0
                },
                {
                    "sent": "The differentials me naive which is a different version that the system DLV uses and a log arhythmic algorithm which tries to perform the closure in even less iterations and the metrics algorithm.",
                    "label": 0
                },
                {
                    "sent": "And finally we also used recursive queries.",
                    "label": 0
                },
                {
                    "sent": "The construct from the post crash.",
                    "label": 0
                },
                {
                    "sent": "A relational database system.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So this is a example of the implementation of the matrix algorithm.",
                    "label": 0
                },
                {
                    "sent": "We we have cycle.",
                    "label": 0
                },
                {
                    "sent": "In each iteration we insert in this case in the food class.",
                    "label": 0
                },
                {
                    "sent": "Table since we want to do the the transitive closure of the subclass, triples the new tuples that we can conclude in this situation we check if we inserted anything and if we didn't, then we've reached fixed points and the transitive closure is going.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Computers for annotated version.",
                    "label": 0
                },
                {
                    "sent": "The same principles for non recursive rule stands.",
                    "label": 0
                },
                {
                    "sent": "We need to perform updates to check if we can improve the annotations of existing triples and we can we calculate the new annotations with the Max and the general functions.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And finally we perform several tests.",
                    "label": 0
                },
                {
                    "sent": "I will only present 4 here and for testing we use mostly Yago knowledge base.",
                    "label": 0
                },
                {
                    "sent": "Data that knowledge base information data.",
                    "label": 0
                },
                {
                    "sent": "Since this is base knowledge base that has lots of triples and it is real world data.",
                    "label": 0
                },
                {
                    "sent": "Since it is extracted from Wikipedia and that is already annotated with confidence values.",
                    "label": 0
                },
                {
                    "sent": "And the first 2 tests only includes triples with the subclass property and only the questions activity rule will be applied to them, so we can see.",
                    "label": 0
                },
                {
                    "sent": "How do different methods to perform the transitive closure behave the five?",
                    "label": 0
                },
                {
                    "sent": "Tests has a Yahoo data graph in which we will apply all the rules in the annotated draw, DF, and test six.",
                    "label": 0
                },
                {
                    "sent": "Also, the full graph closure will be performed, but it has word net 2.0 data.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now for.",
                    "label": 0
                },
                {
                    "sent": "The classical reasoning we can see there that the recursive queries from post Crash, where we're actually faster.",
                    "label": 0
                },
                {
                    "sent": "And As for the 2nd test, which is larger, and that's in the first both matrix differential and logarithmic have similar performance.",
                    "label": 0
                },
                {
                    "sent": "We also tested for classical reasoning that delved system which uses the differential.",
                    "label": 0
                },
                {
                    "sent": "To see how the esquiuel and the system could compare.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "For annotated reasoning, we can first of all we can see that the recursive methods for post crash was really good in classical reasoning, but for annotated it performs really bad.",
                    "label": 0
                },
                {
                    "sent": "In the first Test it took about 2 hours to end, while the others take less than five minutes.",
                    "label": 0
                },
                {
                    "sent": "And for the second tests, it's actually timed out.",
                    "label": 0
                },
                {
                    "sent": "We can see.",
                    "label": 0
                },
                {
                    "sent": "Again, that the best methods to perform the transitive closure seemed to be the matrix log rhythmic and the differential and the logarithmic seem to scale better.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "For full graph closure, we can see once again that the although the differential algorithm does not behave that well.",
                    "label": 0
                },
                {
                    "sent": "That's the matrix and logarithmic, keep better.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And for annotated reasoning, once again the recursive is good for classical, but bad for annotated.",
                    "label": 0
                },
                {
                    "sent": "Also important is that the differences between the reasoning in classical reasoning and annotated the annotated reasoning includes a large overhead.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So in conclusion, we before we presented full relational database implementation for the annotated raw DF close rules, and we presented also the dependency graph for this rules, concluding that we only need to apply the transitive closure as recursive.",
                    "label": 1
                },
                {
                    "sent": "We also concluded that the matrix and logarithmic seem to be better when performing the transitive closure, and that's annotated reasoning has an overhead of.",
                    "label": 0
                },
                {
                    "sent": "Between 150 and 250% in posterior tests, we also concluded that if we.",
                    "label": 0
                },
                {
                    "sent": "Optimize the way that the configuration of the database server, which for these tests were the default when we install post crash that if we modify and we optimized some parameters that we can have a large improvement of the times and.",
                    "label": 0
                },
                {
                    "sent": "That concludes.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "This what you are doing is reasoning RDF schema reasoning on on a datasets.",
                    "label": 1
                },
                {
                    "sent": "Now are they have datasets and you are doing this by storing.",
                    "label": 0
                },
                {
                    "sent": "They are their data into Postgres or yes, yes we have all the triples in a Postgres yes relational schema that you presented on you do reasoning on that by applying the rules.",
                    "label": 0
                },
                {
                    "sent": "Yes, OK, then I. I would wonder how how.",
                    "label": 0
                },
                {
                    "sent": "This could be used, I mean.",
                    "label": 0
                },
                {
                    "sent": "Well, about possible applications because if you have already an RDF data store.",
                    "label": 0
                },
                {
                    "sent": "So in order to do this reasoning I should load in all the data in Postgres.",
                    "label": 0
                },
                {
                    "sent": "In a relational database onto the reasoning or well.",
                    "label": 0
                },
                {
                    "sent": "In our case we wanted to experiment how inference could be performed using.",
                    "label": 0
                },
                {
                    "sent": "Database technology and there are including stripple stores that perform inference.",
                    "label": 0
                },
                {
                    "sent": "Listening in.",
                    "label": 0
                },
                {
                    "sent": "I mean they do in two different ways, one like.",
                    "label": 0
                },
                {
                    "sent": "When curing, I mean on the others.",
                    "label": 0
                },
                {
                    "sent": "Calculating all of this, yes, yes.",
                    "label": 0
                },
                {
                    "sent": "Yes, we actually in the 1st place.",
                    "label": 0
                },
                {
                    "sent": "When we started thinking about trying to implement reasoning for annotated data, we started by checking the look at the triple stores.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "Some triple stores have performed inference and some of them precompute.",
                    "label": 0
                },
                {
                    "sent": "Yes, the triples, but some of them also have to load the triples into memory, and for very large graphs this can be a problem.",
                    "label": 0
                },
                {
                    "sent": "And actually in this test we did not include some large graphs that we experimented.",
                    "label": 0
                },
                {
                    "sent": "Afterwards, the submission of the paper, but since we try to implement this directly in the relational database, since databases can have properties that can make easier or more or faster the performance of inference in really large graphs with several millions of triples, that is discussable, because this is what you are.",
                    "label": 0
                },
                {
                    "sent": "This this young metrics method is on.",
                    "label": 0
                },
                {
                    "sent": "It's like their method for graph search.",
                    "label": 0
                },
                {
                    "sent": "I mean they they have been.",
                    "label": 0
                },
                {
                    "sent": "They have been known for years like yes for search and read for certain I mean some graph databases can do really this very effective.",
                    "label": 0
                },
                {
                    "sent": "So I don't even know where the relational database can do this faster.",
                    "label": 0
                },
                {
                    "sent": "That they are recursive?",
                    "label": 0
                },
                {
                    "sent": "Curious, that's wrong there.",
                    "label": 0
                },
                {
                    "sent": "Then you usually work.",
                    "label": 0
                },
                {
                    "sent": "I'm sorry.",
                    "label": 0
                },
                {
                    "sent": "Wondering about the application of this.",
                    "label": 0
                },
                {
                    "sent": "Thank you, thank you.",
                    "label": 0
                },
                {
                    "sent": "So I have two quick questions.",
                    "label": 0
                },
                {
                    "sent": "The first one is about portability.",
                    "label": 0
                },
                {
                    "sent": "It seems that it would be fairly easy to port your solution to my SQL or vertical database system.",
                    "label": 0
                },
                {
                    "sent": "Yeah, so have you tried, or if not, why we didn't try yet?",
                    "label": 0
                },
                {
                    "sent": "Because this this kind of work.",
                    "label": 0
                },
                {
                    "sent": "It's very recently.",
                    "label": 0
                },
                {
                    "sent": "Recently this is the first things that we tried, but yes, the actual schema was not to be.",
                    "label": 0
                },
                {
                    "sent": "Original angle that we can't.",
                    "label": 0
                },
                {
                    "sent": "Modify where it is implemented and we're.",
                    "label": 0
                },
                {
                    "sent": "We used Postgres, but it's actually in future work to try to implement for example in Oracle and use all the different capabilities that this.",
                    "label": 0
                },
                {
                    "sent": "Database systems have to improve the way that the inferences is performed.",
                    "label": 0
                },
                {
                    "sent": "I think it would be interesting to report this to sort of vertical databases like the corner store, because the query executions would be very different and I guess the tradeoffs will be different and quick question is still are going to open source this or do you have any plans open source, open source disclosed?",
                    "label": 0
                },
                {
                    "sent": "Well, the code is actually valuable in the link is in the the paper.",
                    "label": 0
                },
                {
                    "sent": "The all the client for classical reasoning.",
                    "label": 0
                },
                {
                    "sent": "For annotated reasons, everything that I said.",
                    "label": 0
                },
                {
                    "sent": "Any final question?",
                    "label": 0
                },
                {
                    "sent": "I don't think so, so let's thank the speaker again.",
                    "label": 0
                }
            ]
        }
    }
}