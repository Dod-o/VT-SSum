{
    "id": "cuxqagb5dreywamtlpsxvu5vwbcagzdt",
    "title": "XML Compression and Search",
    "info": {
        "author": [
            "Paolo Ferragina, Dipartimento di Informatica, University of Pisa"
        ],
        "published": "Feb. 25, 2007",
        "recorded": "May 2006",
        "category": [
            "Top->Computer Science->Web Search",
            "Top->Computer Science->Information Retrieval",
            "Top->Computer Science->Search Engines"
        ]
    },
    "url": "http://videolectures.net/fws06_ferragina_xcs/",
    "segmentation": [
        [
            "Is not slower at all with red."
        ],
        [
            "They do them compressing data.",
            "OK, so actually you have the same power of the original data structure, but the data can be kept in compressed form, so you don't want to uncompress the whole data when you have been there.",
            "This was a Seminole paper and after that appeared a number of papers in these last years.",
            "In these six years, and there is this very nice survey by Navarro and Makinen that cites more than 50 papers about this subject.",
            "Now.",
            "Now, in this talk I will take the start from these ideas and I will move to XML."
        ],
        [
            "We already know what XML he is because of the talk of Garrard and actually just to back up what we knew is that XML file are consist of textual data, content, data and tags that are indicated here in red and tax actually means some meta information about the data and when we want to do searches we want to do content searches and structural searches or both.",
            "Combined means that we want to do searches on the black part and on the red part.",
            "OK, now as computer scientists and as algorithmic."
        ],
        [
            "People we prefer to look at as XML like a tree elaborate three in which we have tax into the internal nodes, maybe attributes and we have content data into the leaves.",
            "So these drinks maybe of variable length and especially the leaves may be of big length just because they're content data.",
            "Now if we consider this view of the documents we have that document exploration actually consists of three navigation and the document search actually consist of.",
            "Lovely support search.",
            "What I mean is the following.",
            "For example, if I search for this path, this means that I want to find all the articles whose author is note or if I search for this sub paths I want to search for all the publications that have approved as an author or if I search for this sub.",
            "But I want to search for all the years in which a book was published.",
            "So any search or at least this kind of searches that I will consider which is a tiny subset of X path.",
            "But I will comment on this later on.",
            "Will be formed by a sequence of continuous labels, possibly ending up into a leaf, and in a later we will search for something OK Now."
        ],
        [
            "Left with therefore formalize a problem from an algorithm IK POV.",
            "I give you elaborate 3D and I want to find a compressed representation of these three such that some operations are supported efficiently.",
            "One operation are is navigational.",
            "So I want to navigate the tree by finding the parent or the child according to some level.",
            "I want to do sub searches.",
            "That is, they give you a sequence of levels and I want to identify this sequence of labels inside the tree, anchored anywhere, not necessarily starting from the root.",
            "I want to support content searches.",
            "That is, I give you a support and a string and I want to search this string descending from this sub.",
            "But and I want to do visualization operations.",
            "That is, I give you a node and I want to decompress the whole subtree descending from this node and they want to do all this time this thing efficiently, OK, efficiently here.",
            "Let's leave the things in a rough way means that I don't want to compress the whole tree.",
            "OK now this thing is.",
            "It can be a basic stuff for XML native search engines with we heard about by Garrard and that is you could use this kind of tool in order to estimate query size and so do some sort of optimizations or just to store the XML files in compressed form and then retrieve parts of these XML files.",
            "OK, now the literature is huge and you can find a lot of results about this kind of stuff, but most of the results were experimental.",
            "People were interested in designing XML, our compressors.",
            "But if you use this kind of approach, you achieve a very good space occupancy, but you need to compress the whole data.",
            "People were interested in Queryable compressor, so that means I use less good compressor and they can do a faster search, but they incur in the whole scan of the data so they need to look to the to hold the data in order to find to solve the queries so they are worse compression and not very fast.",
            "Other people were interested mainly in fast operations, so they designed the so called summary indices so that actually they are suffix trees built over all the paths present in the tree.",
            "So they are huge insides, so they are very fast, but they occupy too much space and if you look theoretically, for example to the Seminole Paper of Jakobsen Fox 89, you find solution about the storage of trees such assassin trees, and these are solutions allow you to navigate the tree.",
            "But they do not support content searches.",
            "They do not support supper searches and they are not able to support laboratories where the labels of the nodes may be arbitrary symbols.",
            "OK, they are actually binary trees without any levels now."
        ],
        [
            "What we did in Fox was to show a trivial solution.",
            "So we show that there exists a trivial way of taking the tree and we call it XX BW transform.",
            "So a trivial way of taking a tree and transform into two arrays such that if you want to just if you are just interested in compression, what we tell you is the following.",
            "You take the tree, you get the two arrays and then you use on these two arrays any known string compressor.",
            "Easy peasy whatever, or if you are interested in doing indexing, what we tell you is the following that construct the two arrays and then implement on these two arrays.",
            "Two basic operations of algorithmics that is rank and select primitives over arrays.",
            "Rank means that they give you a position and symbol, and I want to count how many times this simple occurs in the prefix of the array.",
            "So this is the rank, the select is the inverse, so I give you a. I give you 10 and I want to find the 10th A in the string.",
            "OK so they are very basic.",
            "There is a huge literature about this kind of stuff in algorithmics and we show that actually searching, navigating whatever in the tree boils down to implement efficiently this rank and select operations.",
            "OK, so in order to convince you that this is a very simple approach, I will not go through theorems, entropy bounds, efficiency bounds.",
            "I referred you to the original paper.",
            "Here I will try just to convince you that this is really effective and I will show you some experimental results.",
            "So for the theory looks to folks."
        ],
        [
            "So the idea is as follows.",
            "So let us consider elaborate tree.",
            "Every node is a label and they can be strings in XML.",
            "So what I suggest use the following priority, do a pre-order visit of the tree and at anytime you find the node in the visit you write down the level of the node and the upward path.",
            "In this case is empty because it's the root.",
            "So then I have a B and the upward path is C. Just see and so on and so forth.",
            "You find D so that.",
            "No parties BC so actually you write down the order visit.",
            "Here are the labels of the nodes in the order you find during the pre order visit and these are the upward paths.",
            "I'm showing this only for simplicity of exposition.",
            "They will not be stored because they can clearly be quadratic in space.",
            "OK, now this is the first step.",
            "After that I have written down this what I tell you is the following.",
            "Let us sort the rows of these metrics according to this component.",
            "So according to the upward paths.",
            "I did the."
        ],
        [
            "Sort, so if you sort the previous one, you get this, so you notice that you are sorting according to this path OK, and the corresponding labels have followed the second component.",
            "After that you did this sort.",
            "What I tell you is that you need to add some other information in order to have the structure of the tree and what you need is."
        ],
        [
            "Just a binary array for every node.",
            "For example, this is BC.",
            "Is that one?",
            "I just had one because this is the last children of its parent, so I put a one for the last child.",
            "They put a 0 for all the other children.",
            "Now our transform is this one, so I'm saying that you need just to keep the permutation of the node labels built in.",
            "This way you need to keep the binary representation and what we were able to show in folks was the following that actually you can construct this in linear time, so optimal time this is an optimal representation of the treeby 'cause you need to store just the labels and you pay 1 bit per node and up to lower order terms, so you cannot do better.",
            "OK, by combinatorial arguments, and since you can compute this in optimal linear time, this is an equivalent representation of the tree, but you are not using pointers, OK?",
            "Now what you can do with this one, it seems that you are messing up things.",
            "You are just moving things and you are losing everything nice about the tree structure.",
            "Now, OK, let's start from this point and."
        ],
        [
            "Then I will be back to them.",
            "To the indexing part to the navigation and consider a very tiny example.",
            "So I have a XML document.",
            "I construct the tree and I construct the tree in a special way in the sense that do any tag I prefix a minus symbol.",
            "This is important for practical stuff to any attribute value and attribute name.",
            "I prefix the hat symbol and for what concerns the leaves I just divide every leaf into two nodes.",
            "One is the equal node and the other is the content of the leaf, which is prefixed by a new character.",
            "This is just for practical stuff.",
            "Now if you have this tree and you apply the transform that I described before, what you get is the following.",
            "This is the bit string.",
            "This is the levels of the tree according to the order that I've got.",
            "I've got for that word parts, so this would be the transform.",
            "OK, while this transform is interesting and we can look on this example immediately for the following reason.",
            "Because we have a spatial clustering of the information.",
            "Now if you look to this part of a sulfa you will find here only tag names, attribute names and the equal symbol.",
            "If you look to the last part.",
            "Of alfalfa, which is this one according to what we have stored, you get only content data and the nice stuff.",
            "At least then I will show you more properties.",
            "Is that the first equal corresponds to the first content data.",
            "The second equal correspond to the second content data and so on and so forth.",
            "Also, if you look to the sorting, you find that all the entries with the sand from the book Item Book Tag are contiguous because they are stored to get in this part of a sulfa if you take all the entries with Ascend from biblio they are contiguous and there are this one.",
            "So according to this kind of sorting you are clustering data.",
            "You are having a lot what is usually called in data compression.",
            "You are getting strings which are local homogeneous and since they are local emergency they are very good.",
            "Lee compressed that you can.",
            "Compressed very high OK."
        ],
        [
            "Now these are is the first set of experiments that we did take the XML tree transform, get the two arrays and compress using any string compressor that you have in the literature.",
            "So you have not to carry it to take care about complicated stuff that you can find.",
            "This kind of compress or SMP PM or X meal, whatever.",
            "What you are telling you is just to transform and compress.",
            "So this is a very trivial thing, but if you experiment you will find that sometimes we are better than what was known as the best compressors in the literature.",
            "Sometimes we are a little bit worse.",
            "OK, OK, this is permits could be promising, because just doing the transform and the compression we could get some the best known bounds in the literature and the approach is very simple.",
            "But from my point of view I was not really satisfied because if you compare the red bar which is our results.",
            "With, for example, the yellow bar which is PPM is a standard string compressor.",
            "You almost get the same compression.",
            "The difference is just 5%, but we are exploiting the tree data.",
            "The tree information PPM does not know anything about the file, but in any case it achieves a very good compression, so this is promising for compression POV, but it's not really very astonishing.",
            "OK, so this could be a sad moral of this talk.",
            "But this was not my point.",
            "I didn't want to show you a very good compressor for XML data.",
            "I want to show you a way of compressing data and searching into this data and hear the stories completely different cause we need to add more information in order to access this data and do not compress it.",
            "So."
        ],
        [
            "I need to show more properties.",
            "OK about this transform and this makes the transform.",
            "I think very interesting.",
            "Assume that I pick up a node B and the upward path is just see this is the node and this is its upward path.",
            "If we will look to the children DC, these children are contiguous in the metrics Huawei.",
            "Just because we are doing a pre order visit and we are moving in a stable sort.",
            "So children of a node are contiguous.",
            "Now let us speak another node.",
            "This is B, which is exactly the same as this be because it is as label B and upward path is just C and this is this note.",
            "So if you take the children are again contiguous because there's survey shun before.",
            "But the nice part is that the blue children comes after the green children, so they preserve the order of the original parents, so children preserve the order of the original parent.",
            "If they are the same, they come from the same part.",
            "This is a very strong structural properties that allow us to navigate over these three in a very simple way.",
            "So assume that they want to go from here to here.",
            "The algorithm that I want to that I need to do implement is very simple, so take this B and computer rank.",
            "That is, compute how many bees you have above.",
            "In this case you have two bees, so you have two.",
            "So the second step of the algorithm is to start.",
            "From the set of rows, prefix it by B and just to do a selection of the second one, which is here.",
            "So you start from this rule and you select the 2nd one.",
            "Second, because this is 2.",
            "So actually, in order to navigate with what I'm telling you is just to do a rank and select.",
            "Yeah.",
            "Sure, So what you have to keep out is not this one, because this would be too costly.",
            "You just need to keep for every distinct letters for any distinct labels.",
            "The first role which is prefixed by this letter.",
            "So you just need to keep for a 14B44C whatever.",
            "OK, so you need an array whose size is proportional to the number of distinct levels, which is usually very small OK. Good question.",
            "So when you have this you have just implemented rank and select so you look at the literature you use any data structure you want on this array in this array and what you are doing is just we are able to navigate of these three without using pointers.",
            "OK, now in the literature and I will come back in the next part of the talk.",
            "There are solutions that are able to compress a race and do rank and select.",
            "So you could compress these two things and do ranks and select."
        ],
        [
            "Now the nice thing is that we were able to show that you can not only navigate, but you can actually search for subparts.",
            "So assume that they give you BD and they want to search for all the occurrences of VD in these arrays, repeating the ideas that have shown before what you are able to do is that is that you can find a block of rows which are prefixed by DB very efficiently, and given this block of rows, what you can do is just buy ranks.",
            "You can count the number of ones and by the number of once you have.",
            "The number of occurrences of that subpart.",
            "These are really a little bit technical, so you have to refer to the paper OK, but essentially by the same ideas you can do the same, yeah.",
            "Dee Dee I could show you in the sense that he is the same idea that I did by navigation, but in this case you have not just to do navigation, you have to do navigation constrained by the letters so you do OK. Now again, what I'm telling you is that given two arrays, these two arrays by storing rank and select primitives, you can do search for subparts.",
            "OK, so you can prove entropy bounds.",
            "You can prove whatever, but the point was that can we implement this and see what happens.",
            "So this."
        ],
        [
            "Is really interesting, so here the blue bar is just what usually XML search engines do, not.",
            "If so, they take the text they compress, they assign integers tokens to tags and they compressed by Hoffman.",
            "Today the content part this is the blue OK, here we are the green part.",
            "The Red Band is the sparring partner.",
            "So what you can do the best using the best compressor to date.",
            "But obviously if you have a compressor you cannot search OK.",
            "So using this amount of space, which is a little bit more than a compressor, you can keep compressor data.",
            "You can search for sub path, you can search for subaquatic content and this improvement is significant because it can be 36% absolute over the original and the known approaches and the nice part is that you can do counting and navigation in milliseconds because you do not need to decompress the whole data.",
            "So you just going into some parts of the file and the compressed some part of the file.",
            "You can find that information you wish.",
            "Here I'm not talking about X query, I'm not talking about we queries, complicated stuff, I'm talking about simple support searches OK?",
            "And if you turn these numbers into how many space you paper node, this is really interesting because on the BLP we pay one byte .75 bytes per node and news we pay almost about four bytes per node because it's more the content data.",
            "But this is I think very interesting so you pay less than one integer per node, OK?",
            "Anne."
        ],
        [
            "So.",
            "What is the picture just to give you the idea?",
            "So now in the literature we have two streams of papers.",
            "One regards text and the other regards laboratories on the text.",
            "If you open any textbook you find suffix trees and suffix arrays.",
            "Data structure to support substring searches and if you open the textbook for label trees you find the suffix tree over three, which is actually a suffix tree over all the paths is very well known that this data structure.",
            "Powerful, but they occupy a huge amount of space so really huge amount of space now.",
            "Actually the\nOf research that I have very briefly presented here tells you to do a different stuff.",
            "So tells you to transform the data in some way.",
            "Here I've shown the so called ex BW on the string is very well known.",
            "Borrow singular, transform the base of bzip compressor and after that you make this transform.",
            "You just need to implement rank and select primitives.",
            "These transforms so you can do substring searches, so this representation is equivalent to suffix trees and suffix arrays, but the space is compressed and many papers have shown that from a computational point of view you get the same speed as in tatic speed, so this is really very powerful and this explains you why in the last year if you open proceedings, any proceeding you will find papers telling you about rank and select over unbounded alphabets rank and selecting two entropy bounds.",
            "The reason is actually these two lines of papers.",
            "Because if you are able to show that you can implement rank and select efficiently in time and space, you can plug these tools into these ideas and you can get very powerful stuff either for strings or for trees.",
            "So this is actually a way of reducing the complexity of the problem from strings and trees to just binary race and do very basic operations, yes.",
            "This was my last phrase in the sense that what we're doing now is just to continue this line of search and go to more complicated data structure.",
            "What we have now is that we are able to do this on Dax Labra docs, which are actually automata, and so they can be used for example for feature recognition and storing speech.",
            "Different stuff in compressed space and do search searches on these automata.",
            "Yeah, but in general graph I don't know.",
            "And this is all.",
            "And more questions.",
            "So it wasn't what you build the suffix array.",
            "Sorry, So what you build isn't that the suffix array?",
            "Now, if you would have built the suffix array, your space would be four times the text, so you would have got got 400%.",
            "Labels or but just for building.",
            "After that you built the data you'd have not to store this, you just called this.",
            "In this compress it in some way.",
            "So this is just for the building process.",
            "Then you throw away.",
            "Actually during the building process you do not need to explicitly have this, otherwise you would have quadratic space in the building stuff and would be too much in the paper.",
            "In the Fox paper we showed to do this in linear space in linear time.",
            "For King of Main memory I can do my poopy corpus in on four giga the construction you would need the.",
            "You can do this in at most one giga so 1/4 OK because the now the best algorithms known for building suffix arrays, because actually this is a little bit like this require four times the text, so yeah.",
            "Sure.",
            "You come into being more and be on the challenge on actually navigating and get into the data and if you can locate the data very fast.",
            "But I have to be more done in terms of assessing the cost of decompressing more of the tree.",
            "So actually what you can show is that if you search for example for a part of three levels.",
            "According to this, you just need to do 3 assessors to these arrays to get there.",
            "You have work to do when you want to do anything with that data, sure, so you have some position an from this position.",
            "You say what you can do by going down three.",
            "At that point you will pay a cost which is linear in the size of the subtree.",
            "Yes, so impossibly linear random access, because I'm sure that issue is a random access file.",
            "Yeah, sure yes.",
            "Well in the file you will get an internal.",
            "This is a big issue of this complexity in this so.",
            "The bigger challenge of this compressor these instances to move them to be cache oblivious or cache sensitive.",
            "Till now we don't know how to do this.",
            "And there was a question.",
            "I wanted to know about when you.",
            "When you feel that that can visit the next 4 after that, when you change the tree in somewhere and want to at this point we didn't consider incremental updates or changes at this point, just static stuff.",
            "So you get the data you build this stuff and that's it.",
            "If something changes at this point, you have to rebuild from scratch.",
            "OK?",
            "That is exactly what happens with the bar singular transform.",
            "If you change the file, you have to compress from scratch.",
            "OK, just one block in the bar, single transform, But anyway, sorry so late when you build it and you have many the same suffixes.",
            "Does that make it harder to build the tree?",
            "So imagine you have many.",
            "Peter documents, do you want an answer from a theoretical point of view or from a practical?",
            "Because in theory, no matter the optimal algorithms in practice depends on the album.",
            "There are now there is a family of algorithms that are able to tackle also very long shared substrings.",
            "They're called lightweight because they're able to occupy small space and be very robust about the repetition of the substrings.",
            "But in the worst case that the strange stuff is that the fastest algorithms today are not the best algorithms.",
            "In theory they could be quadratic interior, but they are the fastest because they are able to show it to exploit in the cache much better than the theoretical algorithms.",
            "OK."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is not slower at all with red.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "They do them compressing data.",
                    "label": 0
                },
                {
                    "sent": "OK, so actually you have the same power of the original data structure, but the data can be kept in compressed form, so you don't want to uncompress the whole data when you have been there.",
                    "label": 0
                },
                {
                    "sent": "This was a Seminole paper and after that appeared a number of papers in these last years.",
                    "label": 0
                },
                {
                    "sent": "In these six years, and there is this very nice survey by Navarro and Makinen that cites more than 50 papers about this subject.",
                    "label": 1
                },
                {
                    "sent": "Now.",
                    "label": 0
                },
                {
                    "sent": "Now, in this talk I will take the start from these ideas and I will move to XML.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We already know what XML he is because of the talk of Garrard and actually just to back up what we knew is that XML file are consist of textual data, content, data and tags that are indicated here in red and tax actually means some meta information about the data and when we want to do searches we want to do content searches and structural searches or both.",
                    "label": 0
                },
                {
                    "sent": "Combined means that we want to do searches on the black part and on the red part.",
                    "label": 0
                },
                {
                    "sent": "OK, now as computer scientists and as algorithmic.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "People we prefer to look at as XML like a tree elaborate three in which we have tax into the internal nodes, maybe attributes and we have content data into the leaves.",
                    "label": 0
                },
                {
                    "sent": "So these drinks maybe of variable length and especially the leaves may be of big length just because they're content data.",
                    "label": 0
                },
                {
                    "sent": "Now if we consider this view of the documents we have that document exploration actually consists of three navigation and the document search actually consist of.",
                    "label": 0
                },
                {
                    "sent": "Lovely support search.",
                    "label": 0
                },
                {
                    "sent": "What I mean is the following.",
                    "label": 0
                },
                {
                    "sent": "For example, if I search for this path, this means that I want to find all the articles whose author is note or if I search for this sub paths I want to search for all the publications that have approved as an author or if I search for this sub.",
                    "label": 0
                },
                {
                    "sent": "But I want to search for all the years in which a book was published.",
                    "label": 0
                },
                {
                    "sent": "So any search or at least this kind of searches that I will consider which is a tiny subset of X path.",
                    "label": 0
                },
                {
                    "sent": "But I will comment on this later on.",
                    "label": 0
                },
                {
                    "sent": "Will be formed by a sequence of continuous labels, possibly ending up into a leaf, and in a later we will search for something OK Now.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Left with therefore formalize a problem from an algorithm IK POV.",
                    "label": 0
                },
                {
                    "sent": "I give you elaborate 3D and I want to find a compressed representation of these three such that some operations are supported efficiently.",
                    "label": 0
                },
                {
                    "sent": "One operation are is navigational.",
                    "label": 0
                },
                {
                    "sent": "So I want to navigate the tree by finding the parent or the child according to some level.",
                    "label": 0
                },
                {
                    "sent": "I want to do sub searches.",
                    "label": 0
                },
                {
                    "sent": "That is, they give you a sequence of levels and I want to identify this sequence of labels inside the tree, anchored anywhere, not necessarily starting from the root.",
                    "label": 0
                },
                {
                    "sent": "I want to support content searches.",
                    "label": 0
                },
                {
                    "sent": "That is, I give you a support and a string and I want to search this string descending from this sub.",
                    "label": 0
                },
                {
                    "sent": "But and I want to do visualization operations.",
                    "label": 0
                },
                {
                    "sent": "That is, I give you a node and I want to decompress the whole subtree descending from this node and they want to do all this time this thing efficiently, OK, efficiently here.",
                    "label": 0
                },
                {
                    "sent": "Let's leave the things in a rough way means that I don't want to compress the whole tree.",
                    "label": 0
                },
                {
                    "sent": "OK now this thing is.",
                    "label": 0
                },
                {
                    "sent": "It can be a basic stuff for XML native search engines with we heard about by Garrard and that is you could use this kind of tool in order to estimate query size and so do some sort of optimizations or just to store the XML files in compressed form and then retrieve parts of these XML files.",
                    "label": 0
                },
                {
                    "sent": "OK, now the literature is huge and you can find a lot of results about this kind of stuff, but most of the results were experimental.",
                    "label": 0
                },
                {
                    "sent": "People were interested in designing XML, our compressors.",
                    "label": 0
                },
                {
                    "sent": "But if you use this kind of approach, you achieve a very good space occupancy, but you need to compress the whole data.",
                    "label": 0
                },
                {
                    "sent": "People were interested in Queryable compressor, so that means I use less good compressor and they can do a faster search, but they incur in the whole scan of the data so they need to look to the to hold the data in order to find to solve the queries so they are worse compression and not very fast.",
                    "label": 0
                },
                {
                    "sent": "Other people were interested mainly in fast operations, so they designed the so called summary indices so that actually they are suffix trees built over all the paths present in the tree.",
                    "label": 0
                },
                {
                    "sent": "So they are huge insides, so they are very fast, but they occupy too much space and if you look theoretically, for example to the Seminole Paper of Jakobsen Fox 89, you find solution about the storage of trees such assassin trees, and these are solutions allow you to navigate the tree.",
                    "label": 0
                },
                {
                    "sent": "But they do not support content searches.",
                    "label": 0
                },
                {
                    "sent": "They do not support supper searches and they are not able to support laboratories where the labels of the nodes may be arbitrary symbols.",
                    "label": 0
                },
                {
                    "sent": "OK, they are actually binary trees without any levels now.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "What we did in Fox was to show a trivial solution.",
                    "label": 0
                },
                {
                    "sent": "So we show that there exists a trivial way of taking the tree and we call it XX BW transform.",
                    "label": 0
                },
                {
                    "sent": "So a trivial way of taking a tree and transform into two arrays such that if you want to just if you are just interested in compression, what we tell you is the following.",
                    "label": 0
                },
                {
                    "sent": "You take the tree, you get the two arrays and then you use on these two arrays any known string compressor.",
                    "label": 0
                },
                {
                    "sent": "Easy peasy whatever, or if you are interested in doing indexing, what we tell you is the following that construct the two arrays and then implement on these two arrays.",
                    "label": 0
                },
                {
                    "sent": "Two basic operations of algorithmics that is rank and select primitives over arrays.",
                    "label": 0
                },
                {
                    "sent": "Rank means that they give you a position and symbol, and I want to count how many times this simple occurs in the prefix of the array.",
                    "label": 0
                },
                {
                    "sent": "So this is the rank, the select is the inverse, so I give you a. I give you 10 and I want to find the 10th A in the string.",
                    "label": 0
                },
                {
                    "sent": "OK so they are very basic.",
                    "label": 0
                },
                {
                    "sent": "There is a huge literature about this kind of stuff in algorithmics and we show that actually searching, navigating whatever in the tree boils down to implement efficiently this rank and select operations.",
                    "label": 0
                },
                {
                    "sent": "OK, so in order to convince you that this is a very simple approach, I will not go through theorems, entropy bounds, efficiency bounds.",
                    "label": 0
                },
                {
                    "sent": "I referred you to the original paper.",
                    "label": 0
                },
                {
                    "sent": "Here I will try just to convince you that this is really effective and I will show you some experimental results.",
                    "label": 0
                },
                {
                    "sent": "So for the theory looks to folks.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the idea is as follows.",
                    "label": 0
                },
                {
                    "sent": "So let us consider elaborate tree.",
                    "label": 0
                },
                {
                    "sent": "Every node is a label and they can be strings in XML.",
                    "label": 0
                },
                {
                    "sent": "So what I suggest use the following priority, do a pre-order visit of the tree and at anytime you find the node in the visit you write down the level of the node and the upward path.",
                    "label": 0
                },
                {
                    "sent": "In this case is empty because it's the root.",
                    "label": 0
                },
                {
                    "sent": "So then I have a B and the upward path is C. Just see and so on and so forth.",
                    "label": 0
                },
                {
                    "sent": "You find D so that.",
                    "label": 0
                },
                {
                    "sent": "No parties BC so actually you write down the order visit.",
                    "label": 0
                },
                {
                    "sent": "Here are the labels of the nodes in the order you find during the pre order visit and these are the upward paths.",
                    "label": 0
                },
                {
                    "sent": "I'm showing this only for simplicity of exposition.",
                    "label": 0
                },
                {
                    "sent": "They will not be stored because they can clearly be quadratic in space.",
                    "label": 0
                },
                {
                    "sent": "OK, now this is the first step.",
                    "label": 0
                },
                {
                    "sent": "After that I have written down this what I tell you is the following.",
                    "label": 0
                },
                {
                    "sent": "Let us sort the rows of these metrics according to this component.",
                    "label": 0
                },
                {
                    "sent": "So according to the upward paths.",
                    "label": 0
                },
                {
                    "sent": "I did the.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Sort, so if you sort the previous one, you get this, so you notice that you are sorting according to this path OK, and the corresponding labels have followed the second component.",
                    "label": 0
                },
                {
                    "sent": "After that you did this sort.",
                    "label": 0
                },
                {
                    "sent": "What I tell you is that you need to add some other information in order to have the structure of the tree and what you need is.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Just a binary array for every node.",
                    "label": 0
                },
                {
                    "sent": "For example, this is BC.",
                    "label": 0
                },
                {
                    "sent": "Is that one?",
                    "label": 0
                },
                {
                    "sent": "I just had one because this is the last children of its parent, so I put a one for the last child.",
                    "label": 0
                },
                {
                    "sent": "They put a 0 for all the other children.",
                    "label": 0
                },
                {
                    "sent": "Now our transform is this one, so I'm saying that you need just to keep the permutation of the node labels built in.",
                    "label": 0
                },
                {
                    "sent": "This way you need to keep the binary representation and what we were able to show in folks was the following that actually you can construct this in linear time, so optimal time this is an optimal representation of the treeby 'cause you need to store just the labels and you pay 1 bit per node and up to lower order terms, so you cannot do better.",
                    "label": 0
                },
                {
                    "sent": "OK, by combinatorial arguments, and since you can compute this in optimal linear time, this is an equivalent representation of the tree, but you are not using pointers, OK?",
                    "label": 0
                },
                {
                    "sent": "Now what you can do with this one, it seems that you are messing up things.",
                    "label": 0
                },
                {
                    "sent": "You are just moving things and you are losing everything nice about the tree structure.",
                    "label": 0
                },
                {
                    "sent": "Now, OK, let's start from this point and.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Then I will be back to them.",
                    "label": 0
                },
                {
                    "sent": "To the indexing part to the navigation and consider a very tiny example.",
                    "label": 0
                },
                {
                    "sent": "So I have a XML document.",
                    "label": 0
                },
                {
                    "sent": "I construct the tree and I construct the tree in a special way in the sense that do any tag I prefix a minus symbol.",
                    "label": 0
                },
                {
                    "sent": "This is important for practical stuff to any attribute value and attribute name.",
                    "label": 0
                },
                {
                    "sent": "I prefix the hat symbol and for what concerns the leaves I just divide every leaf into two nodes.",
                    "label": 0
                },
                {
                    "sent": "One is the equal node and the other is the content of the leaf, which is prefixed by a new character.",
                    "label": 0
                },
                {
                    "sent": "This is just for practical stuff.",
                    "label": 0
                },
                {
                    "sent": "Now if you have this tree and you apply the transform that I described before, what you get is the following.",
                    "label": 0
                },
                {
                    "sent": "This is the bit string.",
                    "label": 0
                },
                {
                    "sent": "This is the levels of the tree according to the order that I've got.",
                    "label": 0
                },
                {
                    "sent": "I've got for that word parts, so this would be the transform.",
                    "label": 0
                },
                {
                    "sent": "OK, while this transform is interesting and we can look on this example immediately for the following reason.",
                    "label": 0
                },
                {
                    "sent": "Because we have a spatial clustering of the information.",
                    "label": 0
                },
                {
                    "sent": "Now if you look to this part of a sulfa you will find here only tag names, attribute names and the equal symbol.",
                    "label": 0
                },
                {
                    "sent": "If you look to the last part.",
                    "label": 0
                },
                {
                    "sent": "Of alfalfa, which is this one according to what we have stored, you get only content data and the nice stuff.",
                    "label": 0
                },
                {
                    "sent": "At least then I will show you more properties.",
                    "label": 0
                },
                {
                    "sent": "Is that the first equal corresponds to the first content data.",
                    "label": 0
                },
                {
                    "sent": "The second equal correspond to the second content data and so on and so forth.",
                    "label": 0
                },
                {
                    "sent": "Also, if you look to the sorting, you find that all the entries with the sand from the book Item Book Tag are contiguous because they are stored to get in this part of a sulfa if you take all the entries with Ascend from biblio they are contiguous and there are this one.",
                    "label": 0
                },
                {
                    "sent": "So according to this kind of sorting you are clustering data.",
                    "label": 0
                },
                {
                    "sent": "You are having a lot what is usually called in data compression.",
                    "label": 0
                },
                {
                    "sent": "You are getting strings which are local homogeneous and since they are local emergency they are very good.",
                    "label": 0
                },
                {
                    "sent": "Lee compressed that you can.",
                    "label": 0
                },
                {
                    "sent": "Compressed very high OK.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now these are is the first set of experiments that we did take the XML tree transform, get the two arrays and compress using any string compressor that you have in the literature.",
                    "label": 0
                },
                {
                    "sent": "So you have not to carry it to take care about complicated stuff that you can find.",
                    "label": 0
                },
                {
                    "sent": "This kind of compress or SMP PM or X meal, whatever.",
                    "label": 0
                },
                {
                    "sent": "What you are telling you is just to transform and compress.",
                    "label": 0
                },
                {
                    "sent": "So this is a very trivial thing, but if you experiment you will find that sometimes we are better than what was known as the best compressors in the literature.",
                    "label": 0
                },
                {
                    "sent": "Sometimes we are a little bit worse.",
                    "label": 0
                },
                {
                    "sent": "OK, OK, this is permits could be promising, because just doing the transform and the compression we could get some the best known bounds in the literature and the approach is very simple.",
                    "label": 0
                },
                {
                    "sent": "But from my point of view I was not really satisfied because if you compare the red bar which is our results.",
                    "label": 0
                },
                {
                    "sent": "With, for example, the yellow bar which is PPM is a standard string compressor.",
                    "label": 0
                },
                {
                    "sent": "You almost get the same compression.",
                    "label": 0
                },
                {
                    "sent": "The difference is just 5%, but we are exploiting the tree data.",
                    "label": 0
                },
                {
                    "sent": "The tree information PPM does not know anything about the file, but in any case it achieves a very good compression, so this is promising for compression POV, but it's not really very astonishing.",
                    "label": 0
                },
                {
                    "sent": "OK, so this could be a sad moral of this talk.",
                    "label": 0
                },
                {
                    "sent": "But this was not my point.",
                    "label": 0
                },
                {
                    "sent": "I didn't want to show you a very good compressor for XML data.",
                    "label": 0
                },
                {
                    "sent": "I want to show you a way of compressing data and searching into this data and hear the stories completely different cause we need to add more information in order to access this data and do not compress it.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "I need to show more properties.",
                    "label": 0
                },
                {
                    "sent": "OK about this transform and this makes the transform.",
                    "label": 0
                },
                {
                    "sent": "I think very interesting.",
                    "label": 0
                },
                {
                    "sent": "Assume that I pick up a node B and the upward path is just see this is the node and this is its upward path.",
                    "label": 0
                },
                {
                    "sent": "If we will look to the children DC, these children are contiguous in the metrics Huawei.",
                    "label": 1
                },
                {
                    "sent": "Just because we are doing a pre order visit and we are moving in a stable sort.",
                    "label": 0
                },
                {
                    "sent": "So children of a node are contiguous.",
                    "label": 0
                },
                {
                    "sent": "Now let us speak another node.",
                    "label": 0
                },
                {
                    "sent": "This is B, which is exactly the same as this be because it is as label B and upward path is just C and this is this note.",
                    "label": 0
                },
                {
                    "sent": "So if you take the children are again contiguous because there's survey shun before.",
                    "label": 1
                },
                {
                    "sent": "But the nice part is that the blue children comes after the green children, so they preserve the order of the original parents, so children preserve the order of the original parent.",
                    "label": 1
                },
                {
                    "sent": "If they are the same, they come from the same part.",
                    "label": 1
                },
                {
                    "sent": "This is a very strong structural properties that allow us to navigate over these three in a very simple way.",
                    "label": 0
                },
                {
                    "sent": "So assume that they want to go from here to here.",
                    "label": 0
                },
                {
                    "sent": "The algorithm that I want to that I need to do implement is very simple, so take this B and computer rank.",
                    "label": 0
                },
                {
                    "sent": "That is, compute how many bees you have above.",
                    "label": 0
                },
                {
                    "sent": "In this case you have two bees, so you have two.",
                    "label": 1
                },
                {
                    "sent": "So the second step of the algorithm is to start.",
                    "label": 0
                },
                {
                    "sent": "From the set of rows, prefix it by B and just to do a selection of the second one, which is here.",
                    "label": 0
                },
                {
                    "sent": "So you start from this rule and you select the 2nd one.",
                    "label": 0
                },
                {
                    "sent": "Second, because this is 2.",
                    "label": 0
                },
                {
                    "sent": "So actually, in order to navigate with what I'm telling you is just to do a rank and select.",
                    "label": 0
                },
                {
                    "sent": "Yeah.",
                    "label": 0
                },
                {
                    "sent": "Sure, So what you have to keep out is not this one, because this would be too costly.",
                    "label": 0
                },
                {
                    "sent": "You just need to keep for every distinct letters for any distinct labels.",
                    "label": 0
                },
                {
                    "sent": "The first role which is prefixed by this letter.",
                    "label": 0
                },
                {
                    "sent": "So you just need to keep for a 14B44C whatever.",
                    "label": 0
                },
                {
                    "sent": "OK, so you need an array whose size is proportional to the number of distinct levels, which is usually very small OK. Good question.",
                    "label": 0
                },
                {
                    "sent": "So when you have this you have just implemented rank and select so you look at the literature you use any data structure you want on this array in this array and what you are doing is just we are able to navigate of these three without using pointers.",
                    "label": 1
                },
                {
                    "sent": "OK, now in the literature and I will come back in the next part of the talk.",
                    "label": 0
                },
                {
                    "sent": "There are solutions that are able to compress a race and do rank and select.",
                    "label": 0
                },
                {
                    "sent": "So you could compress these two things and do ranks and select.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now the nice thing is that we were able to show that you can not only navigate, but you can actually search for subparts.",
                    "label": 0
                },
                {
                    "sent": "So assume that they give you BD and they want to search for all the occurrences of VD in these arrays, repeating the ideas that have shown before what you are able to do is that is that you can find a block of rows which are prefixed by DB very efficiently, and given this block of rows, what you can do is just buy ranks.",
                    "label": 0
                },
                {
                    "sent": "You can count the number of ones and by the number of once you have.",
                    "label": 0
                },
                {
                    "sent": "The number of occurrences of that subpart.",
                    "label": 0
                },
                {
                    "sent": "These are really a little bit technical, so you have to refer to the paper OK, but essentially by the same ideas you can do the same, yeah.",
                    "label": 0
                },
                {
                    "sent": "Dee Dee I could show you in the sense that he is the same idea that I did by navigation, but in this case you have not just to do navigation, you have to do navigation constrained by the letters so you do OK. Now again, what I'm telling you is that given two arrays, these two arrays by storing rank and select primitives, you can do search for subparts.",
                    "label": 0
                },
                {
                    "sent": "OK, so you can prove entropy bounds.",
                    "label": 0
                },
                {
                    "sent": "You can prove whatever, but the point was that can we implement this and see what happens.",
                    "label": 0
                },
                {
                    "sent": "So this.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is really interesting, so here the blue bar is just what usually XML search engines do, not.",
                    "label": 0
                },
                {
                    "sent": "If so, they take the text they compress, they assign integers tokens to tags and they compressed by Hoffman.",
                    "label": 0
                },
                {
                    "sent": "Today the content part this is the blue OK, here we are the green part.",
                    "label": 0
                },
                {
                    "sent": "The Red Band is the sparring partner.",
                    "label": 0
                },
                {
                    "sent": "So what you can do the best using the best compressor to date.",
                    "label": 0
                },
                {
                    "sent": "But obviously if you have a compressor you cannot search OK.",
                    "label": 0
                },
                {
                    "sent": "So using this amount of space, which is a little bit more than a compressor, you can keep compressor data.",
                    "label": 0
                },
                {
                    "sent": "You can search for sub path, you can search for subaquatic content and this improvement is significant because it can be 36% absolute over the original and the known approaches and the nice part is that you can do counting and navigation in milliseconds because you do not need to decompress the whole data.",
                    "label": 0
                },
                {
                    "sent": "So you just going into some parts of the file and the compressed some part of the file.",
                    "label": 0
                },
                {
                    "sent": "You can find that information you wish.",
                    "label": 0
                },
                {
                    "sent": "Here I'm not talking about X query, I'm not talking about we queries, complicated stuff, I'm talking about simple support searches OK?",
                    "label": 0
                },
                {
                    "sent": "And if you turn these numbers into how many space you paper node, this is really interesting because on the BLP we pay one byte .75 bytes per node and news we pay almost about four bytes per node because it's more the content data.",
                    "label": 0
                },
                {
                    "sent": "But this is I think very interesting so you pay less than one integer per node, OK?",
                    "label": 0
                },
                {
                    "sent": "Anne.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "What is the picture just to give you the idea?",
                    "label": 0
                },
                {
                    "sent": "So now in the literature we have two streams of papers.",
                    "label": 0
                },
                {
                    "sent": "One regards text and the other regards laboratories on the text.",
                    "label": 0
                },
                {
                    "sent": "If you open any textbook you find suffix trees and suffix arrays.",
                    "label": 0
                },
                {
                    "sent": "Data structure to support substring searches and if you open the textbook for label trees you find the suffix tree over three, which is actually a suffix tree over all the paths is very well known that this data structure.",
                    "label": 0
                },
                {
                    "sent": "Powerful, but they occupy a huge amount of space so really huge amount of space now.",
                    "label": 0
                },
                {
                    "sent": "Actually the\nOf research that I have very briefly presented here tells you to do a different stuff.",
                    "label": 0
                },
                {
                    "sent": "So tells you to transform the data in some way.",
                    "label": 0
                },
                {
                    "sent": "Here I've shown the so called ex BW on the string is very well known.",
                    "label": 0
                },
                {
                    "sent": "Borrow singular, transform the base of bzip compressor and after that you make this transform.",
                    "label": 0
                },
                {
                    "sent": "You just need to implement rank and select primitives.",
                    "label": 0
                },
                {
                    "sent": "These transforms so you can do substring searches, so this representation is equivalent to suffix trees and suffix arrays, but the space is compressed and many papers have shown that from a computational point of view you get the same speed as in tatic speed, so this is really very powerful and this explains you why in the last year if you open proceedings, any proceeding you will find papers telling you about rank and select over unbounded alphabets rank and selecting two entropy bounds.",
                    "label": 0
                },
                {
                    "sent": "The reason is actually these two lines of papers.",
                    "label": 0
                },
                {
                    "sent": "Because if you are able to show that you can implement rank and select efficiently in time and space, you can plug these tools into these ideas and you can get very powerful stuff either for strings or for trees.",
                    "label": 0
                },
                {
                    "sent": "So this is actually a way of reducing the complexity of the problem from strings and trees to just binary race and do very basic operations, yes.",
                    "label": 0
                },
                {
                    "sent": "This was my last phrase in the sense that what we're doing now is just to continue this line of search and go to more complicated data structure.",
                    "label": 0
                },
                {
                    "sent": "What we have now is that we are able to do this on Dax Labra docs, which are actually automata, and so they can be used for example for feature recognition and storing speech.",
                    "label": 0
                },
                {
                    "sent": "Different stuff in compressed space and do search searches on these automata.",
                    "label": 0
                },
                {
                    "sent": "Yeah, but in general graph I don't know.",
                    "label": 0
                },
                {
                    "sent": "And this is all.",
                    "label": 0
                },
                {
                    "sent": "And more questions.",
                    "label": 0
                },
                {
                    "sent": "So it wasn't what you build the suffix array.",
                    "label": 0
                },
                {
                    "sent": "Sorry, So what you build isn't that the suffix array?",
                    "label": 0
                },
                {
                    "sent": "Now, if you would have built the suffix array, your space would be four times the text, so you would have got got 400%.",
                    "label": 0
                },
                {
                    "sent": "Labels or but just for building.",
                    "label": 0
                },
                {
                    "sent": "After that you built the data you'd have not to store this, you just called this.",
                    "label": 0
                },
                {
                    "sent": "In this compress it in some way.",
                    "label": 0
                },
                {
                    "sent": "So this is just for the building process.",
                    "label": 0
                },
                {
                    "sent": "Then you throw away.",
                    "label": 0
                },
                {
                    "sent": "Actually during the building process you do not need to explicitly have this, otherwise you would have quadratic space in the building stuff and would be too much in the paper.",
                    "label": 0
                },
                {
                    "sent": "In the Fox paper we showed to do this in linear space in linear time.",
                    "label": 0
                },
                {
                    "sent": "For King of Main memory I can do my poopy corpus in on four giga the construction you would need the.",
                    "label": 0
                },
                {
                    "sent": "You can do this in at most one giga so 1/4 OK because the now the best algorithms known for building suffix arrays, because actually this is a little bit like this require four times the text, so yeah.",
                    "label": 0
                },
                {
                    "sent": "Sure.",
                    "label": 0
                },
                {
                    "sent": "You come into being more and be on the challenge on actually navigating and get into the data and if you can locate the data very fast.",
                    "label": 0
                },
                {
                    "sent": "But I have to be more done in terms of assessing the cost of decompressing more of the tree.",
                    "label": 0
                },
                {
                    "sent": "So actually what you can show is that if you search for example for a part of three levels.",
                    "label": 0
                },
                {
                    "sent": "According to this, you just need to do 3 assessors to these arrays to get there.",
                    "label": 0
                },
                {
                    "sent": "You have work to do when you want to do anything with that data, sure, so you have some position an from this position.",
                    "label": 0
                },
                {
                    "sent": "You say what you can do by going down three.",
                    "label": 0
                },
                {
                    "sent": "At that point you will pay a cost which is linear in the size of the subtree.",
                    "label": 0
                },
                {
                    "sent": "Yes, so impossibly linear random access, because I'm sure that issue is a random access file.",
                    "label": 0
                },
                {
                    "sent": "Yeah, sure yes.",
                    "label": 0
                },
                {
                    "sent": "Well in the file you will get an internal.",
                    "label": 0
                },
                {
                    "sent": "This is a big issue of this complexity in this so.",
                    "label": 0
                },
                {
                    "sent": "The bigger challenge of this compressor these instances to move them to be cache oblivious or cache sensitive.",
                    "label": 0
                },
                {
                    "sent": "Till now we don't know how to do this.",
                    "label": 0
                },
                {
                    "sent": "And there was a question.",
                    "label": 0
                },
                {
                    "sent": "I wanted to know about when you.",
                    "label": 0
                },
                {
                    "sent": "When you feel that that can visit the next 4 after that, when you change the tree in somewhere and want to at this point we didn't consider incremental updates or changes at this point, just static stuff.",
                    "label": 0
                },
                {
                    "sent": "So you get the data you build this stuff and that's it.",
                    "label": 0
                },
                {
                    "sent": "If something changes at this point, you have to rebuild from scratch.",
                    "label": 0
                },
                {
                    "sent": "OK?",
                    "label": 0
                },
                {
                    "sent": "That is exactly what happens with the bar singular transform.",
                    "label": 0
                },
                {
                    "sent": "If you change the file, you have to compress from scratch.",
                    "label": 0
                },
                {
                    "sent": "OK, just one block in the bar, single transform, But anyway, sorry so late when you build it and you have many the same suffixes.",
                    "label": 0
                },
                {
                    "sent": "Does that make it harder to build the tree?",
                    "label": 0
                },
                {
                    "sent": "So imagine you have many.",
                    "label": 0
                },
                {
                    "sent": "Peter documents, do you want an answer from a theoretical point of view or from a practical?",
                    "label": 0
                },
                {
                    "sent": "Because in theory, no matter the optimal algorithms in practice depends on the album.",
                    "label": 0
                },
                {
                    "sent": "There are now there is a family of algorithms that are able to tackle also very long shared substrings.",
                    "label": 0
                },
                {
                    "sent": "They're called lightweight because they're able to occupy small space and be very robust about the repetition of the substrings.",
                    "label": 0
                },
                {
                    "sent": "But in the worst case that the strange stuff is that the fastest algorithms today are not the best algorithms.",
                    "label": 0
                },
                {
                    "sent": "In theory they could be quadratic interior, but they are the fastest because they are able to show it to exploit in the cache much better than the theoretical algorithms.",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                }
            ]
        }
    }
}