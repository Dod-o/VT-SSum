{
    "id": "wiqfm5276viqjd6jnreeec4wlu3qqfvq",
    "title": "Representative Subgraph Sampling using Markov Chain Monte Carlo Methods",
    "info": {
        "author": [
            "Karsten Michael Borgwardt, Max Planck Institute for Biological Cybernetics, Max Planck Institute"
        ],
        "published": "Aug. 25, 2008",
        "recorded": "July 2008",
        "category": [
            "Top->Computer Science->Machine Learning->Markov Processes"
        ]
    },
    "url": "http://videolectures.net/mlg08_borgwardt_rss/",
    "segmentation": [
        [
            "So this talk is going to be about.",
            "A problem that was recently defined in the data mining community and about our first machine learning approach towards this problem that I think it's a good fit for MLG's really said this joint with Christian Christian hoopla and hospital Regal from Munich.",
            "And we've swimming Armani from Cambridge."
        ],
        [
            "Anne.",
            "The real world problem we're dealing with, and that's what Professor Jung mentioned in her keynote this morning.",
            "Is that while?",
            "Classic application domains of graph mining, such as chemoinformatics, dealt with graphs that included dozens of nodes nowadays.",
            "Systems biology and the Internet are creating graph data with thousands, hundreds of thousands or even millions of nodes.",
            "So we are facing the challenge of dealing with graphs of increasing size.",
            "In real world applications."
        ],
        [
            "What's the consequence of this increase in graph size?",
            "It's an algorithmic challenge.",
            "Because as we all know, even basic operations on graphs are very expensive.",
            "Such as graph isomorphism checking or subgraph isomorphism checking.",
            "These classic algorithms that were used on molecules in chemoinformatics.",
            "Include.",
            "Several iterations of these steps usually have graph isomorphism checking in a subgroup isomorphism checking.",
            "And it doesn't matter that much because the graphs are so small and the exponential runtime effort for doing these operations doesn't really kick in on these small graphs.",
            "But as we go to large graphs with thousands of nodes, these.",
            "Exponential runtime efforts for.",
            "These basic operations really start to kick in and to make our runtime degenerate.",
            "So the classic algorithms that we use for graph mining of molecules are not applicable 121 to the new large and very large graphs that we are dealing with in bound for metrics and in the."
        ],
        [
            "Net.",
            "There are two ways.",
            "To tackle this problem.",
            "That our algorithms are not fast enough for these large graphs anymore.",
            "One way is to make the algorithm that you use on these graphs more efficient and three typical ways of doing so is to restrict yourself to a special subclass of graphs.",
            "For example, 2 trees or.",
            "Cycles or other decks.",
            "Other subclasses of graphs, for which you then can find an efficient algorithm that is even applicable to graphs with thousands of nodes.",
            "Another common approach is to neglect the structure of the graph and to treat the graph just as a set which makes computations also much easier.",
            "And the most common approach is to map a graph to a feature vector and then to use all the efficient algorithms that are available on feature vectors depths.",
            "One approach towards coping with this large graphs problem.",
            "The other one is.",
            "To make your graph smaller and hardly anyone has looked at this.",
            "Problem before I'll discuss related work later on.",
            "The problem here in making your graph smaller is that you want to find a small graph S that preserves the key characteristics of your large graph G well.",
            "Now two different strategies of doing so.",
            "One is synthetically generating this graph S. The other is to sample S from the large graph that you are given.",
            "So which sub graph of the large graph that you are given kept just the properties of the large graph?",
            "Well and that's the problem we're going to tackle.",
            "In this talk sample, a representative sub graph that captures the information, the information and the properties of the large graph G."
        ],
        [
            "There's only really one related paper on this topic.",
            "By less convention filters at KD 2006, in which they defined 3 broad classes of sampling is up graph from a large given graph.",
            "The first family just consists of randomly selecting nodes from the graph randomly pick N prime nodes.",
            "Anprim shall be the number of nodes in this graph sample from the given graph G, and they define different variants of that.",
            "The most simple and most basic one is uniform random sampling.",
            "Other variants of this you find some probability distribution over the nodes to prefer certain nodes.",
            "For example, nodes with High Pagerank wait or to prefer nodes with a high degree.",
            "The second family.",
            "Uses the same principle, but randomly sampled edges from the graph so it's the family of random edge selection the basic.",
            "Very and again is to randomly sample edges all over the graph, But you can also do a bit more sophisticated things just such as sampling nodes and edges.",
            "Combined fashions are picking one node and one adjacent edge.",
            "And you can also combine this uniform random sampling and this combined selection of nodes and edges."
        ],
        [
            "The third family.",
            "Of sampling algorithms that less coverage and follow us looked at was the family of sampling by exploration.",
            "Here you pick one node from your graph and then you explore the neighborhood of that node.",
            "In the graph they called it forest fire because.",
            "You can imagine this picking up one node as starting a fire.",
            "In the graph, you pick one node and then you pick a random number X and then you visit ex neighbors of that node that you've randomly picked from the graph, and you recursively repeat this for all the neighbors of the graph that you've now visited.",
            "So just like a forest fire, your sampling algorithm spreads over the large graph.",
            "And this work best among the algorithms that they proposed in their KDD paper.",
            "And to summarize, the state of the art using these three families of sampling algorithms, less question, those managed to reduce.",
            "The graph size of the large graph G by a factor of 6, so roughly down to 15% of the original graph size.",
            "The."
        ],
        [
            "We wondered whether we could define a machine learning.",
            "Inspired approach to this problem and.",
            "To cast this task into an optimization problem.",
            "And we came up with the following formulation.",
            "This task of finding a representative subgraph is equivalent to finding.",
            "This sub graph which minimizes this objective function.",
            "It is this up graph.",
            "Which contains N prime nodes.",
            "And that minimizes the distance to the original graph G. S expressed by a distance function on properties Sigma of the subgraph sample S and the graph G. The minimizer of this.",
            "Objective function is our desired representative sub graph of the graph."
        ],
        [
            "So after casting this problem into an optimization problem.",
            "We then wondered how to tackle this obviously hard optimization problem and we came up with the Metropolis algorithm for finding a solution to our approximating, or at least finding a good solution to this problem.",
            "The idea is to.",
            "Represent sub graph.",
            "Quality to model subgraph quality as a probability distribution over the subgraphs of a given graph G and then to use a metropolis algorithm to search this space of subgraphs.",
            "And to find.",
            "Ones up graph that approximates the characteristics of the original graph G well.",
            "This metropolis algorithm consists as metropolis usually does the following steps.",
            "We start by picking 1 sample from the graph.",
            "So we start by picking one subgraph sample S with N prime nodes.",
            "And then in each iteration we remove one note from S and add a new node to S. And then.",
            "B compute the likelihood ratio.",
            "Between.",
            "The new sub graph sample and the current sub graph sample and if.",
            "This ratio is larger than one.",
            "Then we accept the transition from the current stage to the new state, and if it is smaller than one then we accept it with probability A.",
            "And we rejected.",
            "Obviously, if this probability 1 -- A.",
            "The decisive question now is, how shall we define this row of S?",
            "This function, which is.",
            "Proportional to the probability distribution on which we are doing Metropolis sampling to get a good sub graph sample.",
            "How can we get this connection between row of S and the graph sample code?"
        ],
        [
            "Dirty.",
            "As I mentioned.",
            "Row is a probability distribution that metropolis samples from.",
            "And Rho star is proportional is a function which is proportional to this role.",
            "And roll star shall reflect sub graph quality and to achieve that.",
            "We decided to define Rd star of S as the inverse of a distance.",
            "Between the subgraph sample S and the original graph G. End to reward.",
            "Good subgraph samples even more.",
            "We exponentiated that by a large positive scalar P. So that is.",
            "The function that we actually use in Metropolis to find.",
            "Good subgraphs."
        ],
        [
            "Input.",
            "When we ran initial experiments, we observed that good samples samples which approximated the characteristics of the large graph G well.",
            "They are often connected, so we came up with a slightly modified version which we called chaining, which restricts the search space to connected subgraphs of the original graph G. So we only allow transitions from 1.",
            "Stage two, the other.",
            "If both states represent connected subgraphs.",
            "And what is the effect of this modification on the runtime?",
            "Obviously designs for search search space is reduced because research space only consists of connected subgraphs.",
            "But we need an additional check to verify that each of the states S&S prime is connected."
        ],
        [
            "And the third.",
            "Variant of our approach is to use classic simulated annealing.",
            "It is.",
            "A variant of Metropolis for global optimization, back from the 1980s.",
            "The idea here is that you slightly modify your function row star in each iteration by having a temperature parameter in exponent.",
            "And this temperature parameter slowly decreases to zero, which has the effect that initially.",
            "In your metropolis algorithm, you accept a lot of transitions, but the smaller T gets the more difficult it gets to move from one state to the other.",
            "So more and more transitions are rejected.",
            "St goes to 0.",
            "And in all of this, just to mention it, we assume as a metric proposal distribution."
        ],
        [
            "And then after defining these three approaches to representative subgraph sampling, we ran these three methods on five datasets, four of them from the flutes, and let's go veg paper.",
            "These graphs included 329, two 75,000 nodes.",
            "And our goal was to find a representative sub graph with N prime equals 100 nodes on these large graphs.",
            "We ran our three different variants, Metropolis based representative graph sampling, simulated annealing and chaining.",
            "And.",
            "The graph properties Sigma that we used for sampling were the degree distribution of the graphs, the clustering coefficient.",
            "Which means which ratio for which ratio of nodes does the following property hold if A is connected to B&A is connected to CRB&C connected as well this this type of information is captured by the clustering coefficient.",
            "We also use the graph so called graph distribution as a graph property that we try to approximate a graph that is a small sub graph of a given graph of limited size K. And then 4th we use a weighted combination of all these three properties.",
            "And he compared it to the three families of algorithms defined by deskovic influencers too random at random node and forest fire."
        ],
        [
            "We didn't use exactly the same.",
            "Criteria that we used for sampling for evaluating our samples.",
            "So we also use the degree distribution clustering coefficient in the grafted distribution, but also the diameter and we combined each of the criteria that we used for sampling with each of the quality of these properties for evaluation.",
            "So we didn't always use the same criterion for sampling and for evaluation.",
            "Results here are averages over all the different properties that we used for evaluation of the quality of our sub graph samples.",
            "And what we can see here in this plot is that.",
            "Our methods shown in blue.",
            "Reach.",
            "A better sub graph.",
            "Sample quality, then the classic approaches from this KDD.",
            "Paper.",
            "Eight out of our eleven methods are better than the best method defined by less which influences."
        ],
        [
            "Am the ones that fail are ones in which we just try to approximate the clustering coefficient and the graphlet distribution of the original graph.",
            "So approximating the degree distribution of the original graph works much better in our experiment.",
            "This comes at the price of an increased runtime.",
            "So while the classic approaches take less than one second on average, our slowest algorithm takes roughly 5 to 6 minutes.",
            "But still.",
            "I personally think that 5 to 6 minutes is an acceptable pre processing time.",
            "If you don't can do analysis on your small subgraphs sample more efficiently, our fastest algorithm which is Metropolis sampling approximating the degree distribution just takes 3 seconds on average, so.",
            "This is the most efficient of our our algorithms."
        ],
        [
            "Of course, when we use this.",
            "Special.",
            "Varo robe star.",
            "For measuring the quality office up graph, which is one over the distance between disapprove sample and the graph to the power of P. Then this P has an effect on the quality of the subgraph samples that we obtain, and we check that by repeating our experiments for different values of P and what we observed is that for small values of P we don't get very good.",
            "Sub graph samples.",
            "But as we reach.",
            "Values of 150 and larger.",
            "Our subgraph samples get get much better.",
            "So having a large P means that you put a lot of emphasis on really good graphs.",
            "Really good subgraph samples in your graph and that you strongly reward them.",
            "And this seems to be important in this."
        ],
        [
            "Application.",
            "Then we observed and examined the behavior of our algorithm.",
            "When we change the size of the subgraph samples.",
            "So far we only looked at a sub graph with N prime equals 100 nodes and now we varied from 1% of the original graph size to 100% of the original graph size, and we've shown here.",
            "The distance between the subgraph sample and the original graph G for our best method metropolis approximating the degree distribution and the induced forest fire algorithm from the literature, and as we can see here, we all always better, irrespective of subgraph, sample size and especially for low sample size.",
            "For small sample sizes we outperformed the classic algorithm."
        ],
        [
            "And a final plot.",
            "Here shows how distance, runtime and subgraph sample size correlate.",
            "What we can see here is that obviously as our sub graph sample gets larger, our algorithm requires more runtime, but the approximation quality of our algorithm increases the larger sample size gap."
        ],
        [
            "To summarize our findings, we have proposed three metropolis based approaches to representative subgraph sampling.",
            "We reach high-quality subgraph samples down to point.",
            "One 5% of the original draft sites, which is 100 times smaller than the current state of the art.",
            "And Interestingly, the Metropolis algorithm approximating the degree distribution combines efficiency and sample quality best.",
            "How can we apply this and what will we do in future work?",
            "And a direct application is to use the subgraph samples for visualization.",
            "To use them for approximate graph kernel computation or to perform frequent subgraph mining on them.",
            "Because the graphics are inherently related to subgraphs in a data set of graphs.",
            "An future work in future work we will look into representative subgraph mining tasks that only indirectly rely on these topological properties that we've approximated here.",
            "Such applications include graph clustering and community detection in large networks.",
            "That concludes my talk, thank you very."
        ],
        [
            "Much I'm happy to answer questions.",
            "Yes.",
            "Check for connectivity.",
            "I did my best, ensuring that you sent the money from North that are connected with current setup so you have a proposal subgraph and you know all the nodes will pick it up so you can restrict it down to the notes that I connected.",
            "Then you don't have to do this.",
            "Yes, we want to guarantee a symmetric proposal distribution, and when you remove one note from the sub graph sample, you have to make sure and at the new one then.",
            "It it could be that removing that one node disconnects your current subgraph sample.",
            "So then you know then would have to reconnect it again.",
            "And we haven't.",
            "Yeah, well, you look into that, but at the moment that's the way of guaranteeing that both the current state and and you state are connected.",
            "You're you're approaching.",
            "That's what I tried to mention during the talk.",
            "It was possible because we, as I said, we didn't use exactly the same criteria for evaluation that we had used for sampling before.",
            "So even when we had.",
            "Approximated the degree distribution of the original graph, then we better approximated.",
            "The graph, the distribution and clustering coefficient in forest fire.",
            "So we didn't use exactly the same properties for approximation an for evaluation, we combined all different properties with each other and.",
            "Even if YouTube are different, we did better than forest fire.",
            "But I agree that of course first fire somehow blind to the properties of the large graph.",
            "I think the.",
            "The most important aspect is that.",
            "You have to ensure that the properties of the large graph can be computed efficiently.",
            "That's somehow that for me is the biggest bottleneck of our approach.",
            "So how do you guarantee that you can actually compute Sigma of G?",
            "The properties of the original graph, but a very encouraging result is that computing the degree distribution.",
            "Often large graph which is.",
            "Pretty cheap to do.",
            "An already gives you very good results and better results than those published in the literature.",
            "Function.",
            "Think of somebody who makes statement received number of nodes in graph.",
            "Roger so the amazing.",
            "So what we observed here, but what I can tell from our experiments is that degree distribution works surprisingly well, and that the crossing coefficient in the graph the distribution.",
            "Do not give that good subgraph samples, so it might be some variant of the degree distribution or something that is inherently related.",
            "That could give you even better subgraph samples, but it obviously also depends on your particular application.",
            "So, for example, you might want to include node labels or something like that in your sampling process, which we don't do here.",
            "So we just take the graphs as being unlabeled and we want to preserve the topology of of the graphs, nothing, nothing else, so we're focused on topology here, and you could enrich.",
            "The criteria by adding.",
            "Other types of information.",
            "I have a question overall, how does the computational complexity of the sampling scale with the size of the graphs?",
            "Well, worst case you have to explore all the subgraphs of the.",
            "Of the given graph, to get the optimal globally optimal solution to this, but.",
            "Even though we didn't necessarily find the global optimal solutions or the solutions that we got in our process after a fixed number of steps were much better than those that have been reported in the literature.",
            "X number of steps is a function of the size of the graph.",
            "Yeah, you try to make them depend on the on the number of nodes in the number of edges in your graph.",
            "So you basically need a rule of thumb for setting the number of iterations.",
            "Any other questions?",
            "Well, we haven't analyzed the mixing time yet, but we will look into that.",
            "Next thank you very much."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So this talk is going to be about.",
                    "label": 0
                },
                {
                    "sent": "A problem that was recently defined in the data mining community and about our first machine learning approach towards this problem that I think it's a good fit for MLG's really said this joint with Christian Christian hoopla and hospital Regal from Munich.",
                    "label": 0
                },
                {
                    "sent": "And we've swimming Armani from Cambridge.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Anne.",
                    "label": 0
                },
                {
                    "sent": "The real world problem we're dealing with, and that's what Professor Jung mentioned in her keynote this morning.",
                    "label": 0
                },
                {
                    "sent": "Is that while?",
                    "label": 0
                },
                {
                    "sent": "Classic application domains of graph mining, such as chemoinformatics, dealt with graphs that included dozens of nodes nowadays.",
                    "label": 0
                },
                {
                    "sent": "Systems biology and the Internet are creating graph data with thousands, hundreds of thousands or even millions of nodes.",
                    "label": 1
                },
                {
                    "sent": "So we are facing the challenge of dealing with graphs of increasing size.",
                    "label": 0
                },
                {
                    "sent": "In real world applications.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "What's the consequence of this increase in graph size?",
                    "label": 0
                },
                {
                    "sent": "It's an algorithmic challenge.",
                    "label": 0
                },
                {
                    "sent": "Because as we all know, even basic operations on graphs are very expensive.",
                    "label": 1
                },
                {
                    "sent": "Such as graph isomorphism checking or subgraph isomorphism checking.",
                    "label": 1
                },
                {
                    "sent": "These classic algorithms that were used on molecules in chemoinformatics.",
                    "label": 0
                },
                {
                    "sent": "Include.",
                    "label": 0
                },
                {
                    "sent": "Several iterations of these steps usually have graph isomorphism checking in a subgroup isomorphism checking.",
                    "label": 0
                },
                {
                    "sent": "And it doesn't matter that much because the graphs are so small and the exponential runtime effort for doing these operations doesn't really kick in on these small graphs.",
                    "label": 0
                },
                {
                    "sent": "But as we go to large graphs with thousands of nodes, these.",
                    "label": 1
                },
                {
                    "sent": "Exponential runtime efforts for.",
                    "label": 0
                },
                {
                    "sent": "These basic operations really start to kick in and to make our runtime degenerate.",
                    "label": 0
                },
                {
                    "sent": "So the classic algorithms that we use for graph mining of molecules are not applicable 121 to the new large and very large graphs that we are dealing with in bound for metrics and in the.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Net.",
                    "label": 0
                },
                {
                    "sent": "There are two ways.",
                    "label": 0
                },
                {
                    "sent": "To tackle this problem.",
                    "label": 0
                },
                {
                    "sent": "That our algorithms are not fast enough for these large graphs anymore.",
                    "label": 0
                },
                {
                    "sent": "One way is to make the algorithm that you use on these graphs more efficient and three typical ways of doing so is to restrict yourself to a special subclass of graphs.",
                    "label": 0
                },
                {
                    "sent": "For example, 2 trees or.",
                    "label": 0
                },
                {
                    "sent": "Cycles or other decks.",
                    "label": 0
                },
                {
                    "sent": "Other subclasses of graphs, for which you then can find an efficient algorithm that is even applicable to graphs with thousands of nodes.",
                    "label": 0
                },
                {
                    "sent": "Another common approach is to neglect the structure of the graph and to treat the graph just as a set which makes computations also much easier.",
                    "label": 0
                },
                {
                    "sent": "And the most common approach is to map a graph to a feature vector and then to use all the efficient algorithms that are available on feature vectors depths.",
                    "label": 0
                },
                {
                    "sent": "One approach towards coping with this large graphs problem.",
                    "label": 0
                },
                {
                    "sent": "The other one is.",
                    "label": 0
                },
                {
                    "sent": "To make your graph smaller and hardly anyone has looked at this.",
                    "label": 0
                },
                {
                    "sent": "Problem before I'll discuss related work later on.",
                    "label": 0
                },
                {
                    "sent": "The problem here in making your graph smaller is that you want to find a small graph S that preserves the key characteristics of your large graph G well.",
                    "label": 1
                },
                {
                    "sent": "Now two different strategies of doing so.",
                    "label": 0
                },
                {
                    "sent": "One is synthetically generating this graph S. The other is to sample S from the large graph that you are given.",
                    "label": 0
                },
                {
                    "sent": "So which sub graph of the large graph that you are given kept just the properties of the large graph?",
                    "label": 0
                },
                {
                    "sent": "Well and that's the problem we're going to tackle.",
                    "label": 0
                },
                {
                    "sent": "In this talk sample, a representative sub graph that captures the information, the information and the properties of the large graph G.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "There's only really one related paper on this topic.",
                    "label": 0
                },
                {
                    "sent": "By less convention filters at KD 2006, in which they defined 3 broad classes of sampling is up graph from a large given graph.",
                    "label": 0
                },
                {
                    "sent": "The first family just consists of randomly selecting nodes from the graph randomly pick N prime nodes.",
                    "label": 1
                },
                {
                    "sent": "Anprim shall be the number of nodes in this graph sample from the given graph G, and they define different variants of that.",
                    "label": 1
                },
                {
                    "sent": "The most simple and most basic one is uniform random sampling.",
                    "label": 0
                },
                {
                    "sent": "Other variants of this you find some probability distribution over the nodes to prefer certain nodes.",
                    "label": 0
                },
                {
                    "sent": "For example, nodes with High Pagerank wait or to prefer nodes with a high degree.",
                    "label": 0
                },
                {
                    "sent": "The second family.",
                    "label": 1
                },
                {
                    "sent": "Uses the same principle, but randomly sampled edges from the graph so it's the family of random edge selection the basic.",
                    "label": 0
                },
                {
                    "sent": "Very and again is to randomly sample edges all over the graph, But you can also do a bit more sophisticated things just such as sampling nodes and edges.",
                    "label": 0
                },
                {
                    "sent": "Combined fashions are picking one node and one adjacent edge.",
                    "label": 1
                },
                {
                    "sent": "And you can also combine this uniform random sampling and this combined selection of nodes and edges.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The third family.",
                    "label": 0
                },
                {
                    "sent": "Of sampling algorithms that less coverage and follow us looked at was the family of sampling by exploration.",
                    "label": 0
                },
                {
                    "sent": "Here you pick one node from your graph and then you explore the neighborhood of that node.",
                    "label": 0
                },
                {
                    "sent": "In the graph they called it forest fire because.",
                    "label": 0
                },
                {
                    "sent": "You can imagine this picking up one node as starting a fire.",
                    "label": 0
                },
                {
                    "sent": "In the graph, you pick one node and then you pick a random number X and then you visit ex neighbors of that node that you've randomly picked from the graph, and you recursively repeat this for all the neighbors of the graph that you've now visited.",
                    "label": 1
                },
                {
                    "sent": "So just like a forest fire, your sampling algorithm spreads over the large graph.",
                    "label": 0
                },
                {
                    "sent": "And this work best among the algorithms that they proposed in their KDD paper.",
                    "label": 0
                },
                {
                    "sent": "And to summarize, the state of the art using these three families of sampling algorithms, less question, those managed to reduce.",
                    "label": 1
                },
                {
                    "sent": "The graph size of the large graph G by a factor of 6, so roughly down to 15% of the original graph size.",
                    "label": 0
                },
                {
                    "sent": "The.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We wondered whether we could define a machine learning.",
                    "label": 0
                },
                {
                    "sent": "Inspired approach to this problem and.",
                    "label": 0
                },
                {
                    "sent": "To cast this task into an optimization problem.",
                    "label": 0
                },
                {
                    "sent": "And we came up with the following formulation.",
                    "label": 0
                },
                {
                    "sent": "This task of finding a representative subgraph is equivalent to finding.",
                    "label": 0
                },
                {
                    "sent": "This sub graph which minimizes this objective function.",
                    "label": 0
                },
                {
                    "sent": "It is this up graph.",
                    "label": 0
                },
                {
                    "sent": "Which contains N prime nodes.",
                    "label": 0
                },
                {
                    "sent": "And that minimizes the distance to the original graph G. S expressed by a distance function on properties Sigma of the subgraph sample S and the graph G. The minimizer of this.",
                    "label": 1
                },
                {
                    "sent": "Objective function is our desired representative sub graph of the graph.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So after casting this problem into an optimization problem.",
                    "label": 0
                },
                {
                    "sent": "We then wondered how to tackle this obviously hard optimization problem and we came up with the Metropolis algorithm for finding a solution to our approximating, or at least finding a good solution to this problem.",
                    "label": 0
                },
                {
                    "sent": "The idea is to.",
                    "label": 0
                },
                {
                    "sent": "Represent sub graph.",
                    "label": 0
                },
                {
                    "sent": "Quality to model subgraph quality as a probability distribution over the subgraphs of a given graph G and then to use a metropolis algorithm to search this space of subgraphs.",
                    "label": 0
                },
                {
                    "sent": "And to find.",
                    "label": 0
                },
                {
                    "sent": "Ones up graph that approximates the characteristics of the original graph G well.",
                    "label": 0
                },
                {
                    "sent": "This metropolis algorithm consists as metropolis usually does the following steps.",
                    "label": 0
                },
                {
                    "sent": "We start by picking 1 sample from the graph.",
                    "label": 0
                },
                {
                    "sent": "So we start by picking one subgraph sample S with N prime nodes.",
                    "label": 1
                },
                {
                    "sent": "And then in each iteration we remove one note from S and add a new node to S. And then.",
                    "label": 1
                },
                {
                    "sent": "B compute the likelihood ratio.",
                    "label": 0
                },
                {
                    "sent": "Between.",
                    "label": 0
                },
                {
                    "sent": "The new sub graph sample and the current sub graph sample and if.",
                    "label": 0
                },
                {
                    "sent": "This ratio is larger than one.",
                    "label": 0
                },
                {
                    "sent": "Then we accept the transition from the current stage to the new state, and if it is smaller than one then we accept it with probability A.",
                    "label": 0
                },
                {
                    "sent": "And we rejected.",
                    "label": 0
                },
                {
                    "sent": "Obviously, if this probability 1 -- A.",
                    "label": 0
                },
                {
                    "sent": "The decisive question now is, how shall we define this row of S?",
                    "label": 0
                },
                {
                    "sent": "This function, which is.",
                    "label": 0
                },
                {
                    "sent": "Proportional to the probability distribution on which we are doing Metropolis sampling to get a good sub graph sample.",
                    "label": 0
                },
                {
                    "sent": "How can we get this connection between row of S and the graph sample code?",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Dirty.",
                    "label": 0
                },
                {
                    "sent": "As I mentioned.",
                    "label": 0
                },
                {
                    "sent": "Row is a probability distribution that metropolis samples from.",
                    "label": 1
                },
                {
                    "sent": "And Rho star is proportional is a function which is proportional to this role.",
                    "label": 0
                },
                {
                    "sent": "And roll star shall reflect sub graph quality and to achieve that.",
                    "label": 0
                },
                {
                    "sent": "We decided to define Rd star of S as the inverse of a distance.",
                    "label": 1
                },
                {
                    "sent": "Between the subgraph sample S and the original graph G. End to reward.",
                    "label": 0
                },
                {
                    "sent": "Good subgraph samples even more.",
                    "label": 0
                },
                {
                    "sent": "We exponentiated that by a large positive scalar P. So that is.",
                    "label": 0
                },
                {
                    "sent": "The function that we actually use in Metropolis to find.",
                    "label": 0
                },
                {
                    "sent": "Good subgraphs.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Input.",
                    "label": 0
                },
                {
                    "sent": "When we ran initial experiments, we observed that good samples samples which approximated the characteristics of the large graph G well.",
                    "label": 0
                },
                {
                    "sent": "They are often connected, so we came up with a slightly modified version which we called chaining, which restricts the search space to connected subgraphs of the original graph G. So we only allow transitions from 1.",
                    "label": 1
                },
                {
                    "sent": "Stage two, the other.",
                    "label": 0
                },
                {
                    "sent": "If both states represent connected subgraphs.",
                    "label": 0
                },
                {
                    "sent": "And what is the effect of this modification on the runtime?",
                    "label": 1
                },
                {
                    "sent": "Obviously designs for search search space is reduced because research space only consists of connected subgraphs.",
                    "label": 0
                },
                {
                    "sent": "But we need an additional check to verify that each of the states S&S prime is connected.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And the third.",
                    "label": 0
                },
                {
                    "sent": "Variant of our approach is to use classic simulated annealing.",
                    "label": 1
                },
                {
                    "sent": "It is.",
                    "label": 0
                },
                {
                    "sent": "A variant of Metropolis for global optimization, back from the 1980s.",
                    "label": 1
                },
                {
                    "sent": "The idea here is that you slightly modify your function row star in each iteration by having a temperature parameter in exponent.",
                    "label": 0
                },
                {
                    "sent": "And this temperature parameter slowly decreases to zero, which has the effect that initially.",
                    "label": 1
                },
                {
                    "sent": "In your metropolis algorithm, you accept a lot of transitions, but the smaller T gets the more difficult it gets to move from one state to the other.",
                    "label": 1
                },
                {
                    "sent": "So more and more transitions are rejected.",
                    "label": 0
                },
                {
                    "sent": "St goes to 0.",
                    "label": 0
                },
                {
                    "sent": "And in all of this, just to mention it, we assume as a metric proposal distribution.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And then after defining these three approaches to representative subgraph sampling, we ran these three methods on five datasets, four of them from the flutes, and let's go veg paper.",
                    "label": 0
                },
                {
                    "sent": "These graphs included 329, two 75,000 nodes.",
                    "label": 0
                },
                {
                    "sent": "And our goal was to find a representative sub graph with N prime equals 100 nodes on these large graphs.",
                    "label": 1
                },
                {
                    "sent": "We ran our three different variants, Metropolis based representative graph sampling, simulated annealing and chaining.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "The graph properties Sigma that we used for sampling were the degree distribution of the graphs, the clustering coefficient.",
                    "label": 1
                },
                {
                    "sent": "Which means which ratio for which ratio of nodes does the following property hold if A is connected to B&A is connected to CRB&C connected as well this this type of information is captured by the clustering coefficient.",
                    "label": 0
                },
                {
                    "sent": "We also use the graph so called graph distribution as a graph property that we try to approximate a graph that is a small sub graph of a given graph of limited size K. And then 4th we use a weighted combination of all these three properties.",
                    "label": 0
                },
                {
                    "sent": "And he compared it to the three families of algorithms defined by deskovic influencers too random at random node and forest fire.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We didn't use exactly the same.",
                    "label": 0
                },
                {
                    "sent": "Criteria that we used for sampling for evaluating our samples.",
                    "label": 0
                },
                {
                    "sent": "So we also use the degree distribution clustering coefficient in the grafted distribution, but also the diameter and we combined each of the criteria that we used for sampling with each of the quality of these properties for evaluation.",
                    "label": 0
                },
                {
                    "sent": "So we didn't always use the same criterion for sampling and for evaluation.",
                    "label": 0
                },
                {
                    "sent": "Results here are averages over all the different properties that we used for evaluation of the quality of our sub graph samples.",
                    "label": 1
                },
                {
                    "sent": "And what we can see here in this plot is that.",
                    "label": 0
                },
                {
                    "sent": "Our methods shown in blue.",
                    "label": 0
                },
                {
                    "sent": "Reach.",
                    "label": 0
                },
                {
                    "sent": "A better sub graph.",
                    "label": 0
                },
                {
                    "sent": "Sample quality, then the classic approaches from this KDD.",
                    "label": 0
                },
                {
                    "sent": "Paper.",
                    "label": 0
                },
                {
                    "sent": "Eight out of our eleven methods are better than the best method defined by less which influences.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Am the ones that fail are ones in which we just try to approximate the clustering coefficient and the graphlet distribution of the original graph.",
                    "label": 0
                },
                {
                    "sent": "So approximating the degree distribution of the original graph works much better in our experiment.",
                    "label": 0
                },
                {
                    "sent": "This comes at the price of an increased runtime.",
                    "label": 0
                },
                {
                    "sent": "So while the classic approaches take less than one second on average, our slowest algorithm takes roughly 5 to 6 minutes.",
                    "label": 0
                },
                {
                    "sent": "But still.",
                    "label": 0
                },
                {
                    "sent": "I personally think that 5 to 6 minutes is an acceptable pre processing time.",
                    "label": 0
                },
                {
                    "sent": "If you don't can do analysis on your small subgraphs sample more efficiently, our fastest algorithm which is Metropolis sampling approximating the degree distribution just takes 3 seconds on average, so.",
                    "label": 0
                },
                {
                    "sent": "This is the most efficient of our our algorithms.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Of course, when we use this.",
                    "label": 0
                },
                {
                    "sent": "Special.",
                    "label": 0
                },
                {
                    "sent": "Varo robe star.",
                    "label": 0
                },
                {
                    "sent": "For measuring the quality office up graph, which is one over the distance between disapprove sample and the graph to the power of P. Then this P has an effect on the quality of the subgraph samples that we obtain, and we check that by repeating our experiments for different values of P and what we observed is that for small values of P we don't get very good.",
                    "label": 0
                },
                {
                    "sent": "Sub graph samples.",
                    "label": 0
                },
                {
                    "sent": "But as we reach.",
                    "label": 0
                },
                {
                    "sent": "Values of 150 and larger.",
                    "label": 0
                },
                {
                    "sent": "Our subgraph samples get get much better.",
                    "label": 0
                },
                {
                    "sent": "So having a large P means that you put a lot of emphasis on really good graphs.",
                    "label": 0
                },
                {
                    "sent": "Really good subgraph samples in your graph and that you strongly reward them.",
                    "label": 0
                },
                {
                    "sent": "And this seems to be important in this.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Application.",
                    "label": 0
                },
                {
                    "sent": "Then we observed and examined the behavior of our algorithm.",
                    "label": 0
                },
                {
                    "sent": "When we change the size of the subgraph samples.",
                    "label": 0
                },
                {
                    "sent": "So far we only looked at a sub graph with N prime equals 100 nodes and now we varied from 1% of the original graph size to 100% of the original graph size, and we've shown here.",
                    "label": 0
                },
                {
                    "sent": "The distance between the subgraph sample and the original graph G for our best method metropolis approximating the degree distribution and the induced forest fire algorithm from the literature, and as we can see here, we all always better, irrespective of subgraph, sample size and especially for low sample size.",
                    "label": 0
                },
                {
                    "sent": "For small sample sizes we outperformed the classic algorithm.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And a final plot.",
                    "label": 0
                },
                {
                    "sent": "Here shows how distance, runtime and subgraph sample size correlate.",
                    "label": 0
                },
                {
                    "sent": "What we can see here is that obviously as our sub graph sample gets larger, our algorithm requires more runtime, but the approximation quality of our algorithm increases the larger sample size gap.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "To summarize our findings, we have proposed three metropolis based approaches to representative subgraph sampling.",
                    "label": 0
                },
                {
                    "sent": "We reach high-quality subgraph samples down to point.",
                    "label": 1
                },
                {
                    "sent": "One 5% of the original draft sites, which is 100 times smaller than the current state of the art.",
                    "label": 0
                },
                {
                    "sent": "And Interestingly, the Metropolis algorithm approximating the degree distribution combines efficiency and sample quality best.",
                    "label": 1
                },
                {
                    "sent": "How can we apply this and what will we do in future work?",
                    "label": 1
                },
                {
                    "sent": "And a direct application is to use the subgraph samples for visualization.",
                    "label": 1
                },
                {
                    "sent": "To use them for approximate graph kernel computation or to perform frequent subgraph mining on them.",
                    "label": 0
                },
                {
                    "sent": "Because the graphics are inherently related to subgraphs in a data set of graphs.",
                    "label": 0
                },
                {
                    "sent": "An future work in future work we will look into representative subgraph mining tasks that only indirectly rely on these topological properties that we've approximated here.",
                    "label": 1
                },
                {
                    "sent": "Such applications include graph clustering and community detection in large networks.",
                    "label": 0
                },
                {
                    "sent": "That concludes my talk, thank you very.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Much I'm happy to answer questions.",
                    "label": 0
                },
                {
                    "sent": "Yes.",
                    "label": 0
                },
                {
                    "sent": "Check for connectivity.",
                    "label": 0
                },
                {
                    "sent": "I did my best, ensuring that you sent the money from North that are connected with current setup so you have a proposal subgraph and you know all the nodes will pick it up so you can restrict it down to the notes that I connected.",
                    "label": 0
                },
                {
                    "sent": "Then you don't have to do this.",
                    "label": 0
                },
                {
                    "sent": "Yes, we want to guarantee a symmetric proposal distribution, and when you remove one note from the sub graph sample, you have to make sure and at the new one then.",
                    "label": 0
                },
                {
                    "sent": "It it could be that removing that one node disconnects your current subgraph sample.",
                    "label": 0
                },
                {
                    "sent": "So then you know then would have to reconnect it again.",
                    "label": 0
                },
                {
                    "sent": "And we haven't.",
                    "label": 0
                },
                {
                    "sent": "Yeah, well, you look into that, but at the moment that's the way of guaranteeing that both the current state and and you state are connected.",
                    "label": 0
                },
                {
                    "sent": "You're you're approaching.",
                    "label": 0
                },
                {
                    "sent": "That's what I tried to mention during the talk.",
                    "label": 0
                },
                {
                    "sent": "It was possible because we, as I said, we didn't use exactly the same criteria for evaluation that we had used for sampling before.",
                    "label": 0
                },
                {
                    "sent": "So even when we had.",
                    "label": 0
                },
                {
                    "sent": "Approximated the degree distribution of the original graph, then we better approximated.",
                    "label": 0
                },
                {
                    "sent": "The graph, the distribution and clustering coefficient in forest fire.",
                    "label": 0
                },
                {
                    "sent": "So we didn't use exactly the same properties for approximation an for evaluation, we combined all different properties with each other and.",
                    "label": 0
                },
                {
                    "sent": "Even if YouTube are different, we did better than forest fire.",
                    "label": 0
                },
                {
                    "sent": "But I agree that of course first fire somehow blind to the properties of the large graph.",
                    "label": 0
                },
                {
                    "sent": "I think the.",
                    "label": 0
                },
                {
                    "sent": "The most important aspect is that.",
                    "label": 0
                },
                {
                    "sent": "You have to ensure that the properties of the large graph can be computed efficiently.",
                    "label": 0
                },
                {
                    "sent": "That's somehow that for me is the biggest bottleneck of our approach.",
                    "label": 0
                },
                {
                    "sent": "So how do you guarantee that you can actually compute Sigma of G?",
                    "label": 0
                },
                {
                    "sent": "The properties of the original graph, but a very encouraging result is that computing the degree distribution.",
                    "label": 0
                },
                {
                    "sent": "Often large graph which is.",
                    "label": 0
                },
                {
                    "sent": "Pretty cheap to do.",
                    "label": 0
                },
                {
                    "sent": "An already gives you very good results and better results than those published in the literature.",
                    "label": 0
                },
                {
                    "sent": "Function.",
                    "label": 0
                },
                {
                    "sent": "Think of somebody who makes statement received number of nodes in graph.",
                    "label": 0
                },
                {
                    "sent": "Roger so the amazing.",
                    "label": 0
                },
                {
                    "sent": "So what we observed here, but what I can tell from our experiments is that degree distribution works surprisingly well, and that the crossing coefficient in the graph the distribution.",
                    "label": 0
                },
                {
                    "sent": "Do not give that good subgraph samples, so it might be some variant of the degree distribution or something that is inherently related.",
                    "label": 0
                },
                {
                    "sent": "That could give you even better subgraph samples, but it obviously also depends on your particular application.",
                    "label": 0
                },
                {
                    "sent": "So, for example, you might want to include node labels or something like that in your sampling process, which we don't do here.",
                    "label": 0
                },
                {
                    "sent": "So we just take the graphs as being unlabeled and we want to preserve the topology of of the graphs, nothing, nothing else, so we're focused on topology here, and you could enrich.",
                    "label": 0
                },
                {
                    "sent": "The criteria by adding.",
                    "label": 0
                },
                {
                    "sent": "Other types of information.",
                    "label": 0
                },
                {
                    "sent": "I have a question overall, how does the computational complexity of the sampling scale with the size of the graphs?",
                    "label": 0
                },
                {
                    "sent": "Well, worst case you have to explore all the subgraphs of the.",
                    "label": 0
                },
                {
                    "sent": "Of the given graph, to get the optimal globally optimal solution to this, but.",
                    "label": 0
                },
                {
                    "sent": "Even though we didn't necessarily find the global optimal solutions or the solutions that we got in our process after a fixed number of steps were much better than those that have been reported in the literature.",
                    "label": 0
                },
                {
                    "sent": "X number of steps is a function of the size of the graph.",
                    "label": 0
                },
                {
                    "sent": "Yeah, you try to make them depend on the on the number of nodes in the number of edges in your graph.",
                    "label": 0
                },
                {
                    "sent": "So you basically need a rule of thumb for setting the number of iterations.",
                    "label": 0
                },
                {
                    "sent": "Any other questions?",
                    "label": 0
                },
                {
                    "sent": "Well, we haven't analyzed the mixing time yet, but we will look into that.",
                    "label": 0
                },
                {
                    "sent": "Next thank you very much.",
                    "label": 1
                }
            ]
        }
    }
}