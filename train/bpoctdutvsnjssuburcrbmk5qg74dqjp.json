{
    "id": "bpoctdutvsnjssuburcrbmk5qg74dqjp",
    "title": "The Fast Bilateral Solver",
    "info": {
        "author": [
            "Jonathan Barron, Google, Inc."
        ],
        "published": "Oct. 24, 2016",
        "recorded": "October 2016",
        "category": [
            "Top->Computer Science->Computer Vision"
        ]
    },
    "url": "http://videolectures.net/eccv2016_barron_bilateral_solver/",
    "segmentation": [
        [
            "Hi.",
            "How's it going?",
            "My name is John Barron.",
            "I'm at Google research.",
            "This work was done with Ben Poole from Stanford, who was also at Google's summer.",
            "Is this volume OK we?",
            "OK. Um?",
            "So many of us are probably familiar with the bilateral filter, which is a filter that blurs within regions but not across edges."
        ],
        [
            "So here we have what's usually called a joint bilateral filter, in which some input image Y is filtered with respect to the edges of some reference image R, and this gives us the output image X shown there.",
            "Bilateral filter is widely used in image processing and is often used in computer vision algorithms like the dense CRF as a way to do message passing between pixels."
        ],
        [
            "Mathematically, a bilateral filter, just a matrix vector product where the input image is a vector that gets multiplied by an affinity matrix W. The key aspect of a bilateral filter is that this W is image dependent, so its affinity is the Gaussian distance between two pixels, both in terms of position like a simple blur would be, but also in terms of color."
        ],
        [
            "In this talk, we'll introduce the idea of a bilateral solver, which looks very similar to a bilateral filter, except that instead of simply applying an operator to the input image, we solve an optimization problem that gives us an output image that is as smooth as possible while also being as close as possible to the input image."
        ],
        [
            "This is the math for that where we have a smoothness term based on that matrix W that I showed earlier and a data term that is just squared distance from the input."
        ],
        [
            "So 1 interesting thing you can prove about the bilateral solver is that under certain conditions applying a bilateral filter is exactly equivalent to performing one gradient descent step of the bilateral solver loss.",
            "So this means you can think of the bilateral filter as being like an incomplete application of a bilateral solver.",
            "As you might expect, minimizing this loss to convergence produces significantly better results."
        ],
        [
            "So in addition to that theoretical connection, bilateral silver has a lot of other really nice properties."
        ],
        [
            "So first it's fast naively solving the problem that I first stated for the solver is basically intractable, but we can use techniques from fast bilateral filtering literature to reduce the problem and solve it very quickly, and that reduced form."
        ],
        [
            "Second, the solver has the flexibility of a simple linear filter, and this lets us easily generalize it into a number of variants."
        ],
        [
            "3rd, the solver, and its variance napping to perform really well on a number of tasks in the computer vision and image processing."
        ],
        [
            "So the key insight behind our solver is past work on techniques for fast, bilateral filtering, which basically show how to decompose a bilateral filter into a splat blur and slice operation that are shown here."
        ],
        [
            "More recently, it's been shown that this insight can be used to solve optimization problems or graph cut problems based around bilateral kernels.",
            "In this bilateral space, which is what we will do as well."
        ],
        [
            "So just briefly show how this is possible.",
            "Let's assume that we have a bilateral kernel of the form shown here."
        ],
        [
            "Building on past work, we can show that this matrix can be written as the following decomposition."
        ],
        [
            "And you can see why this decomposition is a powerful idea when you visualize the matrices."
        ],
        [
            "So the affinity matrix W is large and dense, so much so that it can sometimes even be difficult to hold the entire matrix in memory for a large image, and This is why bilateral filtering is generally slow."
        ],
        [
            "But this decomposition has these skinny sparse matrices at the ends."
        ],
        [
            "And then a bunch of small and sparse matrices in the middle."
        ],
        [
            "And So what we're going to do is we're going to use that first matrix to splat or Re sample an optimization problem into bilateral space."
        ],
        [
            "And then we'll solve the problem in this reduced bilateral space using these tiny sparse matrices, and then we."
        ],
        [
            "Slice out the solution when we're done."
        ],
        [
            "So you can take that idea and then take this expensive pixel space optimization problem and."
        ],
        [
            "That would be formulated into this bilateral space problem which we can solve very quickly."
        ],
        [
            "I'm glossing over a lot of details about how the math works out and how we can do this efficiently using hierarchal preconditioning initialization, so please check out the paper for details."
        ],
        [
            "The first task we're going to wait on is the depth Super resolution task using the Middlebury stereo data set, which many people have looked at in other works.",
            "This task is sort of a proxy for improving the output of RGB D sensors like the Connect which produce noisy and incomplete depth Maps that are roughly aligned with RGB images."
        ],
        [
            "So here we have as input a low resolution depth map Y and an RGB reference R. And."
        ],
        [
            "With this we can produce a full resolution depth map X using the bilateral solver.",
            "And."
        ],
        [
            "Naturally, we compare this to the ground truth depth map to see how well we're doing.",
            "So."
        ],
        [
            "We evaluated against a very large number of baseline techniques, some of which are shown here.",
            "The solver is highlighted in the lower right."
        ],
        [
            "And to make comparison easier, here's a table of different techniques along with their error on this task and their runtime in seconds.",
            "All of the baselines are sorted by decreasing error in the bilateral solver is at the bottom, so it doesn't have the lowest error, so we can see it produces the third lowest error.",
            "Of all these techniques, and takes little less than 1/4 of a second to do so."
        ],
        [
            "There are a few techniques which produce output that is comparable to or better than the solver, but all of these techniques take hundreds or thousands of times longer than the solver.",
            "Also, the top two performing techniques rely on lots of external training data from other datasets.",
            "While we have no learning at all, it's just kind of a filter."
        ],
        [
            "So another comparison is against a normal bilateral filter which you can see has both a higher error and a higher runtime than our bilateral solver."
        ],
        [
            "And there are a few eduware filtering techniques like the guided filter and things like that which have runtimes that are as fast or faster than the solver.",
            "But they all have significantly higher error rates, so overall bilateral solver represents a nice combination of high quality and high speed for this task."
        ],
        [
            "So we presented this bilateral solver which solves the optimization problem shown at the top by reducing it to linear system shown below."
        ],
        [
            "And it's trivial to generalize this to a weighted bilateral solver, in which each input value comes with the confidence value shown as vector C here."
        ],
        [
            "This weighted bilateral solver can be used for inpainting like problems like this colorization scribble task, so our input is a grayscale image along with some hand labeled color values and a binary mask showing which pixels contain a scribbled color, and the output is of course a fully colorized image."
        ],
        [
            "There isn't really a quantitative evaluation that people do for this task, but qualitatively we can see that we produce output that looks very similar to existing techniques, while being roughly 95 times faster."
        ],
        [
            "So this weighted bilateral solver enables another generalization."
        ],
        [
            "In which we swap out our weighted loss function for some arbitrary robust loss function, and this lets us use the bilateral solver in an iteratively repeatedly squares framework, where the confidence is repeatedly re estimated in a loop.",
            "The pseudocode is actually an oversimplification."
        ],
        [
            "This can actually be made much more efficient by doing the ILS in bilateral space, which is pretty neat.",
            "So this robust bilateral solver is good for tasks where high quality output is more important than speed.",
            "And to show this will evaluate on the Middlebury stereo."
        ],
        [
            "Task.",
            "So here we have the output of the state of the Art MC, CNN, Sarah algorithm, which produces very accurate results for most pixels but grossly inaccurate results for others, usually near death discontinuity's.",
            "As you can see here.",
            "So there are some zoomed in regions which show on the right to show you details.",
            "And here is come on."
        ],
        [
            "Yeah, so here we use the robust bilateral solver using a given McClure loss function to produce the step map.",
            "You can see that the depth is much cleaner and very tightly aligned to the reference image, which is what we want."
        ],
        [
            "Here is another example where you have MC CNN's output."
        ],
        [
            "And then we have the result of post processing that output with a robust bilateral solver."
        ],
        [
            "So using the solver as opposed processing step for MC CNN reduces tested error by a factor of two roughly which put it at the top of the chart for the Middlebury stereo benchmark at the time of submission for those error metrics."
        ],
        [
            "We also tried several other Edgware filters that you could use for post processing, and we saw that the robust bilateral solver produced lower errors than everything else we tried, so these experiments are done on the training set of the middle or data set, which is what you need to do when you're doing aggressive experimentation like this."
        ],
        [
            "So this improvement is consistent across different choices for the underlying stereo algorithm, although the improvement is generally smaller when the input depth Maps are worse.",
            "Here's another."
        ],
        [
            "Algorithm."
        ],
        [
            "And another."
        ],
        [
            "So instead of smoothing depth Maps, we can use the bilateral solver to smooth out a course per pixel semantic labeling like the one shown here.",
            "So to get an edge aware semantic segmentation."
        ],
        [
            "Yeah, so one convenient property of the solver is that you can treat it like a like a layer in a deep learning pipeline as one does.",
            "And we can backdrop through the solver back onto the CNN that produced the initial course labeling."
        ],
        [
            "So here we have the forward pass of the solver viewed as a kind of layer."
        ],
        [
            "And here we have the backward pass.",
            "You can see that they are identical.",
            "So doing a backdrop just requires calling the solver again."
        ],
        [
            "This makes the solver really easy to use, especially compared to other CRF RNN type techniques where you need to unroll the model and do a lot of extra bookkeeping and computation just to backdrop through them."
        ],
        [
            "So here we have a Pascal image, which is the input to CNN and also the reference image for the solver."
        ],
        [
            "Here we have the output of the deep lab model, which was one of the top performing techniques for this task.",
            "It's mission time.",
            "This is a fast technique and it's fairly accurate, but the labels are very coarse, kind of blobby and poorly aligned to the reference image."
        ],
        [
            "Here we have the output of deep lab after it's been passed through a dense CRF, so the output looks a lot better and the accuracy is gone up.",
            "But this is very computationally expensive with the density of taking nearly a full second to process the image."
        ],
        [
            "And here we have the output of deep web efforts and passed through a bilateral solver.",
            "So the the accuracy is less than we get from a dense CRF, but we do still see a significant improvement from the input, and the labels still have that qualitative property where they are tightly aligned to the reference image.",
            "The real advantage here is that the solver is 11 times faster than CRF.",
            "An is roughly as expensive to evaluate as a CNN itself, so it's smoothing step is no longer the bottleneck during evaluation like it is with a dense era."
        ],
        [
            "As a quick preview, an extension of this bilateral solver is also being used as part of jump, which is Google's virtual reality camera platform.",
            "Thought I'd advertise that here."
        ],
        [
            "So the jump camera is a ring of cameras with different focal points, so producing stereoscopic 360 video requires taking each video feed in this ring and performing optical flow across adjacent cameras.",
            "So."
        ],
        [
            "For this task we apply the bilateral solver to entire video sequences, which produces temporally consistent Edgware flow fields from 1 camera to the next, and because every pixel in a jump video is the output of some view interpolation algorithm that's based on this flow field, the aggressive smoothing and painting that we get from the solver is basically necessary to prevent sort of egregious artifacts in these VR videos.",
            "So there's an upcoming cigarette Asia Paper, so please check that out for details."
        ],
        [
            "So to conclude, we presented the bilateral solver which is a simple, fast and effective tool for smoothing things in an edge aware way."
        ],
        [
            "Solver is nearly as fast as a bilateral filter, but it produces significantly higher quality output."
        ],
        [
            "And we've shown that the solver and different variants of IT work well on a variety of tasks."
        ],
        [
            "And we've shown that it can be easily integrated into deep learning pipelines."
        ],
        [
            "If you're interested in using this, we made a Python implementation available at this address.",
            "This is not the exact same code that was used to make results in the paper, so it may behave slightly differently.",
            "It's also not well optimized.",
            "The runtimes will be slightly slower, but should be very easy to use and experiment with for a lot of things."
        ],
        [
            "And that's it.",
            "Thank you."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Hi.",
                    "label": 0
                },
                {
                    "sent": "How's it going?",
                    "label": 0
                },
                {
                    "sent": "My name is John Barron.",
                    "label": 0
                },
                {
                    "sent": "I'm at Google research.",
                    "label": 0
                },
                {
                    "sent": "This work was done with Ben Poole from Stanford, who was also at Google's summer.",
                    "label": 1
                },
                {
                    "sent": "Is this volume OK we?",
                    "label": 0
                },
                {
                    "sent": "OK. Um?",
                    "label": 0
                },
                {
                    "sent": "So many of us are probably familiar with the bilateral filter, which is a filter that blurs within regions but not across edges.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So here we have what's usually called a joint bilateral filter, in which some input image Y is filtered with respect to the edges of some reference image R, and this gives us the output image X shown there.",
                    "label": 0
                },
                {
                    "sent": "Bilateral filter is widely used in image processing and is often used in computer vision algorithms like the dense CRF as a way to do message passing between pixels.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Mathematically, a bilateral filter, just a matrix vector product where the input image is a vector that gets multiplied by an affinity matrix W. The key aspect of a bilateral filter is that this W is image dependent, so its affinity is the Gaussian distance between two pixels, both in terms of position like a simple blur would be, but also in terms of color.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In this talk, we'll introduce the idea of a bilateral solver, which looks very similar to a bilateral filter, except that instead of simply applying an operator to the input image, we solve an optimization problem that gives us an output image that is as smooth as possible while also being as close as possible to the input image.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This is the math for that where we have a smoothness term based on that matrix W that I showed earlier and a data term that is just squared distance from the input.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So 1 interesting thing you can prove about the bilateral solver is that under certain conditions applying a bilateral filter is exactly equivalent to performing one gradient descent step of the bilateral solver loss.",
                    "label": 1
                },
                {
                    "sent": "So this means you can think of the bilateral filter as being like an incomplete application of a bilateral solver.",
                    "label": 0
                },
                {
                    "sent": "As you might expect, minimizing this loss to convergence produces significantly better results.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So in addition to that theoretical connection, bilateral silver has a lot of other really nice properties.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So first it's fast naively solving the problem that I first stated for the solver is basically intractable, but we can use techniques from fast bilateral filtering literature to reduce the problem and solve it very quickly, and that reduced form.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Second, the solver has the flexibility of a simple linear filter, and this lets us easily generalize it into a number of variants.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "3rd, the solver, and its variance napping to perform really well on a number of tasks in the computer vision and image processing.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the key insight behind our solver is past work on techniques for fast, bilateral filtering, which basically show how to decompose a bilateral filter into a splat blur and slice operation that are shown here.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "More recently, it's been shown that this insight can be used to solve optimization problems or graph cut problems based around bilateral kernels.",
                    "label": 0
                },
                {
                    "sent": "In this bilateral space, which is what we will do as well.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So just briefly show how this is possible.",
                    "label": 0
                },
                {
                    "sent": "Let's assume that we have a bilateral kernel of the form shown here.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Building on past work, we can show that this matrix can be written as the following decomposition.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And you can see why this decomposition is a powerful idea when you visualize the matrices.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the affinity matrix W is large and dense, so much so that it can sometimes even be difficult to hold the entire matrix in memory for a large image, and This is why bilateral filtering is generally slow.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "But this decomposition has these skinny sparse matrices at the ends.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And then a bunch of small and sparse matrices in the middle.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And So what we're going to do is we're going to use that first matrix to splat or Re sample an optimization problem into bilateral space.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And then we'll solve the problem in this reduced bilateral space using these tiny sparse matrices, and then we.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Slice out the solution when we're done.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So you can take that idea and then take this expensive pixel space optimization problem and.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "That would be formulated into this bilateral space problem which we can solve very quickly.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "I'm glossing over a lot of details about how the math works out and how we can do this efficiently using hierarchal preconditioning initialization, so please check out the paper for details.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The first task we're going to wait on is the depth Super resolution task using the Middlebury stereo data set, which many people have looked at in other works.",
                    "label": 0
                },
                {
                    "sent": "This task is sort of a proxy for improving the output of RGB D sensors like the Connect which produce noisy and incomplete depth Maps that are roughly aligned with RGB images.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So here we have as input a low resolution depth map Y and an RGB reference R. And.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "With this we can produce a full resolution depth map X using the bilateral solver.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Naturally, we compare this to the ground truth depth map to see how well we're doing.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We evaluated against a very large number of baseline techniques, some of which are shown here.",
                    "label": 0
                },
                {
                    "sent": "The solver is highlighted in the lower right.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And to make comparison easier, here's a table of different techniques along with their error on this task and their runtime in seconds.",
                    "label": 0
                },
                {
                    "sent": "All of the baselines are sorted by decreasing error in the bilateral solver is at the bottom, so it doesn't have the lowest error, so we can see it produces the third lowest error.",
                    "label": 0
                },
                {
                    "sent": "Of all these techniques, and takes little less than 1/4 of a second to do so.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "There are a few techniques which produce output that is comparable to or better than the solver, but all of these techniques take hundreds or thousands of times longer than the solver.",
                    "label": 0
                },
                {
                    "sent": "Also, the top two performing techniques rely on lots of external training data from other datasets.",
                    "label": 0
                },
                {
                    "sent": "While we have no learning at all, it's just kind of a filter.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So another comparison is against a normal bilateral filter which you can see has both a higher error and a higher runtime than our bilateral solver.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And there are a few eduware filtering techniques like the guided filter and things like that which have runtimes that are as fast or faster than the solver.",
                    "label": 0
                },
                {
                    "sent": "But they all have significantly higher error rates, so overall bilateral solver represents a nice combination of high quality and high speed for this task.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we presented this bilateral solver which solves the optimization problem shown at the top by reducing it to linear system shown below.",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And it's trivial to generalize this to a weighted bilateral solver, in which each input value comes with the confidence value shown as vector C here.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This weighted bilateral solver can be used for inpainting like problems like this colorization scribble task, so our input is a grayscale image along with some hand labeled color values and a binary mask showing which pixels contain a scribbled color, and the output is of course a fully colorized image.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "There isn't really a quantitative evaluation that people do for this task, but qualitatively we can see that we produce output that looks very similar to existing techniques, while being roughly 95 times faster.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So this weighted bilateral solver enables another generalization.",
                    "label": 0
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In which we swap out our weighted loss function for some arbitrary robust loss function, and this lets us use the bilateral solver in an iteratively repeatedly squares framework, where the confidence is repeatedly re estimated in a loop.",
                    "label": 0
                },
                {
                    "sent": "The pseudocode is actually an oversimplification.",
                    "label": 0
                }
            ]
        },
        "clip_39": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "This can actually be made much more efficient by doing the ILS in bilateral space, which is pretty neat.",
                    "label": 1
                },
                {
                    "sent": "So this robust bilateral solver is good for tasks where high quality output is more important than speed.",
                    "label": 1
                },
                {
                    "sent": "And to show this will evaluate on the Middlebury stereo.",
                    "label": 0
                }
            ]
        },
        "clip_40": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Task.",
                    "label": 0
                },
                {
                    "sent": "So here we have the output of the state of the Art MC, CNN, Sarah algorithm, which produces very accurate results for most pixels but grossly inaccurate results for others, usually near death discontinuity's.",
                    "label": 0
                },
                {
                    "sent": "As you can see here.",
                    "label": 0
                },
                {
                    "sent": "So there are some zoomed in regions which show on the right to show you details.",
                    "label": 0
                },
                {
                    "sent": "And here is come on.",
                    "label": 0
                }
            ]
        },
        "clip_41": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Yeah, so here we use the robust bilateral solver using a given McClure loss function to produce the step map.",
                    "label": 0
                },
                {
                    "sent": "You can see that the depth is much cleaner and very tightly aligned to the reference image, which is what we want.",
                    "label": 0
                }
            ]
        },
        "clip_42": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here is another example where you have MC CNN's output.",
                    "label": 0
                }
            ]
        },
        "clip_43": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And then we have the result of post processing that output with a robust bilateral solver.",
                    "label": 0
                }
            ]
        },
        "clip_44": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So using the solver as opposed processing step for MC CNN reduces tested error by a factor of two roughly which put it at the top of the chart for the Middlebury stereo benchmark at the time of submission for those error metrics.",
                    "label": 0
                }
            ]
        },
        "clip_45": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We also tried several other Edgware filters that you could use for post processing, and we saw that the robust bilateral solver produced lower errors than everything else we tried, so these experiments are done on the training set of the middle or data set, which is what you need to do when you're doing aggressive experimentation like this.",
                    "label": 0
                }
            ]
        },
        "clip_46": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So this improvement is consistent across different choices for the underlying stereo algorithm, although the improvement is generally smaller when the input depth Maps are worse.",
                    "label": 0
                },
                {
                    "sent": "Here's another.",
                    "label": 0
                }
            ]
        },
        "clip_47": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Algorithm.",
                    "label": 0
                }
            ]
        },
        "clip_48": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And another.",
                    "label": 0
                }
            ]
        },
        "clip_49": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So instead of smoothing depth Maps, we can use the bilateral solver to smooth out a course per pixel semantic labeling like the one shown here.",
                    "label": 0
                },
                {
                    "sent": "So to get an edge aware semantic segmentation.",
                    "label": 0
                }
            ]
        },
        "clip_50": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Yeah, so one convenient property of the solver is that you can treat it like a like a layer in a deep learning pipeline as one does.",
                    "label": 0
                },
                {
                    "sent": "And we can backdrop through the solver back onto the CNN that produced the initial course labeling.",
                    "label": 0
                }
            ]
        },
        "clip_51": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So here we have the forward pass of the solver viewed as a kind of layer.",
                    "label": 0
                }
            ]
        },
        "clip_52": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And here we have the backward pass.",
                    "label": 0
                },
                {
                    "sent": "You can see that they are identical.",
                    "label": 0
                },
                {
                    "sent": "So doing a backdrop just requires calling the solver again.",
                    "label": 0
                }
            ]
        },
        "clip_53": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This makes the solver really easy to use, especially compared to other CRF RNN type techniques where you need to unroll the model and do a lot of extra bookkeeping and computation just to backdrop through them.",
                    "label": 0
                }
            ]
        },
        "clip_54": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So here we have a Pascal image, which is the input to CNN and also the reference image for the solver.",
                    "label": 0
                }
            ]
        },
        "clip_55": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here we have the output of the deep lab model, which was one of the top performing techniques for this task.",
                    "label": 0
                },
                {
                    "sent": "It's mission time.",
                    "label": 0
                },
                {
                    "sent": "This is a fast technique and it's fairly accurate, but the labels are very coarse, kind of blobby and poorly aligned to the reference image.",
                    "label": 0
                }
            ]
        },
        "clip_56": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here we have the output of deep lab after it's been passed through a dense CRF, so the output looks a lot better and the accuracy is gone up.",
                    "label": 0
                },
                {
                    "sent": "But this is very computationally expensive with the density of taking nearly a full second to process the image.",
                    "label": 0
                }
            ]
        },
        "clip_57": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And here we have the output of deep web efforts and passed through a bilateral solver.",
                    "label": 0
                },
                {
                    "sent": "So the the accuracy is less than we get from a dense CRF, but we do still see a significant improvement from the input, and the labels still have that qualitative property where they are tightly aligned to the reference image.",
                    "label": 0
                },
                {
                    "sent": "The real advantage here is that the solver is 11 times faster than CRF.",
                    "label": 0
                },
                {
                    "sent": "An is roughly as expensive to evaluate as a CNN itself, so it's smoothing step is no longer the bottleneck during evaluation like it is with a dense era.",
                    "label": 0
                }
            ]
        },
        "clip_58": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "As a quick preview, an extension of this bilateral solver is also being used as part of jump, which is Google's virtual reality camera platform.",
                    "label": 0
                },
                {
                    "sent": "Thought I'd advertise that here.",
                    "label": 0
                }
            ]
        },
        "clip_59": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the jump camera is a ring of cameras with different focal points, so producing stereoscopic 360 video requires taking each video feed in this ring and performing optical flow across adjacent cameras.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_60": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "For this task we apply the bilateral solver to entire video sequences, which produces temporally consistent Edgware flow fields from 1 camera to the next, and because every pixel in a jump video is the output of some view interpolation algorithm that's based on this flow field, the aggressive smoothing and painting that we get from the solver is basically necessary to prevent sort of egregious artifacts in these VR videos.",
                    "label": 0
                },
                {
                    "sent": "So there's an upcoming cigarette Asia Paper, so please check that out for details.",
                    "label": 0
                }
            ]
        },
        "clip_61": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So to conclude, we presented the bilateral solver which is a simple, fast and effective tool for smoothing things in an edge aware way.",
                    "label": 0
                }
            ]
        },
        "clip_62": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Solver is nearly as fast as a bilateral filter, but it produces significantly higher quality output.",
                    "label": 0
                }
            ]
        },
        "clip_63": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And we've shown that the solver and different variants of IT work well on a variety of tasks.",
                    "label": 0
                }
            ]
        },
        "clip_64": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And we've shown that it can be easily integrated into deep learning pipelines.",
                    "label": 0
                }
            ]
        },
        "clip_65": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "If you're interested in using this, we made a Python implementation available at this address.",
                    "label": 0
                },
                {
                    "sent": "This is not the exact same code that was used to make results in the paper, so it may behave slightly differently.",
                    "label": 1
                },
                {
                    "sent": "It's also not well optimized.",
                    "label": 0
                },
                {
                    "sent": "The runtimes will be slightly slower, but should be very easy to use and experiment with for a lot of things.",
                    "label": 0
                }
            ]
        },
        "clip_66": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And that's it.",
                    "label": 0
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                }
            ]
        }
    }
}