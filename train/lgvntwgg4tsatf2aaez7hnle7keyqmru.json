{
    "id": "lgvntwgg4tsatf2aaez7hnle7keyqmru",
    "title": "Fast Subtree Kernels on Graphs",
    "info": {
        "author": [
            "Nino Shervashidze, Max Planck Institute for Developmental Biology, Max Planck Institute"
        ],
        "published": "Jan. 19, 2010",
        "recorded": "December 2009",
        "category": [
            "Top->Computer Science->Machine Learning->Kernel Methods"
        ]
    },
    "url": "http://videolectures.net/nips09_shervashidze_fsk/",
    "segmentation": [
        [
            "Thank you for the introduction, so I will present my joint work with Carson Boquette.",
            "First subtree chromosone graphs.",
            "First of all, what are kernels?",
            "Mathematically, kernels are inner products.",
            "In some future space, and so they are functions of two arguments, excellent X prime.",
            "An it corresponds to an inner product in a space where X&X prime are mapped."
        ],
        [
            "Via feature map file.",
            "Sorry."
        ],
        [
            "Should I repeat what I said?",
            "OK.",
            "So first of all, kernels are functions of two arguments, X an expr."
        ],
        [
            "And they correspond to a future to inner products in some future space where X&X prime are mapped to by mapping file.",
            "And intuitively, a kernel is a measure of similarity."
        ],
        [
            "Cards can be defined on vectors, but they can also be defined on structured objects like strings, trees or graphs, and our focus in this work is graph kernels.",
            "So kernels are graphs.",
            "Well, with kernels one can tackle.",
            "A number of tasks in machine learning, like classification with SVM's as a famous example, regression feature selection, statistical tests and so on.",
            "Why it is good to have graph kernels?",
            "What can we do with that?",
            "For example, this can be used in graph classification and graphics classification has probably its most typical application in chemoinformatics, where small molecules are represented as graphs.",
            "And.",
            "So we were given a set of molecules and we know.",
            "What properties they have or whether they are toxic or non toxic for example, or mutagen?"
        ],
        [
            "The ornament anonymous genetic like here and then when a new molecule arrives, we want to be able to determine which class it belongs to and for that we need a similarity measure on graphs.",
            "So just to be precise, we're talking about similarity measures on different graphs, not notes in one single."
        ],
        [
            "Graph.",
            "How to graph kernels usually work usually play count.",
            "Matchings of subgraphs between two graphs.",
            "And this sub graphs are usually paths, works psych."
        ],
        [
            "Cause of profits graphics are small fixed size."
        ],
        [
            "Quest.",
            "Why don't we count all subgraphs and restrict the this to some special classes of subgraphs?",
            "Or because all subgraphs kernel is at least as hard to compute as graph isomorphism checking, and there is still no polynomial time algorithm known for qualifies a morphism."
        ],
        [
            "So that's why people consider restricted classes of subgraphs, and if you have a polynomial time computable graph kernel, then you always have two graphs that are not isomorphic, but they are mapped to the same point by by the kernel.",
            "And but even with this restricted classes of subgraphs, current graph kernels breakdown when graphs have Norton Ledge labels and they are large and by large I mean they have several hundreds or even thousands of nodes.",
            "And this is what I am trying to illustrate here on this spot so.",
            "Here I will show the runtime behavior of several graph kernels on toy example.",
            "So this subtree, Colonel Byron, Man and Gardner is becomes intractable very fast.",
            "Unfortunately, with the graph size growing fast from random walk kernel is."
        ],
        [
            "A bit faster, but it also dictionary generates quite quickly."
        ],
        [
            "They showed us a certain instances of their shortest path, kernel Bible gotten quicker I faster than the random walk kernel.",
            "And."
        ],
        [
            "Counting three graph, let's met, meaning all subgraphs of size 3 in a graph is more efficient, but it is still not very scalable when grass become very large."
        ],
        [
            "And here I'm going to present a graph kernel.",
            "The computation time of which scales like this.",
            "So it scales linearly in the number of edges.",
            "So here I will next I will try to explain how this graph kernel."
        ],
        [
            "First of all, it is a subtree kernel, and informally what subtree can also is the following.",
            "They iteratively look at neighborhoods of nodes.",
            "So consider this graph and the note one.",
            "In the first situation, there not one will look at its neighbors 2, three and six.",
            "And the second iteration it will also look at 2, three and six.",
            "But as to."
        ],
        [
            "Three and six have themselves already looked at their neighbors.",
            "If we unfold this structure of information flow, we get this tree like structure here.",
            "That is called subtree or tree."
        ],
        [
            "Look in the literature.",
            "So."
        ],
        [
            "Our graph criminal counts these kinds of substructures.",
            "And the algorithm for computing our kernel is inspired by a very efficient.",
            "Approximation to graph isomorphism checking, called the one dimensional Vice Felimon algorithm from 1968.",
            "So I will try to explain this algorithm on it on an example.",
            "Suppose we are given these two graphs, and they're unlabeled, so I gave the notes with same label one, and we want to know whether they are not isomorphic.",
            "The one dimensional rise Felimon algorithm will ever tell me that they are not isomorphic.",
            "Or that it doesn't know.",
            "This is why it is approx."
        ],
        [
            "So the virtual Emma algorithm proceeds in iterations, and each iteration has three key steps.",
            "First step is multiset label determination and sorting.",
            "This means that for each node we collect the labels of the neighbors of these nodes.",
            "We sort this list and concatenate this to the label of the original node.",
            "So like here, if we look at the top node of the graph on the left.",
            "It has two neighbors, one and one with labels one at one.",
            "If we sort one and one, we get one one, and so the resulting multiset label on the figure below is 1.",
            "Come up on anyone.",
            "And the other multi set labels are constructed following the same principle.",
            "This can be done in all of number of edges.",
            "Outback it sort.",
            "The second step is label compression.",
            "That means that we don't want to keep this long multi set labels and we want to compress them with the."
        ],
        [
            "Just one number, so each of them by 1 number and for that what we do is we sort all those multiset labels for each note and then rename the multiset labels by short labels."
        ],
        [
            "And this can also be done in over a number of edges where theoretic sort."
        ],
        [
            "The first step is relabeling of the graph.",
            "Here we just replace the multiset labels by the compressed labels that we just.",
            "Just constructed.",
            "And at the end of each iteration of the one dimensional advice for Element, Algorithm asks whether they label sets of G&G Prime are identical."
        ],
        [
            "Here we have twice to 3 * 2, twice three, an once four in each graph, so they label sets arrive."
        ],
        [
            "Anticop, so we continue and the second iteration we have exactly the same."
        ],
        [
            "Steps, so we determined medicine multiset labels.",
            "We sought them.",
            "We compress the label."
        ],
        [
            "Goodbye first."
        ],
        [
            "The sorting this drinks and then associating associating compressed label to each."
        ],
        [
            "And then we label the graph."
        ],
        [
            "No other label sets of G&G prime identical.",
            "They are not identical anymore.",
            "For example, they note Label 5 appears in the in G prime, but doesn't appear in G, so again."
        ],
        [
            "Graphs are non isomorphic.",
            "And overall complexity of this algorithm."
        ],
        [
            "Over HM4H iterations.",
            "Now.",
            "Here are pointing out the differences between the West filament isomorphism test and the kernel that I'm going to define.",
            "So at the end of each iteration, the test checks sets of note labels of the graphs whether they are identical or not.",
            "And it stops when the sets become different or when the number of iteration reaches an because if it reaches and then we know that it won't change anymore.",
            "And it's computed in our MSA set.",
            "The Colonel in can't."
        ],
        [
            "Just at the end of each iteration, it's counts matching pairs of labels into graphs.",
            "And the number of iterations here is is a parameter because we don't care whether.",
            "Label sets in two graphs are not the same.",
            "But we are interested interested in the identical labels in two graphs and not least that identity of the sets.",
            "And this is also computed in all of HM.",
            "Here I will show on a simple example how they kind of works.",
            "So suppose we are given this to labeled graphs.",
            "Anne here justice."
        ],
        [
            "Right now if we run Vice Element S on these two graphs, it won't even begin because the label sets are already different.",
            "For example, we have labeled one twice in G and only once in G prime.",
            "But for the kernel, it's not a problem."
        ],
        [
            "So first we built initial feature vector representations of G&G Prime.",
            "So these two in 50G comes from the fact that we have twice labeled one.",
            "Then we have once labeled two once labeled three months label for once label 5, and what the same principle we construct the 50G prime."
        ],
        [
            "And then we do exactly the same kind of iterations as invoice for lemon test.",
            "So we determine math is at labels and Satnam.",
            "In our van then we compressed the labels in our family Kane."
        ],
        [
            "And we relabel the graphs."
        ],
        [
            "And at the end of this iteration, we update the feature vector representations of G&G Prime.",
            "So the labels in the components of these vectors in Gray come from the initialization."
        ],
        [
            "And now, as we have labeled sex twice, we have two here.",
            "One here, because it appears twice.",
            "Angie wants in G prime.",
            "And the kind of value after one iteration of the kernel is 11 because it's just a scalar product of five, 1, three and five 1G prime."
        ],
        [
            "So to define me, that's why I kept lemon kernel formally.",
            "It corresponds to the cardinality of these sets of.",
            "Pairs of labels from different graphs.",
            "Passive notes from different graphs that have the same compressed label in any iteration."
        ],
        [
            "So no, if.",
            "If we want to compute computer kernel on an end graphs instead of two, which is usually case if we just.",
            "Compute the N squared match kernel matrix entries separately.",
            "Then this will take over N ^2."
        ],
        [
            "Hmm, but we can speed this up by slightly changing this Step 2 in each iteration.",
            "If we were doing sorting of strings and then compressing them.",
            "Now we hash delete the multiset labels and so we don't have to do this expensive sorting."
        ],
        [
            "And this brings down the complexity to all of NH M + N ^2, H N and this N squared HN comes from the fact that we have to multiply N ^2 per pairs of vectors, pass vectors where we have H an non zero entries at most.",
            "Anne."
        ],
        [
            "In practice, this second."
        ],
        [
            "Time never shows up and this is what is illustrated in this part here.",
            "We generated a number of synthetic graphs.",
            "And here on the X axis we have the number of graphs and non white access runtime both in landscape and we can see that the kernel with hashing has perfectly linear runtime.",
            "We also did some experiments on benchmark."
        ],
        [
            "Graph datasets.",
            "Here, so the 1st three datasets Montag and two NCIS are small, relatively relatively small molecules and Indian tea.",
            "We have proteins where, so the average size of a graph is around 300 miles, but we have some graphs where the number of nodes exceeds 5000."
        ],
        [
            "The comparison partner partners are the kernels that I already mentioned.",
            "Subtree kernel by reminding kattner fast, random or kernel shortest path and three graphlet kernels.",
            "And here are the results.",
            "So the plot above shows runtime in a log scale.",
            "And.",
            "So small is good and the plot below is accuracy of classification with."
        ],
        [
            "And so here large is good.",
            "So as we can see from the plot above, the so sorry the vice by Lemon Colonel is the blue bar on the left side.",
            "As we can see from the plot above, the only kernel that can compete for that in terms of runtime is the three graphic kernel.",
            "But on the other hand when we look at its performance, an inaccuracy, we can see that in all datasets.",
            "My seleman performs better and on NCI.",
            "For example it's much better.",
            "So regarding accuracy, The Rifleman Colonel performs the best or.",
            "3rd best on new tech and it is very scalable."
        ],
        [
            "So to conclude, we define a subtree kernel on graphs that is able to deal with node and edge labels.",
            "And its computation time is linear in the number of graphs in subtree, height, age which is small in practice and in the number of edges in this graph.",
            "As an outlook, it would be interesting."
        ],
        [
            "Thing to consider in exact matching of the subtrees.",
            "For example.",
            "This because sometimes graphs are noisy and."
        ],
        [
            "Therefore it's interesting too.",
            "To match up trees, not exactly, but approximately.",
            "This could be done maybe with by using locality sensitive hashing.",
            "And another algorithmic challenge is when we."
        ],
        [
            "Have graphs with continues or high dimensional node labels."
        ],
        [
            "With this I would like to thank Kurt Mehlhorn, Pascal Schweitzer, an African family one for football discussions and of course thank you for attention."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Thank you for the introduction, so I will present my joint work with Carson Boquette.",
                    "label": 1
                },
                {
                    "sent": "First subtree chromosone graphs.",
                    "label": 0
                },
                {
                    "sent": "First of all, what are kernels?",
                    "label": 0
                },
                {
                    "sent": "Mathematically, kernels are inner products.",
                    "label": 0
                },
                {
                    "sent": "In some future space, and so they are functions of two arguments, excellent X prime.",
                    "label": 0
                },
                {
                    "sent": "An it corresponds to an inner product in a space where X&X prime are mapped.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Via feature map file.",
                    "label": 0
                },
                {
                    "sent": "Sorry.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Should I repeat what I said?",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "So first of all, kernels are functions of two arguments, X an expr.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And they correspond to a future to inner products in some future space where X&X prime are mapped to by mapping file.",
                    "label": 0
                },
                {
                    "sent": "And intuitively, a kernel is a measure of similarity.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Cards can be defined on vectors, but they can also be defined on structured objects like strings, trees or graphs, and our focus in this work is graph kernels.",
                    "label": 0
                },
                {
                    "sent": "So kernels are graphs.",
                    "label": 0
                },
                {
                    "sent": "Well, with kernels one can tackle.",
                    "label": 0
                },
                {
                    "sent": "A number of tasks in machine learning, like classification with SVM's as a famous example, regression feature selection, statistical tests and so on.",
                    "label": 0
                },
                {
                    "sent": "Why it is good to have graph kernels?",
                    "label": 0
                },
                {
                    "sent": "What can we do with that?",
                    "label": 0
                },
                {
                    "sent": "For example, this can be used in graph classification and graphics classification has probably its most typical application in chemoinformatics, where small molecules are represented as graphs.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "So we were given a set of molecules and we know.",
                    "label": 0
                },
                {
                    "sent": "What properties they have or whether they are toxic or non toxic for example, or mutagen?",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The ornament anonymous genetic like here and then when a new molecule arrives, we want to be able to determine which class it belongs to and for that we need a similarity measure on graphs.",
                    "label": 0
                },
                {
                    "sent": "So just to be precise, we're talking about similarity measures on different graphs, not notes in one single.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Graph.",
                    "label": 0
                },
                {
                    "sent": "How to graph kernels usually work usually play count.",
                    "label": 1
                },
                {
                    "sent": "Matchings of subgraphs between two graphs.",
                    "label": 0
                },
                {
                    "sent": "And this sub graphs are usually paths, works psych.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Cause of profits graphics are small fixed size.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Quest.",
                    "label": 0
                },
                {
                    "sent": "Why don't we count all subgraphs and restrict the this to some special classes of subgraphs?",
                    "label": 1
                },
                {
                    "sent": "Or because all subgraphs kernel is at least as hard to compute as graph isomorphism checking, and there is still no polynomial time algorithm known for qualifies a morphism.",
                    "label": 1
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So that's why people consider restricted classes of subgraphs, and if you have a polynomial time computable graph kernel, then you always have two graphs that are not isomorphic, but they are mapped to the same point by by the kernel.",
                    "label": 0
                },
                {
                    "sent": "And but even with this restricted classes of subgraphs, current graph kernels breakdown when graphs have Norton Ledge labels and they are large and by large I mean they have several hundreds or even thousands of nodes.",
                    "label": 1
                },
                {
                    "sent": "And this is what I am trying to illustrate here on this spot so.",
                    "label": 1
                },
                {
                    "sent": "Here I will show the runtime behavior of several graph kernels on toy example.",
                    "label": 1
                },
                {
                    "sent": "So this subtree, Colonel Byron, Man and Gardner is becomes intractable very fast.",
                    "label": 0
                },
                {
                    "sent": "Unfortunately, with the graph size growing fast from random walk kernel is.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "A bit faster, but it also dictionary generates quite quickly.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "They showed us a certain instances of their shortest path, kernel Bible gotten quicker I faster than the random walk kernel.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Counting three graph, let's met, meaning all subgraphs of size 3 in a graph is more efficient, but it is still not very scalable when grass become very large.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And here I'm going to present a graph kernel.",
                    "label": 0
                },
                {
                    "sent": "The computation time of which scales like this.",
                    "label": 0
                },
                {
                    "sent": "So it scales linearly in the number of edges.",
                    "label": 0
                },
                {
                    "sent": "So here I will next I will try to explain how this graph kernel.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "First of all, it is a subtree kernel, and informally what subtree can also is the following.",
                    "label": 0
                },
                {
                    "sent": "They iteratively look at neighborhoods of nodes.",
                    "label": 1
                },
                {
                    "sent": "So consider this graph and the note one.",
                    "label": 0
                },
                {
                    "sent": "In the first situation, there not one will look at its neighbors 2, three and six.",
                    "label": 0
                },
                {
                    "sent": "And the second iteration it will also look at 2, three and six.",
                    "label": 0
                },
                {
                    "sent": "But as to.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Three and six have themselves already looked at their neighbors.",
                    "label": 0
                },
                {
                    "sent": "If we unfold this structure of information flow, we get this tree like structure here.",
                    "label": 1
                },
                {
                    "sent": "That is called subtree or tree.",
                    "label": 1
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Look in the literature.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Our graph criminal counts these kinds of substructures.",
                    "label": 0
                },
                {
                    "sent": "And the algorithm for computing our kernel is inspired by a very efficient.",
                    "label": 0
                },
                {
                    "sent": "Approximation to graph isomorphism checking, called the one dimensional Vice Felimon algorithm from 1968.",
                    "label": 0
                },
                {
                    "sent": "So I will try to explain this algorithm on it on an example.",
                    "label": 0
                },
                {
                    "sent": "Suppose we are given these two graphs, and they're unlabeled, so I gave the notes with same label one, and we want to know whether they are not isomorphic.",
                    "label": 0
                },
                {
                    "sent": "The one dimensional rise Felimon algorithm will ever tell me that they are not isomorphic.",
                    "label": 0
                },
                {
                    "sent": "Or that it doesn't know.",
                    "label": 0
                },
                {
                    "sent": "This is why it is approx.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So the virtual Emma algorithm proceeds in iterations, and each iteration has three key steps.",
                    "label": 1
                },
                {
                    "sent": "First step is multiset label determination and sorting.",
                    "label": 1
                },
                {
                    "sent": "This means that for each node we collect the labels of the neighbors of these nodes.",
                    "label": 1
                },
                {
                    "sent": "We sort this list and concatenate this to the label of the original node.",
                    "label": 0
                },
                {
                    "sent": "So like here, if we look at the top node of the graph on the left.",
                    "label": 0
                },
                {
                    "sent": "It has two neighbors, one and one with labels one at one.",
                    "label": 0
                },
                {
                    "sent": "If we sort one and one, we get one one, and so the resulting multiset label on the figure below is 1.",
                    "label": 0
                },
                {
                    "sent": "Come up on anyone.",
                    "label": 0
                },
                {
                    "sent": "And the other multi set labels are constructed following the same principle.",
                    "label": 0
                },
                {
                    "sent": "This can be done in all of number of edges.",
                    "label": 1
                },
                {
                    "sent": "Outback it sort.",
                    "label": 0
                },
                {
                    "sent": "The second step is label compression.",
                    "label": 0
                },
                {
                    "sent": "That means that we don't want to keep this long multi set labels and we want to compress them with the.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Just one number, so each of them by 1 number and for that what we do is we sort all those multiset labels for each note and then rename the multiset labels by short labels.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And this can also be done in over a number of edges where theoretic sort.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The first step is relabeling of the graph.",
                    "label": 0
                },
                {
                    "sent": "Here we just replace the multiset labels by the compressed labels that we just.",
                    "label": 0
                },
                {
                    "sent": "Just constructed.",
                    "label": 0
                },
                {
                    "sent": "And at the end of each iteration of the one dimensional advice for Element, Algorithm asks whether they label sets of G&G Prime are identical.",
                    "label": 1
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here we have twice to 3 * 2, twice three, an once four in each graph, so they label sets arrive.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Anticop, so we continue and the second iteration we have exactly the same.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Steps, so we determined medicine multiset labels.",
                    "label": 0
                },
                {
                    "sent": "We sought them.",
                    "label": 0
                },
                {
                    "sent": "We compress the label.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Goodbye first.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The sorting this drinks and then associating associating compressed label to each.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And then we label the graph.",
                    "label": 0
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "No other label sets of G&G prime identical.",
                    "label": 1
                },
                {
                    "sent": "They are not identical anymore.",
                    "label": 0
                },
                {
                    "sent": "For example, they note Label 5 appears in the in G prime, but doesn't appear in G, so again.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Graphs are non isomorphic.",
                    "label": 0
                },
                {
                    "sent": "And overall complexity of this algorithm.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Over HM4H iterations.",
                    "label": 0
                },
                {
                    "sent": "Now.",
                    "label": 0
                },
                {
                    "sent": "Here are pointing out the differences between the West filament isomorphism test and the kernel that I'm going to define.",
                    "label": 1
                },
                {
                    "sent": "So at the end of each iteration, the test checks sets of note labels of the graphs whether they are identical or not.",
                    "label": 1
                },
                {
                    "sent": "And it stops when the sets become different or when the number of iteration reaches an because if it reaches and then we know that it won't change anymore.",
                    "label": 1
                },
                {
                    "sent": "And it's computed in our MSA set.",
                    "label": 0
                },
                {
                    "sent": "The Colonel in can't.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Just at the end of each iteration, it's counts matching pairs of labels into graphs.",
                    "label": 1
                },
                {
                    "sent": "And the number of iterations here is is a parameter because we don't care whether.",
                    "label": 1
                },
                {
                    "sent": "Label sets in two graphs are not the same.",
                    "label": 0
                },
                {
                    "sent": "But we are interested interested in the identical labels in two graphs and not least that identity of the sets.",
                    "label": 0
                },
                {
                    "sent": "And this is also computed in all of HM.",
                    "label": 0
                },
                {
                    "sent": "Here I will show on a simple example how they kind of works.",
                    "label": 0
                },
                {
                    "sent": "So suppose we are given this to labeled graphs.",
                    "label": 0
                },
                {
                    "sent": "Anne here justice.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Right now if we run Vice Element S on these two graphs, it won't even begin because the label sets are already different.",
                    "label": 0
                },
                {
                    "sent": "For example, we have labeled one twice in G and only once in G prime.",
                    "label": 0
                },
                {
                    "sent": "But for the kernel, it's not a problem.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So first we built initial feature vector representations of G&G Prime.",
                    "label": 1
                },
                {
                    "sent": "So these two in 50G comes from the fact that we have twice labeled one.",
                    "label": 0
                },
                {
                    "sent": "Then we have once labeled two once labeled three months label for once label 5, and what the same principle we construct the 50G prime.",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And then we do exactly the same kind of iterations as invoice for lemon test.",
                    "label": 0
                },
                {
                    "sent": "So we determine math is at labels and Satnam.",
                    "label": 0
                },
                {
                    "sent": "In our van then we compressed the labels in our family Kane.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And we relabel the graphs.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And at the end of this iteration, we update the feature vector representations of G&G Prime.",
                    "label": 0
                },
                {
                    "sent": "So the labels in the components of these vectors in Gray come from the initialization.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And now, as we have labeled sex twice, we have two here.",
                    "label": 0
                },
                {
                    "sent": "One here, because it appears twice.",
                    "label": 0
                },
                {
                    "sent": "Angie wants in G prime.",
                    "label": 0
                },
                {
                    "sent": "And the kind of value after one iteration of the kernel is 11 because it's just a scalar product of five, 1, three and five 1G prime.",
                    "label": 0
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So to define me, that's why I kept lemon kernel formally.",
                    "label": 0
                },
                {
                    "sent": "It corresponds to the cardinality of these sets of.",
                    "label": 0
                },
                {
                    "sent": "Pairs of labels from different graphs.",
                    "label": 0
                },
                {
                    "sent": "Passive notes from different graphs that have the same compressed label in any iteration.",
                    "label": 0
                }
            ]
        },
        "clip_39": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So no, if.",
                    "label": 0
                },
                {
                    "sent": "If we want to compute computer kernel on an end graphs instead of two, which is usually case if we just.",
                    "label": 0
                },
                {
                    "sent": "Compute the N squared match kernel matrix entries separately.",
                    "label": 0
                },
                {
                    "sent": "Then this will take over N ^2.",
                    "label": 0
                }
            ]
        },
        "clip_40": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Hmm, but we can speed this up by slightly changing this Step 2 in each iteration.",
                    "label": 0
                },
                {
                    "sent": "If we were doing sorting of strings and then compressing them.",
                    "label": 0
                },
                {
                    "sent": "Now we hash delete the multiset labels and so we don't have to do this expensive sorting.",
                    "label": 0
                }
            ]
        },
        "clip_41": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And this brings down the complexity to all of NH M + N ^2, H N and this N squared HN comes from the fact that we have to multiply N ^2 per pairs of vectors, pass vectors where we have H an non zero entries at most.",
                    "label": 0
                },
                {
                    "sent": "Anne.",
                    "label": 0
                }
            ]
        },
        "clip_42": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In practice, this second.",
                    "label": 0
                }
            ]
        },
        "clip_43": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Time never shows up and this is what is illustrated in this part here.",
                    "label": 0
                },
                {
                    "sent": "We generated a number of synthetic graphs.",
                    "label": 1
                },
                {
                    "sent": "And here on the X axis we have the number of graphs and non white access runtime both in landscape and we can see that the kernel with hashing has perfectly linear runtime.",
                    "label": 1
                },
                {
                    "sent": "We also did some experiments on benchmark.",
                    "label": 0
                }
            ]
        },
        "clip_44": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Graph datasets.",
                    "label": 0
                },
                {
                    "sent": "Here, so the 1st three datasets Montag and two NCIS are small, relatively relatively small molecules and Indian tea.",
                    "label": 0
                },
                {
                    "sent": "We have proteins where, so the average size of a graph is around 300 miles, but we have some graphs where the number of nodes exceeds 5000.",
                    "label": 0
                }
            ]
        },
        "clip_45": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The comparison partner partners are the kernels that I already mentioned.",
                    "label": 0
                },
                {
                    "sent": "Subtree kernel by reminding kattner fast, random or kernel shortest path and three graphlet kernels.",
                    "label": 1
                },
                {
                    "sent": "And here are the results.",
                    "label": 0
                },
                {
                    "sent": "So the plot above shows runtime in a log scale.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "So small is good and the plot below is accuracy of classification with.",
                    "label": 0
                }
            ]
        },
        "clip_46": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And so here large is good.",
                    "label": 0
                },
                {
                    "sent": "So as we can see from the plot above, the so sorry the vice by Lemon Colonel is the blue bar on the left side.",
                    "label": 0
                },
                {
                    "sent": "As we can see from the plot above, the only kernel that can compete for that in terms of runtime is the three graphic kernel.",
                    "label": 0
                },
                {
                    "sent": "But on the other hand when we look at its performance, an inaccuracy, we can see that in all datasets.",
                    "label": 0
                },
                {
                    "sent": "My seleman performs better and on NCI.",
                    "label": 0
                },
                {
                    "sent": "For example it's much better.",
                    "label": 0
                },
                {
                    "sent": "So regarding accuracy, The Rifleman Colonel performs the best or.",
                    "label": 0
                },
                {
                    "sent": "3rd best on new tech and it is very scalable.",
                    "label": 0
                }
            ]
        },
        "clip_47": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So to conclude, we define a subtree kernel on graphs that is able to deal with node and edge labels.",
                    "label": 1
                },
                {
                    "sent": "And its computation time is linear in the number of graphs in subtree, height, age which is small in practice and in the number of edges in this graph.",
                    "label": 0
                },
                {
                    "sent": "As an outlook, it would be interesting.",
                    "label": 0
                }
            ]
        },
        "clip_48": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Thing to consider in exact matching of the subtrees.",
                    "label": 1
                },
                {
                    "sent": "For example.",
                    "label": 0
                },
                {
                    "sent": "This because sometimes graphs are noisy and.",
                    "label": 0
                }
            ]
        },
        "clip_49": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Therefore it's interesting too.",
                    "label": 0
                },
                {
                    "sent": "To match up trees, not exactly, but approximately.",
                    "label": 0
                },
                {
                    "sent": "This could be done maybe with by using locality sensitive hashing.",
                    "label": 0
                },
                {
                    "sent": "And another algorithmic challenge is when we.",
                    "label": 0
                }
            ]
        },
        "clip_50": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Have graphs with continues or high dimensional node labels.",
                    "label": 0
                }
            ]
        },
        "clip_51": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "With this I would like to thank Kurt Mehlhorn, Pascal Schweitzer, an African family one for football discussions and of course thank you for attention.",
                    "label": 0
                }
            ]
        }
    }
}