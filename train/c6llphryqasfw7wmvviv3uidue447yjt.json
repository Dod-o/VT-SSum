{
    "id": "c6llphryqasfw7wmvviv3uidue447yjt",
    "title": "Mining Edge-Weighted Call Graphs to Localise Software Bugs",
    "info": {
        "author": [
            "Frank Eichinger, Institute for Program Structures and Data Organization (IPD), University of Karlsruhe"
        ],
        "coauthor": [
            "Klemens B\u00f6hm, Institute for Program Structures and Data Organization (IPD), University of Karlsruhe",
            "Matthias Huber, Institute for Program Structures and Data Organization (IPD), University of Karlsruhe"
        ],
        "published": "Oct. 10, 2008",
        "recorded": "September 2008",
        "category": [
            "Top->Computer Science->Network Analysis",
            "Top->Computer Science->Programming Languages"
        ]
    },
    "url": "http://videolectures.net/ecmlpkdd08_eichinger_mewc/",
    "segmentation": [
        [
            "Yeah, welcome to my talk.",
            "I'm going to explain you how to make use of edge weighted graph mining techniques in order to localize buckson software.",
            "And."
        ],
        [
            "The motivation for this work is pretty much straightforward, as you are probably all aware, software is almost never shipped back free, so there are always some bucks and these backs lead to quite high costs usually and well that also happens if the software was tested extensively before.",
            "So debugging and testing is a time consuming consuming task, and that's expensive as well.",
            "So there are some need for automated automated localization of bucks in order to help software engineers to fix bugs before the software is delivered to the customer so."
        ],
        [
            "So the idea the idea is to locate backs with data mining techniques in order to fix them.",
            "But locating box with data mining is not new, and so that's quite a lot of work has been done in this area.",
            "So what I'm going?"
        ],
        [
            "To talk about today is how to make use of a weighted graph mining approach in order to localize box."
        ],
        [
            "So just very briefly, the outline I'm going to talk first about data mining and software engineering in general before I focus on baited call graph mining and at the end I'm going to present some results and to conclude my talk."
        ],
        [
            "OK, data mining in software engineering.",
            "As you all know, traditional data mining techniques like for example classification, classification with decision trees is working with feature vectors of numerical data and categorical data.",
            "And what can there be in software engineering in software engineering such feature vectors can be vectors of source code matrix and such metrics have been used to build classifiers and to locate box in the past so far."
        ],
        [
            "But in the last year, there's an emerging idea, which is the idea of using graph mining techniques in order to.",
            "Localized box, so more specifically 1 looks at program executions, which can be represented as a call graph and then one can analyze the graph structure.",
            "So usually one is interested in identifying substructures which are typical for failing executions.",
            "So."
        ],
        [
            "The new aspect I'm going to talk about is to take call frequency, which can be displayed as weights in graphs.",
            "To take such core frequencies into account.",
            "Besides the pure graph structure, which has been done in related approaches so far."
        ],
        [
            "OK, just a short review.",
            "What are called graphs?",
            "I was using this word a couple of times already.",
            "Call graph is just that representation, in this case of the program execution.",
            "So one can think of this method a here as a main method which is executed and this main message first calls another method called B.",
            "Then it calls a second method C and within this method see there could be for example a loop and this loop is executing message B again, and in this case it's executed three times in a row.",
            "OK, so the interesting question is now how to how to identify box in such call graphs?",
            "Would like to show you 2."
        ],
        [
            "Examples at first.",
            "There are two kinds of bugs which are relevant.",
            "Structure affecting box and also called frequency affecting bugs.",
            "What is the structure affecting back?",
            "Let me show you a easy example.",
            "For example, if there's a back in a loop in an if condition.",
            "In this method, A and this condition leads to the execution or to the call of method B if there's a back in this condition, it might just happen that message B is not called from method A, so this would just change the structure of this call graph as node B would be missing.",
            "And on the other side."
        ],
        [
            "Their core frequency affecting bugs that are bucks.",
            "Let me start with an example.",
            "If there is this for loop, for example in method C. And there's an Buck in this loop condition.",
            "This could result in the execute that this loop is not executed just three times, but maybe 100 times or just twice or whatever.",
            "So if you look at this graph, if there something wrong, this is loop condition.",
            "It would affect the call frequency of Mississippi.",
            "But it would not affect the whole structure of the graph."
        ],
        [
            "OK, before we can do graph mining, there's a small problem or actually this problem is quite a big problem.",
            "This call graphs are quite large, so here we see very really a very small part of a small program which was executed.",
            "So it's really common that a call graph consists of millions of nodes at millions of method calls, and as you are probably aware, if you use a state of the art graph mining algorithm like for example G span, this algorithm will never be able to scale for the size of such graphs.",
            "So what do we have to do?",
            "We have to reduce these graphs?"
        ],
        [
            "Somehow?",
            "And there have been a couple of approaches in the literature and I'm not going to show you these approaches, but they all have in common that say they lose some information or our approach also loses some information, but we try to keep as much information as possible.",
            "And well, if you look at this example graph, our reduction seems to be pretty easy.",
            "So if you're having a quarter frequency here of three, method B is called 3 times from method C. Then we just merge these nodes B and we introduce these edge weights.",
            "So that looks pretty simple.",
            "It's a little bit more complicated if we come to larger graphs, but.",
            "The main question is.",
            "Why has nobody else used such kind of graph compression before?",
            "So as far as we know, we are the only ones who use these edge weights in call graph analyzers.",
            "The."
        ],
        [
            "So it's a pretty simple.",
            "There's no algorithm available for mining weighted graphs and or the graph mining community has been quite active and as well as we've seen this morning is a graph mining session.",
            "There are many approaches about mining different subclasses of graphs, but there has been very little effort on mining weighted graphs.",
            "However."
        ],
        [
            "We have these call graphs and we we think it's worse to analyze these weights which are encoded in our call graphs and we want to make some use of these weights.",
            "So we would say there in general, as long as there's no real algorithm available, there are two approaches.",
            "One approach would be preprocessing.",
            "One approach would be post processing and preprocessing would deal with the discretization of weights.",
            "Which is possible, but there's again lots of information and.",
            "And our opinions as a post processing approach is.",
            "A lot better or keeps more information and can lead to more detailed results, so I'm going to present a post processing approach which consists of graph mining first, which ignores all the edge weights and then subsequent to this graph mining step it does a detailed analyzes of edge weights."
        ],
        [
            "Let me explain this approach a little bit more detail.",
            "It's a first step.",
            "We apply a frequent subgraph mining algorithm which can be spent for example, or any other algorithm to the reduced call graphs and these call graphs they correspond to failing and correct program executions.",
            "And in this very first step we ignore the.",
            "Rates we just introduced.",
            "As these algorithms are not able to deal with such edge weights.",
            "And in the second step we consider only subgraphs, which occur incorrect in failing executions.",
            "So frequent subgraph mining algorithm gives us a set of frequent subgraphs, and we can decide if every single sub graph is contained in correct program executions or only in failing program executions, or in those.",
            "And at this point we are interested in.",
            "Sub graphs which are occurring in both kind of executions and in these graphs we do and analyzes of the edge weights.",
            "But before I'm going to explain this analyzer, so start with a small example.",
            "So let's assume that this pretty simple Calligra, an sub graph here, was found by a graph mining algorithm.",
            "Then we can look at.",
            "The embeddings where this graph is embedded in the call graph corresponding to the program executions and, for example, the weight of the edge from 8 to see in the correct executions could be one, and the weight of.",
            "Off this edge in the failing executions could be wonderful.",
            "And it's just an example.",
            "For the other edge from C to B, it could happen that in the correct executions of eight would be 3 and is appealing.",
            "Executions could be salty, so we're interested."
        ],
        [
            "We are interested in these weights becausw these states seems to be seems to be interesting because they are just significantly different.",
            "And now it's a question, how can we automatically derive which weights are interesting, which waits discriminative, and which Bates could lead us away to wear a bucket hidden in a call graph?"
        ],
        [
            "We do that by reducing the whole problem to a feature selection problem.",
            "So at the end we are using information gain algorithm which is based on entropy.",
            "And in order to apply such an algorithm, we assemble the table and now would like to explain to you how this kind of table is assembled.",
            "Just assume that we've got 2 results from from the graph mining step.",
            "We've got two subgraph, subgraph one and sub graph 2, two pretty small examples.",
            "And now we want to assemble the table and in this table we have in the rules we have the different executions of a certain program and every of this execution is labeled with a class failing or correct this is.",
            "Execution produced correct or wrong result.",
            "And now into columns we we just try to bait which weights from this original executions.",
            "So for example.",
            "In execution one the subgraphs one is embedded.",
            "And the edge in sub graph one from A to C in the first execution has to wait one the edge from node or method C to be in the first sub graph.",
            "Here surveyed 30 and the edge from A to B in the second sub graph which is also embedded in execution one as of eight 6.",
            "And so on.",
            "We are just assembling this table and we can apply a feature selection algorithm to the stable and in this way we gain a ranking of these columns.",
            "And was this ranking is ranking which says which.",
            "Which column is most discriminative and most discriminative means in this context?",
            "It's discriminating whether between failing and correct, so we can do the assumptions assumptions that if it's discriminating between failing and correct, there must be a bug hidden somewhere.",
            "Edge."
        ],
        [
            "OK, just again in this diagram, if you see the red boxes so far describes the left side of this diagram, we started with reduced call graphs that needed frequent subgraph mining, not considering the weights.",
            "And afterwards we looked at subgraphs which are occurring in failing and correct executions, and then we applied this entropy based scoring using the feature selection algorithm.",
            "So that's one part of the whole of the whole framework.",
            "Cause so far I've been just we've just been analyzing the edge weights which are called frequencies, but at the very beginning of my talk I was talking about called frequency affecting box and structure affecting bugs and structure affecting box as well."
        ],
        [
            "And that's what we do on the right side of this diagram.",
            "And in order to find structure affecting bugs.",
            "We just consider Colgrass, which only occur in failing executions.",
            "Excuse me, we are considering sub graph which.",
            "Occurring in failing executions and in these subgraphs, the basic idea is, well, methods which are inside for such subgraphs.",
            "They are having a higher probability of containing it back, so we derive a second score.",
            "The second likelihood of containing a bug, and at the end."
        ],
        [
            "Merging these two these two scores to overall back to an overall score which is able to detect both called frequency and structure affecting bugs.",
            "And just again to remind you what we're doing on the left side of this diagram, we're looking at frequency, which leads to the detection of core frequency affecting box and on the right side we are looking at structure of differences in structures, incorrect and failing executions and.",
            "That leads to the discovery of structure affecting bugs.",
            "So at the end we come up with some kind of."
        ],
        [
            "Thinking of methods and.",
            "That looks like this table for example.",
            "And this table contains a number of methods and it contains a score assigned to every method and.",
            "Well, we would give such such a table to a software engineer to a software developer and software developer would start with the first method.",
            "You will see.",
            "Well, it's quite a high score, quite a high likelihood that this message contains a bug, so we will do code review of this method.",
            "Then you would probably not find something he would go on."
        ],
        [
            "So the second method, and in this example I instrumented the back in the second method, so after vacuum two methods, software developer who found the bug."
        ],
        [
            "OK, we did some experiments and in our setting we used an open source Java tool and.",
            "We instrumented 14 different box, so at the end we had 14 different version of the same piece of software and these bugs we instrumented well that have been artificial bugs, but these artificial bugs we tried to mimic them as closely as possible to realistic packs, and we've used exactly the same types of bugs as they were used in related publications in software engineering.",
            "So at the end we applied our message to these 14 buggy versions and the result is, well that we are having a new possibility to detect these core frequency affecting batch box which has not been possible with previous approaches or well.",
            "And as well, we our experiments show a double precision of back localizations of those types of bugs called frequency affecting box and structure affecting box as well."
        ],
        [
            "So let me conclude my talk.",
            "With a short summary of contributions at first.",
            "We developed a call graph reduction technique.",
            "I didn't show all the details to you on these slides, but you can find them in the paper and then we developed an approach for knowledge discovery invaded classified graphs.",
            "And this approach consists of this pre process as post processing technique where we apply in numerical technique feature selection subsequent to a structural approach which is graph mining.",
            "Enter important finding of this investigation and our experiments is that the combined analyzes of numerical and structural evidence.",
            "So of these call frequencies and structural differences in call graphs was key for precise results.",
            "Just very briefly on our current and future work.",
            "We are working on faith based constraints in order to analyze edge weights, viewing the graph mining process.",
            "We are also mining on working on mining large graphs and especially large software projects, but at the end software engineering is not our only future applications, so we're trying to apply this and related approaches in completely different fields like transportation, logistics as well."
        ],
        [
            "OK, thank you for your attention."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Yeah, welcome to my talk.",
                    "label": 0
                },
                {
                    "sent": "I'm going to explain you how to make use of edge weighted graph mining techniques in order to localize buckson software.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The motivation for this work is pretty much straightforward, as you are probably all aware, software is almost never shipped back free, so there are always some bucks and these backs lead to quite high costs usually and well that also happens if the software was tested extensively before.",
                    "label": 1
                },
                {
                    "sent": "So debugging and testing is a time consuming consuming task, and that's expensive as well.",
                    "label": 0
                },
                {
                    "sent": "So there are some need for automated automated localization of bucks in order to help software engineers to fix bugs before the software is delivered to the customer so.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So the idea the idea is to locate backs with data mining techniques in order to fix them.",
                    "label": 1
                },
                {
                    "sent": "But locating box with data mining is not new, and so that's quite a lot of work has been done in this area.",
                    "label": 0
                },
                {
                    "sent": "So what I'm going?",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "To talk about today is how to make use of a weighted graph mining approach in order to localize box.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So just very briefly, the outline I'm going to talk first about data mining and software engineering in general before I focus on baited call graph mining and at the end I'm going to present some results and to conclude my talk.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, data mining in software engineering.",
                    "label": 1
                },
                {
                    "sent": "As you all know, traditional data mining techniques like for example classification, classification with decision trees is working with feature vectors of numerical data and categorical data.",
                    "label": 0
                },
                {
                    "sent": "And what can there be in software engineering in software engineering such feature vectors can be vectors of source code matrix and such metrics have been used to build classifiers and to locate box in the past so far.",
                    "label": 1
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But in the last year, there's an emerging idea, which is the idea of using graph mining techniques in order to.",
                    "label": 1
                },
                {
                    "sent": "Localized box, so more specifically 1 looks at program executions, which can be represented as a call graph and then one can analyze the graph structure.",
                    "label": 1
                },
                {
                    "sent": "So usually one is interested in identifying substructures which are typical for failing executions.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The new aspect I'm going to talk about is to take call frequency, which can be displayed as weights in graphs.",
                    "label": 0
                },
                {
                    "sent": "To take such core frequencies into account.",
                    "label": 0
                },
                {
                    "sent": "Besides the pure graph structure, which has been done in related approaches so far.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, just a short review.",
                    "label": 0
                },
                {
                    "sent": "What are called graphs?",
                    "label": 0
                },
                {
                    "sent": "I was using this word a couple of times already.",
                    "label": 0
                },
                {
                    "sent": "Call graph is just that representation, in this case of the program execution.",
                    "label": 0
                },
                {
                    "sent": "So one can think of this method a here as a main method which is executed and this main message first calls another method called B.",
                    "label": 0
                },
                {
                    "sent": "Then it calls a second method C and within this method see there could be for example a loop and this loop is executing message B again, and in this case it's executed three times in a row.",
                    "label": 0
                },
                {
                    "sent": "OK, so the interesting question is now how to how to identify box in such call graphs?",
                    "label": 0
                },
                {
                    "sent": "Would like to show you 2.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Examples at first.",
                    "label": 0
                },
                {
                    "sent": "There are two kinds of bugs which are relevant.",
                    "label": 0
                },
                {
                    "sent": "Structure affecting box and also called frequency affecting bugs.",
                    "label": 0
                },
                {
                    "sent": "What is the structure affecting back?",
                    "label": 1
                },
                {
                    "sent": "Let me show you a easy example.",
                    "label": 0
                },
                {
                    "sent": "For example, if there's a back in a loop in an if condition.",
                    "label": 1
                },
                {
                    "sent": "In this method, A and this condition leads to the execution or to the call of method B if there's a back in this condition, it might just happen that message B is not called from method A, so this would just change the structure of this call graph as node B would be missing.",
                    "label": 0
                },
                {
                    "sent": "And on the other side.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Their core frequency affecting bugs that are bucks.",
                    "label": 1
                },
                {
                    "sent": "Let me start with an example.",
                    "label": 0
                },
                {
                    "sent": "If there is this for loop, for example in method C. And there's an Buck in this loop condition.",
                    "label": 1
                },
                {
                    "sent": "This could result in the execute that this loop is not executed just three times, but maybe 100 times or just twice or whatever.",
                    "label": 0
                },
                {
                    "sent": "So if you look at this graph, if there something wrong, this is loop condition.",
                    "label": 0
                },
                {
                    "sent": "It would affect the call frequency of Mississippi.",
                    "label": 1
                },
                {
                    "sent": "But it would not affect the whole structure of the graph.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, before we can do graph mining, there's a small problem or actually this problem is quite a big problem.",
                    "label": 0
                },
                {
                    "sent": "This call graphs are quite large, so here we see very really a very small part of a small program which was executed.",
                    "label": 0
                },
                {
                    "sent": "So it's really common that a call graph consists of millions of nodes at millions of method calls, and as you are probably aware, if you use a state of the art graph mining algorithm like for example G span, this algorithm will never be able to scale for the size of such graphs.",
                    "label": 1
                },
                {
                    "sent": "So what do we have to do?",
                    "label": 0
                },
                {
                    "sent": "We have to reduce these graphs?",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Somehow?",
                    "label": 0
                },
                {
                    "sent": "And there have been a couple of approaches in the literature and I'm not going to show you these approaches, but they all have in common that say they lose some information or our approach also loses some information, but we try to keep as much information as possible.",
                    "label": 0
                },
                {
                    "sent": "And well, if you look at this example graph, our reduction seems to be pretty easy.",
                    "label": 0
                },
                {
                    "sent": "So if you're having a quarter frequency here of three, method B is called 3 times from method C. Then we just merge these nodes B and we introduce these edge weights.",
                    "label": 0
                },
                {
                    "sent": "So that looks pretty simple.",
                    "label": 0
                },
                {
                    "sent": "It's a little bit more complicated if we come to larger graphs, but.",
                    "label": 0
                },
                {
                    "sent": "The main question is.",
                    "label": 0
                },
                {
                    "sent": "Why has nobody else used such kind of graph compression before?",
                    "label": 0
                },
                {
                    "sent": "So as far as we know, we are the only ones who use these edge weights in call graph analyzers.",
                    "label": 0
                },
                {
                    "sent": "The.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So it's a pretty simple.",
                    "label": 0
                },
                {
                    "sent": "There's no algorithm available for mining weighted graphs and or the graph mining community has been quite active and as well as we've seen this morning is a graph mining session.",
                    "label": 1
                },
                {
                    "sent": "There are many approaches about mining different subclasses of graphs, but there has been very little effort on mining weighted graphs.",
                    "label": 0
                },
                {
                    "sent": "However.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We have these call graphs and we we think it's worse to analyze these weights which are encoded in our call graphs and we want to make some use of these weights.",
                    "label": 1
                },
                {
                    "sent": "So we would say there in general, as long as there's no real algorithm available, there are two approaches.",
                    "label": 0
                },
                {
                    "sent": "One approach would be preprocessing.",
                    "label": 1
                },
                {
                    "sent": "One approach would be post processing and preprocessing would deal with the discretization of weights.",
                    "label": 0
                },
                {
                    "sent": "Which is possible, but there's again lots of information and.",
                    "label": 0
                },
                {
                    "sent": "And our opinions as a post processing approach is.",
                    "label": 0
                },
                {
                    "sent": "A lot better or keeps more information and can lead to more detailed results, so I'm going to present a post processing approach which consists of graph mining first, which ignores all the edge weights and then subsequent to this graph mining step it does a detailed analyzes of edge weights.",
                    "label": 1
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Let me explain this approach a little bit more detail.",
                    "label": 0
                },
                {
                    "sent": "It's a first step.",
                    "label": 0
                },
                {
                    "sent": "We apply a frequent subgraph mining algorithm which can be spent for example, or any other algorithm to the reduced call graphs and these call graphs they correspond to failing and correct program executions.",
                    "label": 1
                },
                {
                    "sent": "And in this very first step we ignore the.",
                    "label": 0
                },
                {
                    "sent": "Rates we just introduced.",
                    "label": 0
                },
                {
                    "sent": "As these algorithms are not able to deal with such edge weights.",
                    "label": 1
                },
                {
                    "sent": "And in the second step we consider only subgraphs, which occur incorrect in failing executions.",
                    "label": 1
                },
                {
                    "sent": "So frequent subgraph mining algorithm gives us a set of frequent subgraphs, and we can decide if every single sub graph is contained in correct program executions or only in failing program executions, or in those.",
                    "label": 1
                },
                {
                    "sent": "And at this point we are interested in.",
                    "label": 1
                },
                {
                    "sent": "Sub graphs which are occurring in both kind of executions and in these graphs we do and analyzes of the edge weights.",
                    "label": 0
                },
                {
                    "sent": "But before I'm going to explain this analyzer, so start with a small example.",
                    "label": 0
                },
                {
                    "sent": "So let's assume that this pretty simple Calligra, an sub graph here, was found by a graph mining algorithm.",
                    "label": 0
                },
                {
                    "sent": "Then we can look at.",
                    "label": 0
                },
                {
                    "sent": "The embeddings where this graph is embedded in the call graph corresponding to the program executions and, for example, the weight of the edge from 8 to see in the correct executions could be one, and the weight of.",
                    "label": 0
                },
                {
                    "sent": "Off this edge in the failing executions could be wonderful.",
                    "label": 0
                },
                {
                    "sent": "And it's just an example.",
                    "label": 0
                },
                {
                    "sent": "For the other edge from C to B, it could happen that in the correct executions of eight would be 3 and is appealing.",
                    "label": 0
                },
                {
                    "sent": "Executions could be salty, so we're interested.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We are interested in these weights becausw these states seems to be seems to be interesting because they are just significantly different.",
                    "label": 0
                },
                {
                    "sent": "And now it's a question, how can we automatically derive which weights are interesting, which waits discriminative, and which Bates could lead us away to wear a bucket hidden in a call graph?",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We do that by reducing the whole problem to a feature selection problem.",
                    "label": 0
                },
                {
                    "sent": "So at the end we are using information gain algorithm which is based on entropy.",
                    "label": 1
                },
                {
                    "sent": "And in order to apply such an algorithm, we assemble the table and now would like to explain to you how this kind of table is assembled.",
                    "label": 1
                },
                {
                    "sent": "Just assume that we've got 2 results from from the graph mining step.",
                    "label": 0
                },
                {
                    "sent": "We've got two subgraph, subgraph one and sub graph 2, two pretty small examples.",
                    "label": 0
                },
                {
                    "sent": "And now we want to assemble the table and in this table we have in the rules we have the different executions of a certain program and every of this execution is labeled with a class failing or correct this is.",
                    "label": 0
                },
                {
                    "sent": "Execution produced correct or wrong result.",
                    "label": 0
                },
                {
                    "sent": "And now into columns we we just try to bait which weights from this original executions.",
                    "label": 0
                },
                {
                    "sent": "So for example.",
                    "label": 0
                },
                {
                    "sent": "In execution one the subgraphs one is embedded.",
                    "label": 0
                },
                {
                    "sent": "And the edge in sub graph one from A to C in the first execution has to wait one the edge from node or method C to be in the first sub graph.",
                    "label": 0
                },
                {
                    "sent": "Here surveyed 30 and the edge from A to B in the second sub graph which is also embedded in execution one as of eight 6.",
                    "label": 0
                },
                {
                    "sent": "And so on.",
                    "label": 1
                },
                {
                    "sent": "We are just assembling this table and we can apply a feature selection algorithm to the stable and in this way we gain a ranking of these columns.",
                    "label": 0
                },
                {
                    "sent": "And was this ranking is ranking which says which.",
                    "label": 0
                },
                {
                    "sent": "Which column is most discriminative and most discriminative means in this context?",
                    "label": 0
                },
                {
                    "sent": "It's discriminating whether between failing and correct, so we can do the assumptions assumptions that if it's discriminating between failing and correct, there must be a bug hidden somewhere.",
                    "label": 0
                },
                {
                    "sent": "Edge.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, just again in this diagram, if you see the red boxes so far describes the left side of this diagram, we started with reduced call graphs that needed frequent subgraph mining, not considering the weights.",
                    "label": 1
                },
                {
                    "sent": "And afterwards we looked at subgraphs which are occurring in failing and correct executions, and then we applied this entropy based scoring using the feature selection algorithm.",
                    "label": 0
                },
                {
                    "sent": "So that's one part of the whole of the whole framework.",
                    "label": 0
                },
                {
                    "sent": "Cause so far I've been just we've just been analyzing the edge weights which are called frequencies, but at the very beginning of my talk I was talking about called frequency affecting box and structure affecting bugs and structure affecting box as well.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And that's what we do on the right side of this diagram.",
                    "label": 0
                },
                {
                    "sent": "And in order to find structure affecting bugs.",
                    "label": 0
                },
                {
                    "sent": "We just consider Colgrass, which only occur in failing executions.",
                    "label": 0
                },
                {
                    "sent": "Excuse me, we are considering sub graph which.",
                    "label": 0
                },
                {
                    "sent": "Occurring in failing executions and in these subgraphs, the basic idea is, well, methods which are inside for such subgraphs.",
                    "label": 0
                },
                {
                    "sent": "They are having a higher probability of containing it back, so we derive a second score.",
                    "label": 0
                },
                {
                    "sent": "The second likelihood of containing a bug, and at the end.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Merging these two these two scores to overall back to an overall score which is able to detect both called frequency and structure affecting bugs.",
                    "label": 1
                },
                {
                    "sent": "And just again to remind you what we're doing on the left side of this diagram, we're looking at frequency, which leads to the detection of core frequency affecting box and on the right side we are looking at structure of differences in structures, incorrect and failing executions and.",
                    "label": 0
                },
                {
                    "sent": "That leads to the discovery of structure affecting bugs.",
                    "label": 0
                },
                {
                    "sent": "So at the end we come up with some kind of.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Thinking of methods and.",
                    "label": 0
                },
                {
                    "sent": "That looks like this table for example.",
                    "label": 0
                },
                {
                    "sent": "And this table contains a number of methods and it contains a score assigned to every method and.",
                    "label": 0
                },
                {
                    "sent": "Well, we would give such such a table to a software engineer to a software developer and software developer would start with the first method.",
                    "label": 0
                },
                {
                    "sent": "You will see.",
                    "label": 0
                },
                {
                    "sent": "Well, it's quite a high score, quite a high likelihood that this message contains a bug, so we will do code review of this method.",
                    "label": 0
                },
                {
                    "sent": "Then you would probably not find something he would go on.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the second method, and in this example I instrumented the back in the second method, so after vacuum two methods, software developer who found the bug.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, we did some experiments and in our setting we used an open source Java tool and.",
                    "label": 1
                },
                {
                    "sent": "We instrumented 14 different box, so at the end we had 14 different version of the same piece of software and these bugs we instrumented well that have been artificial bugs, but these artificial bugs we tried to mimic them as closely as possible to realistic packs, and we've used exactly the same types of bugs as they were used in related publications in software engineering.",
                    "label": 1
                },
                {
                    "sent": "So at the end we applied our message to these 14 buggy versions and the result is, well that we are having a new possibility to detect these core frequency affecting batch box which has not been possible with previous approaches or well.",
                    "label": 0
                },
                {
                    "sent": "And as well, we our experiments show a double precision of back localizations of those types of bugs called frequency affecting box and structure affecting box as well.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So let me conclude my talk.",
                    "label": 0
                },
                {
                    "sent": "With a short summary of contributions at first.",
                    "label": 1
                },
                {
                    "sent": "We developed a call graph reduction technique.",
                    "label": 1
                },
                {
                    "sent": "I didn't show all the details to you on these slides, but you can find them in the paper and then we developed an approach for knowledge discovery invaded classified graphs.",
                    "label": 0
                },
                {
                    "sent": "And this approach consists of this pre process as post processing technique where we apply in numerical technique feature selection subsequent to a structural approach which is graph mining.",
                    "label": 1
                },
                {
                    "sent": "Enter important finding of this investigation and our experiments is that the combined analyzes of numerical and structural evidence.",
                    "label": 1
                },
                {
                    "sent": "So of these call frequencies and structural differences in call graphs was key for precise results.",
                    "label": 1
                },
                {
                    "sent": "Just very briefly on our current and future work.",
                    "label": 0
                },
                {
                    "sent": "We are working on faith based constraints in order to analyze edge weights, viewing the graph mining process.",
                    "label": 0
                },
                {
                    "sent": "We are also mining on working on mining large graphs and especially large software projects, but at the end software engineering is not our only future applications, so we're trying to apply this and related approaches in completely different fields like transportation, logistics as well.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, thank you for your attention.",
                    "label": 0
                }
            ]
        }
    }
}