{
    "id": "wepxcuu56jlpqy3kecxevsarayvprsze",
    "title": "Computing All-Pairs Shortest Paths by Leveraging Low Treewidth",
    "info": {
        "author": [
            "L\u00e9on Planken, Faculty of Electrical Engineering, Mathematics and Computer Science, Delft University of Technology (TU Delft)"
        ],
        "published": "July 21, 2011",
        "recorded": "June 2011",
        "category": [
            "Top->Computer Science->Artificial Intelligence->Planning and Scheduling"
        ]
    },
    "url": "http://videolectures.net/icaps2011_planken_computing/",
    "segmentation": [
        [
            "So let's look at this title and let's put this in two parts because that is what I'm going to do."
        ],
        [
            "In this short talk 1st, I'm going to talk about computing all pair shortest parts.",
            "Going to tell you briefly reiterate what it actually means, then give a motivation for why it's interesting to you and look at existing algorithms for this problem, and when I've done that, will look at how we can leverage low tree width to calculate this so."
        ],
        [
            "Consider a graph with N vertices and edges, so in."
        ],
        [
            "This case we have 8 vertices and we have some edges between them and this graph is directed as you can see and these edges."
        ],
        [
            "Or actually waited so their each edge has a weight."
        ],
        [
            "And we are interested in calculating a shortest path from A to H. Well, actually I am and I'm going to tell you why you should be.",
            "So here this is the shortest path from A to H, But actually we're not just interested in one pair of source destination, we."
        ],
        [
            "To calculate all pair shortest path so the result of that would be a matrix with N by N. So in this case 64 values for the shortest paths in this graph."
        ],
        [
            "Now, why is this interesting to you?",
            "Of course we can use shortest paths results to reason about space.",
            "Things like Maps and so on.",
            "But we can also use it for temporal reasoning in simple temporal networks, which many of you will have."
        ],
        [
            "About but which I'm going to briefly introduce.",
            "They were proposed in 1991 by Dexter Myrie in Peru and they can be used to represent and reason about temporal information, and in this network each node represents an event, and each arc represents a temporal constraint between a pair of events."
        ],
        [
            "So for example, here we have two events A&B and between them we say that between 10:10 and 40 time units are allowed to pass, so this could be minutes, seconds, whatever.",
            "Now if we have."
        ],
        [
            "Extra events C&D.",
            "Then we can actually see that this constraint, which has been stated between A&B can be tightened because if we look at events in event path from A through C2B and we see that the upper bound on the path from A to B."
        ],
        [
            "Is only 30 minutes, and likewise if we look at the path from a through D."
        ],
        [
            "Maybe we should lower bound."
        ],
        [
            "Is actually 20 minutes and we can."
        ],
        [
            "Find this information by considering a distance graph where instead of these intervals we have directed edges just like the example I showed at the beginning."
        ],
        [
            "So, and where can this be applied?",
            "If you want to solve a job shop problem, one way to go about it is to represent such a schedule as a simple temporal network, and then you can find out whether the schedule schedule is consistent or not, and you can infer new information from the schedule.",
            "It is also used in temporal planning, and it has been applied in space missions such as in NASA's Mars Rover, and easy as much express."
        ],
        [
            "Now existing algorithms for all pair shortest parts are the Floyd Warshall algorithm, which is from a long time ago that runs in cubic time and Dexter and the RSD.",
            "They actually proposed this to be able to reason about the simple temporal network.",
            "It's very simple to implement with, which is also."
        ],
        [
            "There's another algorithm, Johnson's algorithm, and this benefits from.",
            "If the graph is sparse, so if it is comparatively few edges, it's a little bit harder to implement, and it makes use affinity to attain this N squared log in time bound."
        ],
        [
            "There are some other algorithm which algorithms which you can apply to the STN.",
            "For example the Bellman Ford algorithm which calculates single source shortest paths which runs in N * M time.",
            "It can be used to find out where the network is consistent or not.",
            "So if it is inconsistent then there is a negative cycle in this network.",
            "It can also be used to find just a single schedule for events and it can be used to infer constraints involving just a single time."
        ],
        [
            "And another approach is our own P3C algorithm from three years ago, which also benefits from, well actually from low tree with, which is where I'm moving on to this subject in a moment.",
            "What we do here is we calculate shortest paths for multiple pairs, but not for all pairs.",
            "So for an interesting subset of these or all these pairs for those and just a couple of others, we calculate the inferred constraints and for this specific problem it is currently the state of the art."
        ],
        [
            "Now let's talk about how to leverage this low tree width of of a graph.",
            "First, we're going to look at directed pass consistency.",
            "Then Snowball is our new algorithm, and we're going to tell you how that works.",
            "I'll tell you about the empirical evaluation of our method."
        ],
        [
            "So director position.",
            "He was also proposed by Dexter to use from the STP to determine whether or not consistent and this approach actually known from constraint satisfaction literature.",
            "So, given what you need is an ordering of your vertices, and given this ordering, it runs in end times the induced width of this ordering squared time.",
            "And what exactly this means.",
            "I will show you in the next slide, and this is actually a prerequisite to the P3C algorithm.",
            "Talked about just now.",
            "It's also a prerequisite to our snowball algorithm, which I'll talk about in a moment."
        ],
        [
            "So this is the director position.",
            "See algorithm, which is actually there's all the pseudocode there is, so it's actually pretty simple."
        ],
        [
            "What we do is we iterate downwards over along this ordering D we trade downwards overall."
        ],
        [
            "Vertices and then we look at all pairs of neighbors of each vertex in this direction and."
        ],
        [
            "All these pairs of neighbors we try to see if there is a shorter path going through this current vertex K from one neighbor to the other, and if there is any updates, the weights in this graph.",
            "There is some inconsistency in the network, so if there is some negative cycle in our graph then this is also the point where we will find out."
        ],
        [
            "Another point what happens is that the set of edges of your graph may actually in many cases go grow bigger.",
            "And what we would like is to have this as little as possible.",
            "I'll move on to the moment."
        ],
        [
            "Here's an example of how it would work, more or less.",
            "I've taken out the the weights of the edges to reduce clutter."
        ],
        [
            "So let's assume that we have an ordering in this graph from left to right, so or alphabetically from A to H."
        ],
        [
            "Our current vertex vertex A and we look at all neighbors of vertex A and now for all pairs of these neighbors we calculate the shortest path."
        ],
        [
            "Through Vertex a.",
            "And as you see, these red edges have actually been added, so this is a lot of extra edge edges in this small graph.",
            "They also contain the shortest path, for example from B2D through Vertex a so up there.",
            "Two down there via."
        ],
        [
            "Protects a witch."
        ],
        [
            "Here.",
            "And blue edges have also been updated.",
            "If this is possible."
        ],
        [
            "Let's move on next Vertex first B."
        ],
        [
            "And again we look at this neighbors."
        ],
        [
            "All pairs of it, and we update the edge."
        ],
        [
            "It's between them."
        ],
        [
            "And so on.",
            "Here's one extra edge that."
        ],
        [
            "I've been at it."
        ],
        [
            "Can we move on until?"
        ],
        [
            "Until we are done, we have just two left.",
            "So actually what we now have between vertis G&H is guaranteed to be the shortest path between these two.",
            "So that's one side effect of the direct path necessary algorithm that already have one pair of shorts, parts of."
        ],
        [
            "All of them, right?",
            "That's the first point.",
            "In this slide, the last two vertices, the edge between them is labeled by the minimum weight.",
            "In this example I just showed you the induced with is 5.",
            "I didn't really tell you, but what it is.",
            "Is the number.",
            "Let's move back."
        ],
        [
            "Induced with this five.",
            "Because this is the largest number of neighbors that downstream neighbors, I should say that one vertex going to show for it."
        ],
        [
            "Well here we have 5 neighbors."
        ],
        [
            "Actually this one is 4."
        ],
        [
            "But"
        ],
        [
            "SC also has."
        ],
        [
            "04"
        ],
        [
            "Or right, so the rest is for the first time."
        ],
        [
            "5."
        ],
        [
            "And the number."
        ],
        [
            "Fill edges in the."
        ],
        [
            "In this case is 9.",
            "This is a bit high.",
            "We would try to, because this is all overhead for the use of our algorithm, so we would like to try and minimize this, and one way to go about this.",
            "It's a very simple heuristic which is called the minimum degree you are."
        ],
        [
            "So we have to graph again, but instead of going from left to right, we at each point we take the vertex which has the fewest number of neighbors, so."
        ],
        [
            "Example or three of Oh yes, one extra thing I should tell you what I'm going to look at in this example is assumed there is a short spot from G2H or the other way around, which runs all the way through through the graph.",
            "Then you can see how this shortest passes updated as the algorithm moves on."
        ],
        [
            "So there are three features of weight of with two neighbors, so at first we consider all three of these."
        ],
        [
            "And we update the edges between the man at the new one is if possible.",
            "So now actually there is a shortest path in this graph which skips over vertex B, which was up there and that goes directly from A to F. And there is one at."
        ],
        [
            "That edge, so we move on and we see now that the shortest path from."
        ],
        [
            "Will run from."
        ],
        [
            "G2F"
        ],
        [
            "And so on.",
            "And in the end."
        ],
        [
            "Again, we are assured that the edge between G&H is labeled by the shortest weight."
        ],
        [
            "And now in this example we saw that the induced with only three and we have added only two field edges.",
            "And what we offer also seems to the shortest path between two vertices can always be found by looking down only at lower neighbor lower number of neighbors and we use this in our snowball."
        ],
        [
            "Algorithm.",
            "Right like P3C.",
            "This algorithm builds upon the results.",
            "From the PC.",
            "It runs in the end times.",
            "MC I should tell you what MC is of course, and was just a number of edges originally in the graph, and MC is the number of edges and it's called the core graph which is triangulated, which is the number of original edges plus the red ones I showed you.",
            "So the total number of edges after running VPC, and actually this is a subset of N squared times the induced with and the idea behind our algorithm is that after DC as I told you.",
            "Wait between the last two vertices in.",
            "Our ordering is already minimal and the shortest path to from any two or from any vertex runs only through lower number of vertices in the ordering."
        ],
        [
            "So here's the pseudocode.",
            "First, Noble algorithm.",
            "At first we run the PC and then we go back up again.",
            "If you remember, the PC ran from end to end and this one runs from one from 12:50 and this one runs from 1:00 to N. At first"
        ],
        [
            "We initialize our distance matrix by setting all values to zero except the ones on the diagonal from one vertex to itself.",
            "30 and then we iterate."
        ],
        [
            "Over this ordering.",
            "Then what we do is again we look only at lower number at edges."
        ],
        [
            "But then for every other edge which is also lower, no number we can actually update this values in the distance matrix and we know that after each iteration of the outer loop, we're sure we prove this in a paper now briefly.",
            "I go explain more or less in the next slide how it works.",
            "After this, each iteration of the outer loop, we are sure that values in the distance matrix involving vertex.",
            "OK, are set correctly."
        ],
        [
            "So we after PC this is where we were.",
            "We have to get two vertices left and we know that the shortest path between them as being calculated.",
            "There's really hand WAVY by the way, so I moved back up the next."
        ],
        [
            "Is F."
        ],
        [
            "And I know that the two.",
            "Just from F2, the lower number for dishes are also.",
            "Any path that would go through here is actually incorporated in these two edges.",
            "So we can update the distance matrix for values for.",
            "For node F."
        ],
        [
            "The next one is D."
        ],
        [
            "Again, we only need to look at a downwards pointing edges."
        ],
        [
            "And so on."
        ],
        [
            "This is really handwaving.",
            "Actual proof is in the in our paper."
        ],
        [
            "Now there are some special cases of graphs where we can actually tighten our theoretical bound that I just told you about.",
            "If there is some ordering of vertices for which there is a constant induced with, then we can find this in linear time linear in the number of vertices.",
            "But actually this WD which is a constant is somewhere in an exponent of this of this.",
            "So it's only where file is WD is really small, but in this case WD is constant.",
            "Then the snowball algorithm runs in.",
            "Squared Time, which is optimal because the output of the algorithm is also N ^2.",
            "If the graph is already chordal, so if there is some ordering for DPC in which we didn't have to add any edges.",
            "If such an ordering exists, we can actually find this in linear time, and this is a much nicer formula because it's just.",
            "There's no hidden exponents anywhere.",
            "If this is the case, then it actually runs in end times M time, which is a nice bound.",
            "Because it's, for example, the same as the Bellman Ford algorithm, which only calculates single source water."
        ],
        [
            "Parts.",
            "Now the name Snowball.",
            "Where does it derive from?",
            "Actually, the number of computers shortest paths in a graph.",
            "Gross gross."
        ],
        [
            "Quadratically bit."
        ],
        [
            "Like this poor man."
        ],
        [
            "Animation, so it's a bit like a snowball running downhill, growing bigger all the time and actually at the moment that the bikers deadline was there was snow.",
            "Also in our in Delft.",
            "So that's why it was on my mind."
        ],
        [
            "Now we empirically evaluated or algorithms.",
            "Also, we compared Floyd Warshall and Johnson's algorithm against our own algorithm.",
            "We implemented all these algorithms in Java and we ran each benchmark 10 times."
        ],
        [
            "Took the average.",
            "Here is an overview of all the benchmarks we have so you can see that there are some instances where we let the number of.",
            "First, he should grow quite quite high and also the number of edges in some of these graphs are rather large.",
            "And what we also did is we in some of the benchmarks we varied the size of the graph, the number of vertices instead of some others.",
            "We kept the number of vertices constant and we varied the density of the graph the tree with.",
            "I."
        ],
        [
            "Actually, only going to show you a couple of them, these when I'll leave out for now, but they're in our page."
        ],
        [
            "So for scale free graph scale free graph, let me briefly introduce a graph in which there are just a couple of nodes which have a very large number of neighbors and there are many nodes which only have a few.",
            "These follow a power law.",
            "The distribution of degree over over vertices.",
            "Now what we see here.",
            "What we actually in our R plots the time on the vertical axis is in the log scale and in the milliseconds.",
            "So what we see here, we kept the induced with more or less constant while we induced increase the number of vertices and at the beginning where the.",
            "Used with this large with respect to the number of vertices in the graph, we see that Johnson still outperforms.",
            "Our algorithm was rather quickly.",
            "We outperformed the others by by a nice margin."
        ],
        [
            "Here's another one from a other point of view.",
            "It's actually the same type of graph, but here we kept the number of vertices constant at 150 and we increased the induced width.",
            "So here we can see that if the induced with is large with respect to the size of the graph, so about 80 from that point on.",
            "Johnson starts out performance, but before that our algorithm is fastest.",
            "Something that you should know, by the way, is that all these three algorithms actually calculate the same information, so the output and the input to algorithms is exactly the same."
        ],
        [
            "Another type of graph is to Rd networks NYC, so this would be an example where we do spatial reasoning induced with his various here from 2 to 51 and we let the number of vertices increase up to 5000 and we see even at the right that's the.",
            "Also, the original access error log rhythmic scale, so that's why Floyd Warshall shows a straight line on a double lock scale.",
            "Any building will will show a straight line and.",
            "At the right at around 5000 British, we still have like an order of magnitudes.",
            "We are like an order of magnitude faster than Johnson and this difference is actually a little bit larger.",
            "Still around the thousand for this vertex mark."
        ],
        [
            "For job shop, this is not actually job shop problem we solved, but we constructed.",
            "Estian insists that you would we have the structure that you would encounter when you try to solve chop shop problems.",
            "Here the difference is actually a bit smaller, and especially when the graphs are small.",
            "The three algorithms are rather close, but when they grow a little larger we are still the fastest, but not by as wide margin."
        ],
        [
            "And finally, if you have HD ensan, we construct SCN instances that you will encounter when you try to solve hierarchical task networks.",
            "Then these graphs already are a bit really likes the, so that's why our algorithm benefits from that a lot.",
            "So even if the induced with rice is rather high, the number of vertices is about constant here.",
            "Then we still we yeah, we outperformed the others of the entire range."
        ],
        [
            "So in conclusion, we proposed a new simple open shortest path algorithm, and for graphs of constant re with that runs in N squared time, which is optimal for choreographs.",
            "It runs in end times M time and for general graphs we have this bound of N times the number of edges in the quarter graph or N squared times the induced with and we empirically verified that this that our approach outperforms the competitors in most case."
        ],
        [
            "Future work for us would be to find, well, actually, I know that there is a even more efficient implementation possible where we dropped the exponent on the number of vertices and move it back to the induced with.",
            "But then we have N ^2 * S S. Is this size of largest separator in the graph, and this is always smaller than the induced with your graph.",
            "So this is especially important again for HNS where the branching factor influences the mostly the size of induced within the separator size is usually very small.",
            "We should also compare our approach against rather more recent open shortest path algorithm from 2004, which we actually only found about pretty near the deadline which runs in squared log log in time.",
            "So we should implement that and compare against that one as well.",
            "Thanks for the brilliant talk, really enjoyed it.",
            "I was just wondering, in the Johnson algorithm that seems to be at least in the estian setting competitive.",
            "Which kind of priority queue did you use and which implementation of that was there and follow up of this would be which kind of numbers you have looked at.",
            "Was it like integers or general things?",
            "I was just wondering because there are some new implementation of priority queues at might.",
            "Be little bit more competitive, right?",
            "Thank you for your question.",
            "This allows me also to tell.",
            "OK, we used Fibonacci heaps in the Johnson algorithm which give these log log N about Logan bound.",
            "But actually the favorite cheap implementation which is available in, for example, the introduction to algorithm book by Korman and others.",
            "This suffers from from mistake that actually doesn't yield this.",
            "This efficiency, so there is a pointer in my paper for an implementation of the Fibonacci heap that does give this efficiency, and this is the one we used.",
            "So if you use Affinity, follow this follow this link.",
            "But to answer the second part of your question.",
            "Actually, in all the benchmarks we used, we only looked at integers.",
            "So presumably for this case, there are more efficient heaps available.",
            "However, we wanted to present an algorithm that runs in the general case, so even for real values.",
            "Yes, is that the?",
            "Right?",
            "Hi, how does this work relate to a contraction hierarchies that done for a single in pathfinding?",
            "'cause it seems pretty simple, similar that edges are contracted.",
            "I didn't catch the first.",
            "What kind of hierarchy conduction hell is complex for pathfinding.",
            "OK, I'm not really familiar with that application I'm afraid.",
            "Do you calculate all pair shortest path and they know that it works for a single pathfinding, right?",
            "But it seems like very similar and just do it falters and to be pretty similar, but OK, I will look at the at work, but if you just want to find the shortest path between one pair of vertices, there are more efficient ways to go about it.",
            "I'm I'm sure I'm certain actually can clarify there, So what they do is they build a data structure that later allow sufficient all pairs shortest path queries.",
            "OK yeah, then solving those problems, so that's what that yes there are.",
            "There is a related work where the graph is prepared in a way for later allowing efficient queries.",
            "That's very interesting and.",
            "That's not what we do here, so right here we calculate them all and we store them in an array and then you can just look up any shortest path you want in constant time.",
            "So I have a question.",
            "So when you, when, when when you use kind of the tree decomposition, what you really?",
            "I mean the tree tree decompositions are basically based on undirected graph.",
            "So you're not not exploiting the fact that some edges might only run in One Direction, right?",
            "I wondered if there would be some way of exploiting that to reduce the parameters a bit or so.",
            "Yeah, very interesting question.",
            "That's something I've briefly looked at three years ago.",
            "Which I would like to look at again because I think there might still be something there too.",
            "Increase efficiency further.",
            "So yes, that's something that we would should look at.",
            "We might have time for a last question.",
            "Coming up.",
            "So in that in the first formula, W is the actual tree width of the graph right?",
            "And juice with?",
            "Yeah, so it's the one we found here.",
            "The one you found, right?",
            "So I wonder whether it's worth running an approximation algorithm for three weeks of that group, right?",
            "Yes, so actually the minimum degree approach I told you about it, so you Ristic gifts and upper bound on the on the.",
            "In the tree with the graph and there exist other risks as well, some of them, some of which should give lower better upper bounds.",
            "But then we've tried multiple touristics.",
            "Real results are in our paper.",
            "And actually, it doesn't pay to have a very expensive heuristic, because the problem itself is relatively simple.",
            "So.",
            "There you go."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So let's look at this title and let's put this in two parts because that is what I'm going to do.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In this short talk 1st, I'm going to talk about computing all pair shortest parts.",
                    "label": 0
                },
                {
                    "sent": "Going to tell you briefly reiterate what it actually means, then give a motivation for why it's interesting to you and look at existing algorithms for this problem, and when I've done that, will look at how we can leverage low tree width to calculate this so.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Consider a graph with N vertices and edges, so in.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This case we have 8 vertices and we have some edges between them and this graph is directed as you can see and these edges.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Or actually waited so their each edge has a weight.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And we are interested in calculating a shortest path from A to H. Well, actually I am and I'm going to tell you why you should be.",
                    "label": 0
                },
                {
                    "sent": "So here this is the shortest path from A to H, But actually we're not just interested in one pair of source destination, we.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "To calculate all pair shortest path so the result of that would be a matrix with N by N. So in this case 64 values for the shortest paths in this graph.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now, why is this interesting to you?",
                    "label": 1
                },
                {
                    "sent": "Of course we can use shortest paths results to reason about space.",
                    "label": 0
                },
                {
                    "sent": "Things like Maps and so on.",
                    "label": 0
                },
                {
                    "sent": "But we can also use it for temporal reasoning in simple temporal networks, which many of you will have.",
                    "label": 1
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "About but which I'm going to briefly introduce.",
                    "label": 0
                },
                {
                    "sent": "They were proposed in 1991 by Dexter Myrie in Peru and they can be used to represent and reason about temporal information, and in this network each node represents an event, and each arc represents a temporal constraint between a pair of events.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So for example, here we have two events A&B and between them we say that between 10:10 and 40 time units are allowed to pass, so this could be minutes, seconds, whatever.",
                    "label": 0
                },
                {
                    "sent": "Now if we have.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Extra events C&D.",
                    "label": 0
                },
                {
                    "sent": "Then we can actually see that this constraint, which has been stated between A&B can be tightened because if we look at events in event path from A through C2B and we see that the upper bound on the path from A to B.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": []
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is only 30 minutes, and likewise if we look at the path from a through D.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Maybe we should lower bound.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is actually 20 minutes and we can.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Find this information by considering a distance graph where instead of these intervals we have directed edges just like the example I showed at the beginning.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So, and where can this be applied?",
                    "label": 0
                },
                {
                    "sent": "If you want to solve a job shop problem, one way to go about it is to represent such a schedule as a simple temporal network, and then you can find out whether the schedule schedule is consistent or not, and you can infer new information from the schedule.",
                    "label": 0
                },
                {
                    "sent": "It is also used in temporal planning, and it has been applied in space missions such as in NASA's Mars Rover, and easy as much express.",
                    "label": 1
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now existing algorithms for all pair shortest parts are the Floyd Warshall algorithm, which is from a long time ago that runs in cubic time and Dexter and the RSD.",
                    "label": 1
                },
                {
                    "sent": "They actually proposed this to be able to reason about the simple temporal network.",
                    "label": 0
                },
                {
                    "sent": "It's very simple to implement with, which is also.",
                    "label": 1
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "There's another algorithm, Johnson's algorithm, and this benefits from.",
                    "label": 0
                },
                {
                    "sent": "If the graph is sparse, so if it is comparatively few edges, it's a little bit harder to implement, and it makes use affinity to attain this N squared log in time bound.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "There are some other algorithm which algorithms which you can apply to the STN.",
                    "label": 0
                },
                {
                    "sent": "For example the Bellman Ford algorithm which calculates single source shortest paths which runs in N * M time.",
                    "label": 0
                },
                {
                    "sent": "It can be used to find out where the network is consistent or not.",
                    "label": 0
                },
                {
                    "sent": "So if it is inconsistent then there is a negative cycle in this network.",
                    "label": 0
                },
                {
                    "sent": "It can also be used to find just a single schedule for events and it can be used to infer constraints involving just a single time.",
                    "label": 1
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And another approach is our own P3C algorithm from three years ago, which also benefits from, well actually from low tree with, which is where I'm moving on to this subject in a moment.",
                    "label": 0
                },
                {
                    "sent": "What we do here is we calculate shortest paths for multiple pairs, but not for all pairs.",
                    "label": 0
                },
                {
                    "sent": "So for an interesting subset of these or all these pairs for those and just a couple of others, we calculate the inferred constraints and for this specific problem it is currently the state of the art.",
                    "label": 1
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now let's talk about how to leverage this low tree width of of a graph.",
                    "label": 0
                },
                {
                    "sent": "First, we're going to look at directed pass consistency.",
                    "label": 0
                },
                {
                    "sent": "Then Snowball is our new algorithm, and we're going to tell you how that works.",
                    "label": 0
                },
                {
                    "sent": "I'll tell you about the empirical evaluation of our method.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So director position.",
                    "label": 0
                },
                {
                    "sent": "He was also proposed by Dexter to use from the STP to determine whether or not consistent and this approach actually known from constraint satisfaction literature.",
                    "label": 1
                },
                {
                    "sent": "So, given what you need is an ordering of your vertices, and given this ordering, it runs in end times the induced width of this ordering squared time.",
                    "label": 0
                },
                {
                    "sent": "And what exactly this means.",
                    "label": 0
                },
                {
                    "sent": "I will show you in the next slide, and this is actually a prerequisite to the P3C algorithm.",
                    "label": 0
                },
                {
                    "sent": "Talked about just now.",
                    "label": 1
                },
                {
                    "sent": "It's also a prerequisite to our snowball algorithm, which I'll talk about in a moment.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So this is the director position.",
                    "label": 0
                },
                {
                    "sent": "See algorithm, which is actually there's all the pseudocode there is, so it's actually pretty simple.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "What we do is we iterate downwards over along this ordering D we trade downwards overall.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Vertices and then we look at all pairs of neighbors of each vertex in this direction and.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "All these pairs of neighbors we try to see if there is a shorter path going through this current vertex K from one neighbor to the other, and if there is any updates, the weights in this graph.",
                    "label": 0
                },
                {
                    "sent": "There is some inconsistency in the network, so if there is some negative cycle in our graph then this is also the point where we will find out.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Another point what happens is that the set of edges of your graph may actually in many cases go grow bigger.",
                    "label": 0
                },
                {
                    "sent": "And what we would like is to have this as little as possible.",
                    "label": 0
                },
                {
                    "sent": "I'll move on to the moment.",
                    "label": 0
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here's an example of how it would work, more or less.",
                    "label": 0
                },
                {
                    "sent": "I've taken out the the weights of the edges to reduce clutter.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So let's assume that we have an ordering in this graph from left to right, so or alphabetically from A to H.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Our current vertex vertex A and we look at all neighbors of vertex A and now for all pairs of these neighbors we calculate the shortest path.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Through Vertex a.",
                    "label": 0
                },
                {
                    "sent": "And as you see, these red edges have actually been added, so this is a lot of extra edge edges in this small graph.",
                    "label": 0
                },
                {
                    "sent": "They also contain the shortest path, for example from B2D through Vertex a so up there.",
                    "label": 0
                },
                {
                    "sent": "Two down there via.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Protects a witch.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here.",
                    "label": 0
                },
                {
                    "sent": "And blue edges have also been updated.",
                    "label": 0
                },
                {
                    "sent": "If this is possible.",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Let's move on next Vertex first B.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And again we look at this neighbors.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "All pairs of it, and we update the edge.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "It's between them.",
                    "label": 0
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And so on.",
                    "label": 0
                },
                {
                    "sent": "Here's one extra edge that.",
                    "label": 0
                }
            ]
        },
        "clip_39": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "I've been at it.",
                    "label": 0
                }
            ]
        },
        "clip_40": {
            "is_summarization_sample": false,
            "summarization_data": []
        },
        "clip_41": {
            "is_summarization_sample": false,
            "summarization_data": []
        },
        "clip_42": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Can we move on until?",
                    "label": 0
                }
            ]
        },
        "clip_43": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Until we are done, we have just two left.",
                    "label": 0
                },
                {
                    "sent": "So actually what we now have between vertis G&H is guaranteed to be the shortest path between these two.",
                    "label": 0
                },
                {
                    "sent": "So that's one side effect of the direct path necessary algorithm that already have one pair of shorts, parts of.",
                    "label": 0
                }
            ]
        },
        "clip_44": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "All of them, right?",
                    "label": 0
                },
                {
                    "sent": "That's the first point.",
                    "label": 0
                },
                {
                    "sent": "In this slide, the last two vertices, the edge between them is labeled by the minimum weight.",
                    "label": 0
                },
                {
                    "sent": "In this example I just showed you the induced with is 5.",
                    "label": 0
                },
                {
                    "sent": "I didn't really tell you, but what it is.",
                    "label": 0
                },
                {
                    "sent": "Is the number.",
                    "label": 0
                },
                {
                    "sent": "Let's move back.",
                    "label": 0
                }
            ]
        },
        "clip_45": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Induced with this five.",
                    "label": 0
                },
                {
                    "sent": "Because this is the largest number of neighbors that downstream neighbors, I should say that one vertex going to show for it.",
                    "label": 0
                }
            ]
        },
        "clip_46": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Well here we have 5 neighbors.",
                    "label": 0
                }
            ]
        },
        "clip_47": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Actually this one is 4.",
                    "label": 0
                }
            ]
        },
        "clip_48": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "But",
                    "label": 0
                }
            ]
        },
        "clip_49": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "SC also has.",
                    "label": 0
                }
            ]
        },
        "clip_50": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "04",
                    "label": 0
                }
            ]
        },
        "clip_51": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Or right, so the rest is for the first time.",
                    "label": 0
                }
            ]
        },
        "clip_52": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "5.",
                    "label": 0
                }
            ]
        },
        "clip_53": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And the number.",
                    "label": 0
                }
            ]
        },
        "clip_54": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Fill edges in the.",
                    "label": 0
                }
            ]
        },
        "clip_55": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In this case is 9.",
                    "label": 0
                },
                {
                    "sent": "This is a bit high.",
                    "label": 0
                },
                {
                    "sent": "We would try to, because this is all overhead for the use of our algorithm, so we would like to try and minimize this, and one way to go about this.",
                    "label": 0
                },
                {
                    "sent": "It's a very simple heuristic which is called the minimum degree you are.",
                    "label": 0
                }
            ]
        },
        "clip_56": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we have to graph again, but instead of going from left to right, we at each point we take the vertex which has the fewest number of neighbors, so.",
                    "label": 0
                }
            ]
        },
        "clip_57": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Example or three of Oh yes, one extra thing I should tell you what I'm going to look at in this example is assumed there is a short spot from G2H or the other way around, which runs all the way through through the graph.",
                    "label": 0
                },
                {
                    "sent": "Then you can see how this shortest passes updated as the algorithm moves on.",
                    "label": 0
                }
            ]
        },
        "clip_58": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So there are three features of weight of with two neighbors, so at first we consider all three of these.",
                    "label": 0
                }
            ]
        },
        "clip_59": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And we update the edges between the man at the new one is if possible.",
                    "label": 0
                },
                {
                    "sent": "So now actually there is a shortest path in this graph which skips over vertex B, which was up there and that goes directly from A to F. And there is one at.",
                    "label": 0
                }
            ]
        },
        "clip_60": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "That edge, so we move on and we see now that the shortest path from.",
                    "label": 0
                }
            ]
        },
        "clip_61": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Will run from.",
                    "label": 0
                }
            ]
        },
        "clip_62": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "G2F",
                    "label": 0
                }
            ]
        },
        "clip_63": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And so on.",
                    "label": 0
                },
                {
                    "sent": "And in the end.",
                    "label": 0
                }
            ]
        },
        "clip_64": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Again, we are assured that the edge between G&H is labeled by the shortest weight.",
                    "label": 0
                }
            ]
        },
        "clip_65": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And now in this example we saw that the induced with only three and we have added only two field edges.",
                    "label": 0
                },
                {
                    "sent": "And what we offer also seems to the shortest path between two vertices can always be found by looking down only at lower neighbor lower number of neighbors and we use this in our snowball.",
                    "label": 0
                }
            ]
        },
        "clip_66": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Algorithm.",
                    "label": 0
                },
                {
                    "sent": "Right like P3C.",
                    "label": 0
                },
                {
                    "sent": "This algorithm builds upon the results.",
                    "label": 0
                },
                {
                    "sent": "From the PC.",
                    "label": 0
                },
                {
                    "sent": "It runs in the end times.",
                    "label": 0
                },
                {
                    "sent": "MC I should tell you what MC is of course, and was just a number of edges originally in the graph, and MC is the number of edges and it's called the core graph which is triangulated, which is the number of original edges plus the red ones I showed you.",
                    "label": 0
                },
                {
                    "sent": "So the total number of edges after running VPC, and actually this is a subset of N squared times the induced with and the idea behind our algorithm is that after DC as I told you.",
                    "label": 0
                },
                {
                    "sent": "Wait between the last two vertices in.",
                    "label": 0
                },
                {
                    "sent": "Our ordering is already minimal and the shortest path to from any two or from any vertex runs only through lower number of vertices in the ordering.",
                    "label": 0
                }
            ]
        },
        "clip_67": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So here's the pseudocode.",
                    "label": 0
                },
                {
                    "sent": "First, Noble algorithm.",
                    "label": 0
                },
                {
                    "sent": "At first we run the PC and then we go back up again.",
                    "label": 0
                },
                {
                    "sent": "If you remember, the PC ran from end to end and this one runs from one from 12:50 and this one runs from 1:00 to N. At first",
                    "label": 0
                }
            ]
        },
        "clip_68": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We initialize our distance matrix by setting all values to zero except the ones on the diagonal from one vertex to itself.",
                    "label": 0
                },
                {
                    "sent": "30 and then we iterate.",
                    "label": 0
                }
            ]
        },
        "clip_69": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Over this ordering.",
                    "label": 0
                },
                {
                    "sent": "Then what we do is again we look only at lower number at edges.",
                    "label": 0
                }
            ]
        },
        "clip_70": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "But then for every other edge which is also lower, no number we can actually update this values in the distance matrix and we know that after each iteration of the outer loop, we're sure we prove this in a paper now briefly.",
                    "label": 0
                },
                {
                    "sent": "I go explain more or less in the next slide how it works.",
                    "label": 0
                },
                {
                    "sent": "After this, each iteration of the outer loop, we are sure that values in the distance matrix involving vertex.",
                    "label": 0
                },
                {
                    "sent": "OK, are set correctly.",
                    "label": 0
                }
            ]
        },
        "clip_71": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we after PC this is where we were.",
                    "label": 0
                },
                {
                    "sent": "We have to get two vertices left and we know that the shortest path between them as being calculated.",
                    "label": 0
                },
                {
                    "sent": "There's really hand WAVY by the way, so I moved back up the next.",
                    "label": 0
                }
            ]
        },
        "clip_72": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is F.",
                    "label": 0
                }
            ]
        },
        "clip_73": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And I know that the two.",
                    "label": 0
                },
                {
                    "sent": "Just from F2, the lower number for dishes are also.",
                    "label": 0
                },
                {
                    "sent": "Any path that would go through here is actually incorporated in these two edges.",
                    "label": 0
                },
                {
                    "sent": "So we can update the distance matrix for values for.",
                    "label": 0
                },
                {
                    "sent": "For node F.",
                    "label": 0
                }
            ]
        },
        "clip_74": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The next one is D.",
                    "label": 0
                }
            ]
        },
        "clip_75": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Again, we only need to look at a downwards pointing edges.",
                    "label": 0
                }
            ]
        },
        "clip_76": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And so on.",
                    "label": 0
                }
            ]
        },
        "clip_77": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This is really handwaving.",
                    "label": 0
                },
                {
                    "sent": "Actual proof is in the in our paper.",
                    "label": 0
                }
            ]
        },
        "clip_78": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now there are some special cases of graphs where we can actually tighten our theoretical bound that I just told you about.",
                    "label": 0
                },
                {
                    "sent": "If there is some ordering of vertices for which there is a constant induced with, then we can find this in linear time linear in the number of vertices.",
                    "label": 0
                },
                {
                    "sent": "But actually this WD which is a constant is somewhere in an exponent of this of this.",
                    "label": 0
                },
                {
                    "sent": "So it's only where file is WD is really small, but in this case WD is constant.",
                    "label": 0
                },
                {
                    "sent": "Then the snowball algorithm runs in.",
                    "label": 0
                },
                {
                    "sent": "Squared Time, which is optimal because the output of the algorithm is also N ^2.",
                    "label": 0
                },
                {
                    "sent": "If the graph is already chordal, so if there is some ordering for DPC in which we didn't have to add any edges.",
                    "label": 0
                },
                {
                    "sent": "If such an ordering exists, we can actually find this in linear time, and this is a much nicer formula because it's just.",
                    "label": 0
                },
                {
                    "sent": "There's no hidden exponents anywhere.",
                    "label": 0
                },
                {
                    "sent": "If this is the case, then it actually runs in end times M time, which is a nice bound.",
                    "label": 0
                },
                {
                    "sent": "Because it's, for example, the same as the Bellman Ford algorithm, which only calculates single source water.",
                    "label": 0
                }
            ]
        },
        "clip_79": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Parts.",
                    "label": 0
                },
                {
                    "sent": "Now the name Snowball.",
                    "label": 0
                },
                {
                    "sent": "Where does it derive from?",
                    "label": 0
                },
                {
                    "sent": "Actually, the number of computers shortest paths in a graph.",
                    "label": 0
                },
                {
                    "sent": "Gross gross.",
                    "label": 0
                }
            ]
        },
        "clip_80": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Quadratically bit.",
                    "label": 0
                }
            ]
        },
        "clip_81": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Like this poor man.",
                    "label": 0
                }
            ]
        },
        "clip_82": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Animation, so it's a bit like a snowball running downhill, growing bigger all the time and actually at the moment that the bikers deadline was there was snow.",
                    "label": 0
                },
                {
                    "sent": "Also in our in Delft.",
                    "label": 0
                },
                {
                    "sent": "So that's why it was on my mind.",
                    "label": 0
                }
            ]
        },
        "clip_83": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now we empirically evaluated or algorithms.",
                    "label": 0
                },
                {
                    "sent": "Also, we compared Floyd Warshall and Johnson's algorithm against our own algorithm.",
                    "label": 0
                },
                {
                    "sent": "We implemented all these algorithms in Java and we ran each benchmark 10 times.",
                    "label": 0
                }
            ]
        },
        "clip_84": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Took the average.",
                    "label": 0
                },
                {
                    "sent": "Here is an overview of all the benchmarks we have so you can see that there are some instances where we let the number of.",
                    "label": 0
                },
                {
                    "sent": "First, he should grow quite quite high and also the number of edges in some of these graphs are rather large.",
                    "label": 0
                },
                {
                    "sent": "And what we also did is we in some of the benchmarks we varied the size of the graph, the number of vertices instead of some others.",
                    "label": 0
                },
                {
                    "sent": "We kept the number of vertices constant and we varied the density of the graph the tree with.",
                    "label": 0
                },
                {
                    "sent": "I.",
                    "label": 0
                }
            ]
        },
        "clip_85": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Actually, only going to show you a couple of them, these when I'll leave out for now, but they're in our page.",
                    "label": 0
                }
            ]
        },
        "clip_86": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So for scale free graph scale free graph, let me briefly introduce a graph in which there are just a couple of nodes which have a very large number of neighbors and there are many nodes which only have a few.",
                    "label": 0
                },
                {
                    "sent": "These follow a power law.",
                    "label": 0
                },
                {
                    "sent": "The distribution of degree over over vertices.",
                    "label": 0
                },
                {
                    "sent": "Now what we see here.",
                    "label": 0
                },
                {
                    "sent": "What we actually in our R plots the time on the vertical axis is in the log scale and in the milliseconds.",
                    "label": 0
                },
                {
                    "sent": "So what we see here, we kept the induced with more or less constant while we induced increase the number of vertices and at the beginning where the.",
                    "label": 0
                },
                {
                    "sent": "Used with this large with respect to the number of vertices in the graph, we see that Johnson still outperforms.",
                    "label": 0
                },
                {
                    "sent": "Our algorithm was rather quickly.",
                    "label": 0
                },
                {
                    "sent": "We outperformed the others by by a nice margin.",
                    "label": 0
                }
            ]
        },
        "clip_87": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here's another one from a other point of view.",
                    "label": 0
                },
                {
                    "sent": "It's actually the same type of graph, but here we kept the number of vertices constant at 150 and we increased the induced width.",
                    "label": 0
                },
                {
                    "sent": "So here we can see that if the induced with is large with respect to the size of the graph, so about 80 from that point on.",
                    "label": 0
                },
                {
                    "sent": "Johnson starts out performance, but before that our algorithm is fastest.",
                    "label": 0
                },
                {
                    "sent": "Something that you should know, by the way, is that all these three algorithms actually calculate the same information, so the output and the input to algorithms is exactly the same.",
                    "label": 0
                }
            ]
        },
        "clip_88": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Another type of graph is to Rd networks NYC, so this would be an example where we do spatial reasoning induced with his various here from 2 to 51 and we let the number of vertices increase up to 5000 and we see even at the right that's the.",
                    "label": 0
                },
                {
                    "sent": "Also, the original access error log rhythmic scale, so that's why Floyd Warshall shows a straight line on a double lock scale.",
                    "label": 0
                },
                {
                    "sent": "Any building will will show a straight line and.",
                    "label": 0
                },
                {
                    "sent": "At the right at around 5000 British, we still have like an order of magnitudes.",
                    "label": 0
                },
                {
                    "sent": "We are like an order of magnitude faster than Johnson and this difference is actually a little bit larger.",
                    "label": 0
                },
                {
                    "sent": "Still around the thousand for this vertex mark.",
                    "label": 0
                }
            ]
        },
        "clip_89": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "For job shop, this is not actually job shop problem we solved, but we constructed.",
                    "label": 0
                },
                {
                    "sent": "Estian insists that you would we have the structure that you would encounter when you try to solve chop shop problems.",
                    "label": 0
                },
                {
                    "sent": "Here the difference is actually a bit smaller, and especially when the graphs are small.",
                    "label": 0
                },
                {
                    "sent": "The three algorithms are rather close, but when they grow a little larger we are still the fastest, but not by as wide margin.",
                    "label": 0
                }
            ]
        },
        "clip_90": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And finally, if you have HD ensan, we construct SCN instances that you will encounter when you try to solve hierarchical task networks.",
                    "label": 0
                },
                {
                    "sent": "Then these graphs already are a bit really likes the, so that's why our algorithm benefits from that a lot.",
                    "label": 0
                },
                {
                    "sent": "So even if the induced with rice is rather high, the number of vertices is about constant here.",
                    "label": 0
                },
                {
                    "sent": "Then we still we yeah, we outperformed the others of the entire range.",
                    "label": 0
                }
            ]
        },
        "clip_91": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So in conclusion, we proposed a new simple open shortest path algorithm, and for graphs of constant re with that runs in N squared time, which is optimal for choreographs.",
                    "label": 0
                },
                {
                    "sent": "It runs in end times M time and for general graphs we have this bound of N times the number of edges in the quarter graph or N squared times the induced with and we empirically verified that this that our approach outperforms the competitors in most case.",
                    "label": 0
                }
            ]
        },
        "clip_92": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Future work for us would be to find, well, actually, I know that there is a even more efficient implementation possible where we dropped the exponent on the number of vertices and move it back to the induced with.",
                    "label": 0
                },
                {
                    "sent": "But then we have N ^2 * S S. Is this size of largest separator in the graph, and this is always smaller than the induced with your graph.",
                    "label": 0
                },
                {
                    "sent": "So this is especially important again for HNS where the branching factor influences the mostly the size of induced within the separator size is usually very small.",
                    "label": 0
                },
                {
                    "sent": "We should also compare our approach against rather more recent open shortest path algorithm from 2004, which we actually only found about pretty near the deadline which runs in squared log log in time.",
                    "label": 0
                },
                {
                    "sent": "So we should implement that and compare against that one as well.",
                    "label": 0
                },
                {
                    "sent": "Thanks for the brilliant talk, really enjoyed it.",
                    "label": 0
                },
                {
                    "sent": "I was just wondering, in the Johnson algorithm that seems to be at least in the estian setting competitive.",
                    "label": 0
                },
                {
                    "sent": "Which kind of priority queue did you use and which implementation of that was there and follow up of this would be which kind of numbers you have looked at.",
                    "label": 0
                },
                {
                    "sent": "Was it like integers or general things?",
                    "label": 0
                },
                {
                    "sent": "I was just wondering because there are some new implementation of priority queues at might.",
                    "label": 0
                },
                {
                    "sent": "Be little bit more competitive, right?",
                    "label": 0
                },
                {
                    "sent": "Thank you for your question.",
                    "label": 0
                },
                {
                    "sent": "This allows me also to tell.",
                    "label": 0
                },
                {
                    "sent": "OK, we used Fibonacci heaps in the Johnson algorithm which give these log log N about Logan bound.",
                    "label": 0
                },
                {
                    "sent": "But actually the favorite cheap implementation which is available in, for example, the introduction to algorithm book by Korman and others.",
                    "label": 0
                },
                {
                    "sent": "This suffers from from mistake that actually doesn't yield this.",
                    "label": 0
                },
                {
                    "sent": "This efficiency, so there is a pointer in my paper for an implementation of the Fibonacci heap that does give this efficiency, and this is the one we used.",
                    "label": 0
                },
                {
                    "sent": "So if you use Affinity, follow this follow this link.",
                    "label": 0
                },
                {
                    "sent": "But to answer the second part of your question.",
                    "label": 0
                },
                {
                    "sent": "Actually, in all the benchmarks we used, we only looked at integers.",
                    "label": 0
                },
                {
                    "sent": "So presumably for this case, there are more efficient heaps available.",
                    "label": 0
                },
                {
                    "sent": "However, we wanted to present an algorithm that runs in the general case, so even for real values.",
                    "label": 0
                },
                {
                    "sent": "Yes, is that the?",
                    "label": 0
                },
                {
                    "sent": "Right?",
                    "label": 0
                },
                {
                    "sent": "Hi, how does this work relate to a contraction hierarchies that done for a single in pathfinding?",
                    "label": 0
                },
                {
                    "sent": "'cause it seems pretty simple, similar that edges are contracted.",
                    "label": 0
                },
                {
                    "sent": "I didn't catch the first.",
                    "label": 0
                },
                {
                    "sent": "What kind of hierarchy conduction hell is complex for pathfinding.",
                    "label": 0
                },
                {
                    "sent": "OK, I'm not really familiar with that application I'm afraid.",
                    "label": 0
                },
                {
                    "sent": "Do you calculate all pair shortest path and they know that it works for a single pathfinding, right?",
                    "label": 0
                },
                {
                    "sent": "But it seems like very similar and just do it falters and to be pretty similar, but OK, I will look at the at work, but if you just want to find the shortest path between one pair of vertices, there are more efficient ways to go about it.",
                    "label": 0
                },
                {
                    "sent": "I'm I'm sure I'm certain actually can clarify there, So what they do is they build a data structure that later allow sufficient all pairs shortest path queries.",
                    "label": 0
                },
                {
                    "sent": "OK yeah, then solving those problems, so that's what that yes there are.",
                    "label": 0
                },
                {
                    "sent": "There is a related work where the graph is prepared in a way for later allowing efficient queries.",
                    "label": 0
                },
                {
                    "sent": "That's very interesting and.",
                    "label": 0
                },
                {
                    "sent": "That's not what we do here, so right here we calculate them all and we store them in an array and then you can just look up any shortest path you want in constant time.",
                    "label": 0
                },
                {
                    "sent": "So I have a question.",
                    "label": 0
                },
                {
                    "sent": "So when you, when, when when you use kind of the tree decomposition, what you really?",
                    "label": 0
                },
                {
                    "sent": "I mean the tree tree decompositions are basically based on undirected graph.",
                    "label": 0
                },
                {
                    "sent": "So you're not not exploiting the fact that some edges might only run in One Direction, right?",
                    "label": 0
                },
                {
                    "sent": "I wondered if there would be some way of exploiting that to reduce the parameters a bit or so.",
                    "label": 0
                },
                {
                    "sent": "Yeah, very interesting question.",
                    "label": 0
                },
                {
                    "sent": "That's something I've briefly looked at three years ago.",
                    "label": 0
                },
                {
                    "sent": "Which I would like to look at again because I think there might still be something there too.",
                    "label": 0
                },
                {
                    "sent": "Increase efficiency further.",
                    "label": 0
                },
                {
                    "sent": "So yes, that's something that we would should look at.",
                    "label": 0
                },
                {
                    "sent": "We might have time for a last question.",
                    "label": 0
                },
                {
                    "sent": "Coming up.",
                    "label": 0
                },
                {
                    "sent": "So in that in the first formula, W is the actual tree width of the graph right?",
                    "label": 0
                },
                {
                    "sent": "And juice with?",
                    "label": 0
                },
                {
                    "sent": "Yeah, so it's the one we found here.",
                    "label": 0
                },
                {
                    "sent": "The one you found, right?",
                    "label": 0
                },
                {
                    "sent": "So I wonder whether it's worth running an approximation algorithm for three weeks of that group, right?",
                    "label": 0
                },
                {
                    "sent": "Yes, so actually the minimum degree approach I told you about it, so you Ristic gifts and upper bound on the on the.",
                    "label": 0
                },
                {
                    "sent": "In the tree with the graph and there exist other risks as well, some of them, some of which should give lower better upper bounds.",
                    "label": 0
                },
                {
                    "sent": "But then we've tried multiple touristics.",
                    "label": 0
                },
                {
                    "sent": "Real results are in our paper.",
                    "label": 0
                },
                {
                    "sent": "And actually, it doesn't pay to have a very expensive heuristic, because the problem itself is relatively simple.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "There you go.",
                    "label": 0
                }
            ]
        }
    }
}