{
    "id": "5q4b6utm3m2pv7o6ql6r2sevgs4gqmxk",
    "title": "SYRql: A Dataflow Language for Large Scale Processing of RDF Data",
    "info": {
        "author": [
            "Fadi Maali, DERI Galway, National University of Ireland, Galway"
        ],
        "published": "Dec. 19, 2014",
        "recorded": "October 2014",
        "category": [
            "Top->Computer Science->Semantic Web"
        ]
    },
    "url": "http://videolectures.net/iswc2014_maali_dataflow_language/",
    "segmentation": [
        [
            "So I started."
        ],
        [
            "Motivating the need for a dataflow language.",
            "Then I'll talk about the underlying data model, which is RDF algebra, and I think I'll spend most of the time of the presentation, and this part was, I believe, is one of them.",
            "Most interesting contribution of the paper.",
            "I then describe the language we called it circle, and then I'll.",
            "I think quickly show the implementation and evaluation.",
            "So data is growing and RDF data is no exception, and analyzing the data is increasingly becoming the bottleneck.",
            "So in particular, in the case of RDF, if you have a large amount of RDF data and you want to query it or process it, you have two options.",
            "You either can use Sparkle and I."
        ],
        [
            "Think I love sparkle, it's great for for many use cases, but for complicated analytical queries, sparkle sparkle queries can be complicated, which makes them hard to read, hard to understand, error prone, and in many times very hard for the optimizer to optimize.",
            "So this is a screenshot for a sparkle query taken from them.",
            "Berlin Sparkle benchmark business intelligence use case so that's this is a real sparkle queries just to show that they tend to be complicated for.",
            "Many analytical scenarios plus Sparkle Sparkle is known to be it's very expressive, which comes at the cost of a high evaluation code, so it's known to be P space complete problem.",
            "The other alternative of using sparkle to analyze data is to use one."
        ],
        [
            "The existing big data languages, so things like Apache Big Latent Apache Hive or IBM Jackal queries and I'm just using a batch late in as an example.",
            "Sorry about you.",
            "Big latent as as an example here.",
            "So the symbol need graph pattern of sparkle on the left.",
            "Translate to this kind of verbos and probably arguably hard to understand equivalent script in pig Latin.",
            "So you need a couple of joins.",
            "Need to keep track where things are jumping and.",
            "That the, like the root of the problem, is that this language are designed for tabular data.",
            "So when you use them to process graph data, they tend to get complicated an.",
            "As a result they are mostly with graph data.",
            "An efficient verbals, error prone and hard to read.",
            "Uh, so.",
            "We propose circle as a language that.",
            "So that's an example of a circle script.",
            "It looks like big latent in terms of its head dataflow language, so you can describe your solution in a step by step way.",
            "You can use variables, assign intermediate results there."
        ],
        [
            "And.",
            "Anne."
        ],
        [
            "And reuse reuse them later at the same time it looks."
        ],
        [
            "Like sparkle in terms of it has an agraffe underlying data model and you can use the exact exact triple pattern syntax that you use with sparkle.",
            "So the interesting questions in designing such a language is what?"
        ],
        [
            "The data model that needs to be used to like as an underlying layer for such a language.",
            "So how do we represent the data and what set of operators we need to support an typically in big data languages when using like defines a small set of operators, operators carefully selected so that they are amenable to parallelization.",
            "To ensure, like scalability and high performance.",
            "So for the data model question, the first candidate that comes to my mind probably is Sparkle Algebra, so Sparkle has a very very popular, well cited and nicely defined underlying Sparkle algebra.",
            "However, I'll show that Sparkle algebra cannot be used for this use case, and therefore motivate the definition of a new algebra as an underlying data model for a dataflow language.",
            "So what's the problem with Sparkle algebra?",
            "If we."
        ],
        [
            "Take this example, so that's a symbol small RDF query, and that's a graph pattern that I want to evaluate against that the graph so the way sparkle evaluate such a query is that it takes each of the triple pattern, evaluate them and the result will be a set of bindings and you can think of a set of binding as a table.",
            "So they'll get evaluated.",
            "Then they'll get joined and then you get the final result.",
            "So what's the problem here?",
            "The flow goes like this.",
            "You have graphs.",
            "You have light triple pattern matching.",
            "You get a set of bindings or tables and then you can do a union join Aurora filters on this table.",
            "So I like that."
        ],
        [
            "Transition this alternating from the graph word to the table or a set of bindings.",
            "Word makes the makes the algebra.",
            "It's not fully compositional, it's not closed.",
            "So, for example, you can't join two graphs cause join is just defined on set of bindings, so you can't have two graphs and join them directly using Sparkle algebra.",
            "Another example, if you if you apply a triple pattern matching like the example here.",
            "And then you want to further filter this result using another triple pattern matching.",
            "You can't use.",
            "You can't do this in sparkle, so the flow of the operators is partially hard coded in the sparkle.",
            "You have graphs, you apply triple pattern, then you are in a different world which is the set of bindings and only then you can apply things like join filter and and union and therefore Sparkle algebra as it is can't be used as an underlying data model.",
            "Web for the language for a language.",
            "For a dataflow language I was working on, so the problem is that the sparkle."
        ],
        [
            "Is not fully compositional and therefore our proposal that's described in the language and called RDF algebra.",
            "It uses simple tricks or instead of alternating between these two words, the graphs and bindings.",
            "All the operators that are defined have an input, an output, a set of operators of pairs of graphs and tables.",
            "So any operator the input will be a set of pairs of graphs and associated binding or a table.",
            "And the output will be the same.",
            "And just because the input and the output of all the operators are the same, this is a.",
            "This is a closed algebra.",
            "You can cascade the operators as as as much as you want and makes it fully compositional."
        ],
        [
            "So the syntax and the semantics of the algebra is formally defined in the paper.",
            "And Furthermore, we OK."
        ],
        [
            "You know, before jumping to.",
            "There I'll just show a quick two example, so this is just a diagram representing the underlying data model, so there is always a pair of a graph and associated table.",
            "It's the and it's a set usually, and that's, uh, just a pictorial representation of a triple pattern matching, and the result will always be a set of pairs.",
            "So don't worry much about the details, but.",
            "The point I want to make is that the input and output of all the operators are consistent.",
            "They are always a set of pairs of graphs and associated bindings.",
            "That's an example of a triple pattern matching and that."
        ],
        [
            "Another example of a cross product, so it's always a set of pairs and then put the set of pairs and output with a set of pairs.",
            "As I said, like the syntax and the semantics is formally defined in the in the paper, I didn't include the details here."
        ],
        [
            "The other thing we did is that we convert the expressivity of this language to sparkle so it's existing state that the expressivity is equivalent to sparkle.",
            "1.1 basic graph pattern matching with filtered aggregation and assignments like the binding statement, but Additionally the language has a definition to extend the graph, which means you can do things that you can let's particle allows you to do using construct which is changed that shape of the graph.",
            "However, this is defined as a.",
            "As a basic operator of the data, so it's similar to the other operators, whereas in sparkle, the way that constructs usually goes is that you have the graph you do like all the query you end up with a set of bindings.",
            "Then from this set of bindings you construct the graph, the graph again, or the new graph that's described by the construct body.",
            "Which yeah, which makes like the contact very kind of a special after like special modification that's applied after evaluating the query.",
            "However, here extending the graph, transforming it or defining a new edge or triple in it and is yet another basic operators.",
            "OK."
        ],
        [
            "So another thing that this allows is a new set of algebraic properties, so that's kind of a new algebra.",
            "It's very similar to relational operators, very similar to Sparkle algebra with few differences, but at the same time it has its unique algebraic properties which provide an optimization opportunity, unique optimization opportunities.",
            "So like properties of.",
            "Of operators that are inherited from sparkle apply here, but Furthermore, because you can cascade operators you, there's a new set of properties that has to do with treble pattern, which doesn't doesn't apply to sparkle and therefore was not studied before.",
            "But we define as a format like a selectivity.",
            "Would you find a relation between treble better, like a partial order relationship, which allows further optimizations?"
        ],
        [
            "This is a simple one.",
            "If you apply at least restrictive triple better into the results of another triple pattern that doesn't change anything, so you can safely right such an exception from the left to the right another."
        ],
        [
            "More interesting when if you have a cross product and then you apply a triple pattern to the result, you can actually sorry."
        ],
        [
            "You can add."
        ],
        [
            "Sleep.",
            "Jump too much.",
            "You can actually Bush this election inside.",
            "That's cool, but it's even more interesting 'cause you can.",
            "Bush lists any list selective triple pattern inside.",
            "So if you have these and this is one of the most expensive operators like it's across product or a join.",
            "But if you have these calculated like cashed or you have an index that can give you this result quickly.",
            "So instead of executing this you can execute this.",
            "Then do the triple button on that.",
            "On the result.",
            "So we believe that this can be applied in further scenarios, but that's kind of a direction for a future work, but this applies in general to caching results, reusing partial results and view management in RDF.",
            "So that's the language.",
            "That's the algebra, it's the underlying data model for the language we describe that we convert its expressivity to sparkle and we."
        ],
        [
            "Listed a number of unique algebraic properties which provide optimization opportunities for the link for the algebra, and this algebra was used as underlying data model for a language that we called circle like."
        ],
        [
            "Showed the example before, so the language just have syntactical constructs for each of the operators that are defined in the algebra.",
            "If there are like a number of also syntax decisions that we made, I think we don't have much time, but we use exactly the same syntax for the triple pattern part, the exactly the same thing that's used in sparkle.",
            "We use the bibl symbol to represent dataflow.",
            "And yeah, like it's for the implementation, we use Jason."
        ],
        [
            "LDF to represent the data and execute that the evaluation of script goes like a like typically, so there is sparse for the abstract syntax tree.",
            "Then there is a set of rewrite rules which gets an enhanced abstract syntax true.",
            "Then this gets compiled to a directed acyclic graph of operators and the current implementations.",
            "Each of these nodes that map reduce job which gets at the executed on their own.",
            "Any clustered like that has Hadoop or any equivalent MapReduce implementation.",
            "So to evaluate the.",
            "Implementation we took the Berlin Sparkle benchmark business intelligence set of queries we wrote for each query.",
            "An equivalent script in Pig Latin and then equivalent query in Apache Hive and an equivalent script of IBM, Jackal and yeah, and quick script using circle language and the point of the evaluation was just to see how the current implementation of the language compared with this existing will establish.",
            "The language is, so the argument goes something like this.",
            "We provide a syntax that for many people is more intuitive than the than the other existing languages because it inherited things from sparkle that people kind of use 2, and that's designed.",
            "That's intuitive for graph pattern matching, and we want to see whether we can.",
            "Like how far the performance we can provide in comparison to these existing languages so."
        ],
        [
            "Of experiment was run it in node cluster and that's the result that our implementation is the last column, so it's good.",
            "It's it's not the best hive still outperforms Hive, has many built-in optimizations for vectorized execution, etc.",
            "So I think we can enhance the evaluation, but the implementation.",
            "But the message of the evaluation was OK. We provide a new language more suitable for graph processing.",
            "And we provide an implementation that provides results.",
            "Now that's almost in the same range as Big Layton or Jackal.",
            "Hive has been reported also, another results to outperform these languages.",
            "But yeah, the implementation can be enhanced.",
            "However, it's very comparison to what we will get from Jack Hill or from Pig Latin."
        ],
        [
            "So to conclude, we defined RDF algebra as an underlying data model that is closed in comparison to Sparkle algebra.",
            "This this has converted.",
            "We compared the expressivity and we believe that it can has a far reaching.",
            "It can be reused in other context and hopefully have a fruitful results in related fields.",
            "And we highlighted caching like partial results reuse and view management as possible application area that we plan to.",
            "But really, like work on as part of the future work and we also presented circle like the syntax and the language that's used defined on top of this data model.",
            "So that's from my side.",
            "Thanks for your attention.",
            "Agency is so how big is the data that you evaluated?",
            "How many triples and what's the size?",
            "Tuition was running the 140 million travel.",
            "That's not large scale, is it?",
            "Yeah, it's not that huge data.",
            "We convert the time we convert the event that evaluation plan.",
            "So we looked at the.",
            "We looked at the execution plan of each of these languages and we convert that as well.",
            "And we have a compatible like evaluation plan in terms of number of these.",
            "Yeah, I agree this is not huge data, but that's that's it.",
            "In node cluster, all old machine that we have access to and that's the most we could run with it, but.",
            "Yeah, point taken I think.",
            "Like a bigger data would would also help.",
            "Could you please give more details on why cannot you do joints on graphs and how is currently this being solved by by your language?",
            "Please know you can.",
            "You can do joins in graphs.",
            "I want to say that.",
            "Oh, so you cannot, for example, take two graphs and join them.",
            "So if you have to do this in Sparkle, I was saying in the only way you do it is that if you have the whole graph you do I select star where SP or all of them are variable.",
            "Yeah and then from the first graph and then you do the same for the second graph and then you get it.",
            "So basically you can for example Union two graphs.",
            "The only way to do is to do a select rabbit in a construct because there is also for select is a set of table.",
            "If you want a graph that the union of two graphs, you do a select star from the one rabbit in a contract and then like Union the results with another.",
            "Sorry union with another select and do a construct over all of them.",
            "The problem is that union is defined on set of findings, not on graphs, so the input for a union can't be a graph and the only way to go from a graph to a set of bindings to apply a triple better.",
            "Therefore, if you, if you have a graph, you have to do this trick where you do select start and then very often in sparkle you find this also people a lot like a pattern that you may be many like.",
            "It's it's very common in literature to do to have a contract that has exactly the same body as the select and the only reason for that is that the select doesn't give you a graph and the only way to mimic this is to have everything that's in the body of the select repeated the body of the construct.",
            "So there's a work work there are work arounds, but that's more code that's harder to optimize and harder to reason about four.",
            "Engine and harder to read and harder to reuse.",
            "OK, one more quick question.",
            "Are your data is not so big?",
            "150 million, 2% body.",
            "It takes much times 60 minutes before querying processing.",
            "I'm wondering why it takes so time when I look at your evaluation pages.",
            "Yeah, this queries are really so this query is coming from the business intelligence use case, so these queries that usually touch most of the data and then do a lot of joint.",
            "So I have a screenshot is not very so.",
            "This is kind of that type of queries.",
            "These are analytical queries that like touch most of the data and then needs to ship like most of the time will be taken by the joins that needs to be like it will ship between nodes.",
            "Large amounts of data is just because that these are analytical queries that have really huge intermediate results, so most of the time was a network network time for shipping the data between the notes.",
            "Thank you.",
            "Alright, let's thank the speaker again.",
            "Thank you, fatty."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So I started.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Motivating the need for a dataflow language.",
                    "label": 1
                },
                {
                    "sent": "Then I'll talk about the underlying data model, which is RDF algebra, and I think I'll spend most of the time of the presentation, and this part was, I believe, is one of them.",
                    "label": 0
                },
                {
                    "sent": "Most interesting contribution of the paper.",
                    "label": 0
                },
                {
                    "sent": "I then describe the language we called it circle, and then I'll.",
                    "label": 0
                },
                {
                    "sent": "I think quickly show the implementation and evaluation.",
                    "label": 0
                },
                {
                    "sent": "So data is growing and RDF data is no exception, and analyzing the data is increasingly becoming the bottleneck.",
                    "label": 0
                },
                {
                    "sent": "So in particular, in the case of RDF, if you have a large amount of RDF data and you want to query it or process it, you have two options.",
                    "label": 0
                },
                {
                    "sent": "You either can use Sparkle and I.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Think I love sparkle, it's great for for many use cases, but for complicated analytical queries, sparkle sparkle queries can be complicated, which makes them hard to read, hard to understand, error prone, and in many times very hard for the optimizer to optimize.",
                    "label": 0
                },
                {
                    "sent": "So this is a screenshot for a sparkle query taken from them.",
                    "label": 0
                },
                {
                    "sent": "Berlin Sparkle benchmark business intelligence use case so that's this is a real sparkle queries just to show that they tend to be complicated for.",
                    "label": 0
                },
                {
                    "sent": "Many analytical scenarios plus Sparkle Sparkle is known to be it's very expressive, which comes at the cost of a high evaluation code, so it's known to be P space complete problem.",
                    "label": 0
                },
                {
                    "sent": "The other alternative of using sparkle to analyze data is to use one.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The existing big data languages, so things like Apache Big Latent Apache Hive or IBM Jackal queries and I'm just using a batch late in as an example.",
                    "label": 0
                },
                {
                    "sent": "Sorry about you.",
                    "label": 0
                },
                {
                    "sent": "Big latent as as an example here.",
                    "label": 0
                },
                {
                    "sent": "So the symbol need graph pattern of sparkle on the left.",
                    "label": 0
                },
                {
                    "sent": "Translate to this kind of verbos and probably arguably hard to understand equivalent script in pig Latin.",
                    "label": 0
                },
                {
                    "sent": "So you need a couple of joins.",
                    "label": 0
                },
                {
                    "sent": "Need to keep track where things are jumping and.",
                    "label": 0
                },
                {
                    "sent": "That the, like the root of the problem, is that this language are designed for tabular data.",
                    "label": 0
                },
                {
                    "sent": "So when you use them to process graph data, they tend to get complicated an.",
                    "label": 0
                },
                {
                    "sent": "As a result they are mostly with graph data.",
                    "label": 0
                },
                {
                    "sent": "An efficient verbals, error prone and hard to read.",
                    "label": 0
                },
                {
                    "sent": "Uh, so.",
                    "label": 0
                },
                {
                    "sent": "We propose circle as a language that.",
                    "label": 0
                },
                {
                    "sent": "So that's an example of a circle script.",
                    "label": 0
                },
                {
                    "sent": "It looks like big latent in terms of its head dataflow language, so you can describe your solution in a step by step way.",
                    "label": 0
                },
                {
                    "sent": "You can use variables, assign intermediate results there.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "Anne.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And reuse reuse them later at the same time it looks.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Like sparkle in terms of it has an agraffe underlying data model and you can use the exact exact triple pattern syntax that you use with sparkle.",
                    "label": 0
                },
                {
                    "sent": "So the interesting questions in designing such a language is what?",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The data model that needs to be used to like as an underlying layer for such a language.",
                    "label": 1
                },
                {
                    "sent": "So how do we represent the data and what set of operators we need to support an typically in big data languages when using like defines a small set of operators, operators carefully selected so that they are amenable to parallelization.",
                    "label": 1
                },
                {
                    "sent": "To ensure, like scalability and high performance.",
                    "label": 0
                },
                {
                    "sent": "So for the data model question, the first candidate that comes to my mind probably is Sparkle Algebra, so Sparkle has a very very popular, well cited and nicely defined underlying Sparkle algebra.",
                    "label": 0
                },
                {
                    "sent": "However, I'll show that Sparkle algebra cannot be used for this use case, and therefore motivate the definition of a new algebra as an underlying data model for a dataflow language.",
                    "label": 0
                },
                {
                    "sent": "So what's the problem with Sparkle algebra?",
                    "label": 0
                },
                {
                    "sent": "If we.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Take this example, so that's a symbol small RDF query, and that's a graph pattern that I want to evaluate against that the graph so the way sparkle evaluate such a query is that it takes each of the triple pattern, evaluate them and the result will be a set of bindings and you can think of a set of binding as a table.",
                    "label": 0
                },
                {
                    "sent": "So they'll get evaluated.",
                    "label": 0
                },
                {
                    "sent": "Then they'll get joined and then you get the final result.",
                    "label": 0
                },
                {
                    "sent": "So what's the problem here?",
                    "label": 1
                },
                {
                    "sent": "The flow goes like this.",
                    "label": 0
                },
                {
                    "sent": "You have graphs.",
                    "label": 1
                },
                {
                    "sent": "You have light triple pattern matching.",
                    "label": 1
                },
                {
                    "sent": "You get a set of bindings or tables and then you can do a union join Aurora filters on this table.",
                    "label": 0
                },
                {
                    "sent": "So I like that.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Transition this alternating from the graph word to the table or a set of bindings.",
                    "label": 0
                },
                {
                    "sent": "Word makes the makes the algebra.",
                    "label": 0
                },
                {
                    "sent": "It's not fully compositional, it's not closed.",
                    "label": 1
                },
                {
                    "sent": "So, for example, you can't join two graphs cause join is just defined on set of bindings, so you can't have two graphs and join them directly using Sparkle algebra.",
                    "label": 0
                },
                {
                    "sent": "Another example, if you if you apply a triple pattern matching like the example here.",
                    "label": 1
                },
                {
                    "sent": "And then you want to further filter this result using another triple pattern matching.",
                    "label": 0
                },
                {
                    "sent": "You can't use.",
                    "label": 0
                },
                {
                    "sent": "You can't do this in sparkle, so the flow of the operators is partially hard coded in the sparkle.",
                    "label": 0
                },
                {
                    "sent": "You have graphs, you apply triple pattern, then you are in a different world which is the set of bindings and only then you can apply things like join filter and and union and therefore Sparkle algebra as it is can't be used as an underlying data model.",
                    "label": 0
                },
                {
                    "sent": "Web for the language for a language.",
                    "label": 0
                },
                {
                    "sent": "For a dataflow language I was working on, so the problem is that the sparkle.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Is not fully compositional and therefore our proposal that's described in the language and called RDF algebra.",
                    "label": 0
                },
                {
                    "sent": "It uses simple tricks or instead of alternating between these two words, the graphs and bindings.",
                    "label": 1
                },
                {
                    "sent": "All the operators that are defined have an input, an output, a set of operators of pairs of graphs and tables.",
                    "label": 0
                },
                {
                    "sent": "So any operator the input will be a set of pairs of graphs and associated binding or a table.",
                    "label": 0
                },
                {
                    "sent": "And the output will be the same.",
                    "label": 0
                },
                {
                    "sent": "And just because the input and the output of all the operators are the same, this is a.",
                    "label": 1
                },
                {
                    "sent": "This is a closed algebra.",
                    "label": 0
                },
                {
                    "sent": "You can cascade the operators as as as much as you want and makes it fully compositional.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the syntax and the semantics of the algebra is formally defined in the paper.",
                    "label": 0
                },
                {
                    "sent": "And Furthermore, we OK.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "You know, before jumping to.",
                    "label": 0
                },
                {
                    "sent": "There I'll just show a quick two example, so this is just a diagram representing the underlying data model, so there is always a pair of a graph and associated table.",
                    "label": 0
                },
                {
                    "sent": "It's the and it's a set usually, and that's, uh, just a pictorial representation of a triple pattern matching, and the result will always be a set of pairs.",
                    "label": 0
                },
                {
                    "sent": "So don't worry much about the details, but.",
                    "label": 0
                },
                {
                    "sent": "The point I want to make is that the input and output of all the operators are consistent.",
                    "label": 0
                },
                {
                    "sent": "They are always a set of pairs of graphs and associated bindings.",
                    "label": 0
                },
                {
                    "sent": "That's an example of a triple pattern matching and that.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Another example of a cross product, so it's always a set of pairs and then put the set of pairs and output with a set of pairs.",
                    "label": 0
                },
                {
                    "sent": "As I said, like the syntax and the semantics is formally defined in the in the paper, I didn't include the details here.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The other thing we did is that we convert the expressivity of this language to sparkle so it's existing state that the expressivity is equivalent to sparkle.",
                    "label": 0
                },
                {
                    "sent": "1.1 basic graph pattern matching with filtered aggregation and assignments like the binding statement, but Additionally the language has a definition to extend the graph, which means you can do things that you can let's particle allows you to do using construct which is changed that shape of the graph.",
                    "label": 1
                },
                {
                    "sent": "However, this is defined as a.",
                    "label": 1
                },
                {
                    "sent": "As a basic operator of the data, so it's similar to the other operators, whereas in sparkle, the way that constructs usually goes is that you have the graph you do like all the query you end up with a set of bindings.",
                    "label": 0
                },
                {
                    "sent": "Then from this set of bindings you construct the graph, the graph again, or the new graph that's described by the construct body.",
                    "label": 0
                },
                {
                    "sent": "Which yeah, which makes like the contact very kind of a special after like special modification that's applied after evaluating the query.",
                    "label": 0
                },
                {
                    "sent": "However, here extending the graph, transforming it or defining a new edge or triple in it and is yet another basic operators.",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So another thing that this allows is a new set of algebraic properties, so that's kind of a new algebra.",
                    "label": 0
                },
                {
                    "sent": "It's very similar to relational operators, very similar to Sparkle algebra with few differences, but at the same time it has its unique algebraic properties which provide an optimization opportunity, unique optimization opportunities.",
                    "label": 0
                },
                {
                    "sent": "So like properties of.",
                    "label": 0
                },
                {
                    "sent": "Of operators that are inherited from sparkle apply here, but Furthermore, because you can cascade operators you, there's a new set of properties that has to do with treble pattern, which doesn't doesn't apply to sparkle and therefore was not studied before.",
                    "label": 0
                },
                {
                    "sent": "But we define as a format like a selectivity.",
                    "label": 0
                },
                {
                    "sent": "Would you find a relation between treble better, like a partial order relationship, which allows further optimizations?",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This is a simple one.",
                    "label": 0
                },
                {
                    "sent": "If you apply at least restrictive triple better into the results of another triple pattern that doesn't change anything, so you can safely right such an exception from the left to the right another.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "More interesting when if you have a cross product and then you apply a triple pattern to the result, you can actually sorry.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "You can add.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Sleep.",
                    "label": 0
                },
                {
                    "sent": "Jump too much.",
                    "label": 0
                },
                {
                    "sent": "You can actually Bush this election inside.",
                    "label": 0
                },
                {
                    "sent": "That's cool, but it's even more interesting 'cause you can.",
                    "label": 0
                },
                {
                    "sent": "Bush lists any list selective triple pattern inside.",
                    "label": 0
                },
                {
                    "sent": "So if you have these and this is one of the most expensive operators like it's across product or a join.",
                    "label": 0
                },
                {
                    "sent": "But if you have these calculated like cashed or you have an index that can give you this result quickly.",
                    "label": 0
                },
                {
                    "sent": "So instead of executing this you can execute this.",
                    "label": 0
                },
                {
                    "sent": "Then do the triple button on that.",
                    "label": 0
                },
                {
                    "sent": "On the result.",
                    "label": 0
                },
                {
                    "sent": "So we believe that this can be applied in further scenarios, but that's kind of a direction for a future work, but this applies in general to caching results, reusing partial results and view management in RDF.",
                    "label": 0
                },
                {
                    "sent": "So that's the language.",
                    "label": 0
                },
                {
                    "sent": "That's the algebra, it's the underlying data model for the language we describe that we convert its expressivity to sparkle and we.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Listed a number of unique algebraic properties which provide optimization opportunities for the link for the algebra, and this algebra was used as underlying data model for a language that we called circle like.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Showed the example before, so the language just have syntactical constructs for each of the operators that are defined in the algebra.",
                    "label": 0
                },
                {
                    "sent": "If there are like a number of also syntax decisions that we made, I think we don't have much time, but we use exactly the same syntax for the triple pattern part, the exactly the same thing that's used in sparkle.",
                    "label": 0
                },
                {
                    "sent": "We use the bibl symbol to represent dataflow.",
                    "label": 0
                },
                {
                    "sent": "And yeah, like it's for the implementation, we use Jason.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "LDF to represent the data and execute that the evaluation of script goes like a like typically, so there is sparse for the abstract syntax tree.",
                    "label": 0
                },
                {
                    "sent": "Then there is a set of rewrite rules which gets an enhanced abstract syntax true.",
                    "label": 0
                },
                {
                    "sent": "Then this gets compiled to a directed acyclic graph of operators and the current implementations.",
                    "label": 0
                },
                {
                    "sent": "Each of these nodes that map reduce job which gets at the executed on their own.",
                    "label": 0
                },
                {
                    "sent": "Any clustered like that has Hadoop or any equivalent MapReduce implementation.",
                    "label": 0
                },
                {
                    "sent": "So to evaluate the.",
                    "label": 0
                },
                {
                    "sent": "Implementation we took the Berlin Sparkle benchmark business intelligence set of queries we wrote for each query.",
                    "label": 0
                },
                {
                    "sent": "An equivalent script in Pig Latin and then equivalent query in Apache Hive and an equivalent script of IBM, Jackal and yeah, and quick script using circle language and the point of the evaluation was just to see how the current implementation of the language compared with this existing will establish.",
                    "label": 0
                },
                {
                    "sent": "The language is, so the argument goes something like this.",
                    "label": 0
                },
                {
                    "sent": "We provide a syntax that for many people is more intuitive than the than the other existing languages because it inherited things from sparkle that people kind of use 2, and that's designed.",
                    "label": 0
                },
                {
                    "sent": "That's intuitive for graph pattern matching, and we want to see whether we can.",
                    "label": 0
                },
                {
                    "sent": "Like how far the performance we can provide in comparison to these existing languages so.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Of experiment was run it in node cluster and that's the result that our implementation is the last column, so it's good.",
                    "label": 0
                },
                {
                    "sent": "It's it's not the best hive still outperforms Hive, has many built-in optimizations for vectorized execution, etc.",
                    "label": 0
                },
                {
                    "sent": "So I think we can enhance the evaluation, but the implementation.",
                    "label": 0
                },
                {
                    "sent": "But the message of the evaluation was OK. We provide a new language more suitable for graph processing.",
                    "label": 0
                },
                {
                    "sent": "And we provide an implementation that provides results.",
                    "label": 0
                },
                {
                    "sent": "Now that's almost in the same range as Big Layton or Jackal.",
                    "label": 0
                },
                {
                    "sent": "Hive has been reported also, another results to outperform these languages.",
                    "label": 0
                },
                {
                    "sent": "But yeah, the implementation can be enhanced.",
                    "label": 0
                },
                {
                    "sent": "However, it's very comparison to what we will get from Jack Hill or from Pig Latin.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So to conclude, we defined RDF algebra as an underlying data model that is closed in comparison to Sparkle algebra.",
                    "label": 1
                },
                {
                    "sent": "This this has converted.",
                    "label": 0
                },
                {
                    "sent": "We compared the expressivity and we believe that it can has a far reaching.",
                    "label": 0
                },
                {
                    "sent": "It can be reused in other context and hopefully have a fruitful results in related fields.",
                    "label": 0
                },
                {
                    "sent": "And we highlighted caching like partial results reuse and view management as possible application area that we plan to.",
                    "label": 0
                },
                {
                    "sent": "But really, like work on as part of the future work and we also presented circle like the syntax and the language that's used defined on top of this data model.",
                    "label": 0
                },
                {
                    "sent": "So that's from my side.",
                    "label": 0
                },
                {
                    "sent": "Thanks for your attention.",
                    "label": 0
                },
                {
                    "sent": "Agency is so how big is the data that you evaluated?",
                    "label": 0
                },
                {
                    "sent": "How many triples and what's the size?",
                    "label": 0
                },
                {
                    "sent": "Tuition was running the 140 million travel.",
                    "label": 0
                },
                {
                    "sent": "That's not large scale, is it?",
                    "label": 0
                },
                {
                    "sent": "Yeah, it's not that huge data.",
                    "label": 0
                },
                {
                    "sent": "We convert the time we convert the event that evaluation plan.",
                    "label": 0
                },
                {
                    "sent": "So we looked at the.",
                    "label": 0
                },
                {
                    "sent": "We looked at the execution plan of each of these languages and we convert that as well.",
                    "label": 0
                },
                {
                    "sent": "And we have a compatible like evaluation plan in terms of number of these.",
                    "label": 0
                },
                {
                    "sent": "Yeah, I agree this is not huge data, but that's that's it.",
                    "label": 0
                },
                {
                    "sent": "In node cluster, all old machine that we have access to and that's the most we could run with it, but.",
                    "label": 0
                },
                {
                    "sent": "Yeah, point taken I think.",
                    "label": 0
                },
                {
                    "sent": "Like a bigger data would would also help.",
                    "label": 0
                },
                {
                    "sent": "Could you please give more details on why cannot you do joints on graphs and how is currently this being solved by by your language?",
                    "label": 0
                },
                {
                    "sent": "Please know you can.",
                    "label": 0
                },
                {
                    "sent": "You can do joins in graphs.",
                    "label": 0
                },
                {
                    "sent": "I want to say that.",
                    "label": 0
                },
                {
                    "sent": "Oh, so you cannot, for example, take two graphs and join them.",
                    "label": 0
                },
                {
                    "sent": "So if you have to do this in Sparkle, I was saying in the only way you do it is that if you have the whole graph you do I select star where SP or all of them are variable.",
                    "label": 0
                },
                {
                    "sent": "Yeah and then from the first graph and then you do the same for the second graph and then you get it.",
                    "label": 0
                },
                {
                    "sent": "So basically you can for example Union two graphs.",
                    "label": 0
                },
                {
                    "sent": "The only way to do is to do a select rabbit in a construct because there is also for select is a set of table.",
                    "label": 0
                },
                {
                    "sent": "If you want a graph that the union of two graphs, you do a select star from the one rabbit in a contract and then like Union the results with another.",
                    "label": 0
                },
                {
                    "sent": "Sorry union with another select and do a construct over all of them.",
                    "label": 0
                },
                {
                    "sent": "The problem is that union is defined on set of findings, not on graphs, so the input for a union can't be a graph and the only way to go from a graph to a set of bindings to apply a triple better.",
                    "label": 0
                },
                {
                    "sent": "Therefore, if you, if you have a graph, you have to do this trick where you do select start and then very often in sparkle you find this also people a lot like a pattern that you may be many like.",
                    "label": 0
                },
                {
                    "sent": "It's it's very common in literature to do to have a contract that has exactly the same body as the select and the only reason for that is that the select doesn't give you a graph and the only way to mimic this is to have everything that's in the body of the select repeated the body of the construct.",
                    "label": 0
                },
                {
                    "sent": "So there's a work work there are work arounds, but that's more code that's harder to optimize and harder to reason about four.",
                    "label": 0
                },
                {
                    "sent": "Engine and harder to read and harder to reuse.",
                    "label": 0
                },
                {
                    "sent": "OK, one more quick question.",
                    "label": 0
                },
                {
                    "sent": "Are your data is not so big?",
                    "label": 0
                },
                {
                    "sent": "150 million, 2% body.",
                    "label": 0
                },
                {
                    "sent": "It takes much times 60 minutes before querying processing.",
                    "label": 0
                },
                {
                    "sent": "I'm wondering why it takes so time when I look at your evaluation pages.",
                    "label": 0
                },
                {
                    "sent": "Yeah, this queries are really so this query is coming from the business intelligence use case, so these queries that usually touch most of the data and then do a lot of joint.",
                    "label": 0
                },
                {
                    "sent": "So I have a screenshot is not very so.",
                    "label": 0
                },
                {
                    "sent": "This is kind of that type of queries.",
                    "label": 0
                },
                {
                    "sent": "These are analytical queries that like touch most of the data and then needs to ship like most of the time will be taken by the joins that needs to be like it will ship between nodes.",
                    "label": 0
                },
                {
                    "sent": "Large amounts of data is just because that these are analytical queries that have really huge intermediate results, so most of the time was a network network time for shipping the data between the notes.",
                    "label": 0
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "Alright, let's thank the speaker again.",
                    "label": 0
                },
                {
                    "sent": "Thank you, fatty.",
                    "label": 0
                }
            ]
        }
    }
}