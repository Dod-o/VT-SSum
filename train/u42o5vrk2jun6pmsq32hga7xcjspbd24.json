{
    "id": "u42o5vrk2jun6pmsq32hga7xcjspbd24",
    "title": "Bipartite Graph Matching for Computing the Edit Distance of Graphs",
    "info": {
        "author": [
            "Kaspar Riesen, University of Bern"
        ],
        "published": "July 3, 2007",
        "recorded": "June 2007",
        "category": [
            "Top->Computer Science",
            "Top->Mathematics->Graph Theory"
        ]
    },
    "url": "http://videolectures.net/gbr07_riesen_bgm/",
    "segmentation": [
        [
            "OK.",
            "So my name is Kasper.",
            "Listen and I'm a PhD student of Professor Bunker at the University of Bern in Switzerland.",
            "So this talk here considers the general graph matching paradigm of graph edit distance.",
            "So first of all I will talk about graph edit distance, so graph matching paradigm then."
        ],
        [
            "And I will briefly talk about standard procedure for computing the graph.",
            "Edit distance by means of a tree search algorithm, and then next I will talk about more Chris algorithm, which is in fact an algorithm for solving the assignment problem in polynomial time complexity, and then our contribution here is that we adapt this algorithm for solving the assignment problem to the problem of graph edit distance.",
            "So I will talk about this.",
            "Then of course we will provide several experimental results that we have achieved.",
            "With our new algorithm for computing graph, edit distance and finally I will draw conclusions."
        ],
        [
            "So the main contribution of this talk or our work here is that we provide a very fast algorithm for computing graph edit distance and this algorithm is suboptimal in the sense of finding, not necessarily the exact graph edit distance.",
            "So."
        ],
        [
            "Suppose all of you notice standard definition of graphs, but nevertheless I mentioned it here for the sake of completeness.",
            "And there's one thing that I really want to point out here, and it is this concerns our label alphabet.",
            "So as you see, we have no restrictions concerning the label alphabet for both nodes and edges, so the labels can be out of a set of integers.",
            "Set of reals can be the real work to space.",
            "It can be a set of discrete symbols, or it can even be a combination of two or.",
            "More label alphabets.",
            "Hence the patterns or objects to be transformed into graph based representations are manifold and they range from physical or logical networks to images and chemical structures.",
            "So this flexibility in in our definition here is based in our graph matching parody."
        ],
        [
            "And that we apply.",
            "And this is graph edit distance.",
            "So in graph edit, distance, dissimilarity or the distance of two graphs is basically defined by the minimum amount of distortion that is needed to transform one graph into another.",
            "So in fact these distortions are given by edit operations and these edit operations consists of deletions, insertions and substitutions of both nodes and edges.",
            "So here's an example.",
            "We have two graphs, G1 and G2, so we have now an edit sequence which transform.",
            "G1 completely into T2 and such a sequence is commonly referred to as Edit Path."
        ],
        [
            "So we."
        ],
        [
            "Possibly delete some edges with."
        ],
        [
            "Leave some notes with."
        ],
        [
            "Insert note."
        ],
        [
            "So we insert it just and we substitute nodes and edges.",
            "So finally we have transformed Chaewon completely into G2.",
            "With this edit path, so of course not only one edit path exists between two rows by the number of different edit Pass.",
            "So for instance you can think of an edit path where you delete all the nodes edges in G1 and insert.",
            "Although its intentions in G2 it is would be possible Edit Path 2."
        ],
        [
            "So formally.",
            "The graph edit distance is defined as follows.",
            "Let us assume we have two graphs given G1 as the source graph and chi two as the target graph.",
            "Then the graph edit distance between the source and the target graph is given by the minimum cost edit path between the source and the target.",
            "So obviously what we have to define here is a cost function which measures the strength of a given edit operation OK and this.",
            "This is a cost function should of course.",
            "Reflect the intuition that two nodes, for instance with very different labels, should have higher costs than two substitution of two nodes with very similar labels.",
            "So we can."
        ],
        [
            "Conclude that graph edit Distance provides us with a very general dissimilarity model for graphs which can handle any kind of label alphabet."
        ],
        [
            "So let's consider now the possibilities we have for edit distance based classification, and we distinguish two different ways of edit distance based classification.",
            "So first of all, of course you can apply classifiers directly in the domain of graphs, but in fact if you do so, you are.",
            "Where I'm restricted to this and nearest neighbor classifiers.",
            "But however we can also define graph kernels based on the edit distance, so I name here 3.",
            "So for instance you can define a trivial graph kernel in conjunction with an SVM.",
            "So what you have to do is you have to change to transform your similarity of graph, edit distance into a similarity measure.",
            "This is an example here.",
            "What you can also do is you can extend standard graph kernels, for instance the random walk kernel with edit distance.",
            "So Michel Neuhaus has shown in his PhD that this is this might be a good idea.",
            "For instance the random walk edit kernel.",
            "And the third possibility you have with graph edit distance is that you use the information about gravity for graph edit distance to embed your graphs explicitly in a real vector space.",
            "So this will be the topic of my second talk on Wednesday."
        ],
        [
            "So for those of you who have already worked with gravity, distant distance, know that it's computational complexity is its major drawback.",
            "So in contrast with exact graph matching algorithms, the notes of the source graph can potentially be mapped to any node of the target graph, so this might be a problem and consequently the computational complexity for graph edit distance is exponential in the number of nodes of the involved graphs, so it's well known that for graphs with unique node labels, the complexity is linear, but we do not consider these graphs.",
            "Here we do consider general graphs.",
            "So the computation of graph edit distance is usually carried out by means of a tree search algorithm.",
            "So the idea is that you use the search tree as a representation formalism for the optimization problem.",
            "So the root node of this research represents the starting point of your search, and then in the nodes represent partial solutions and leaf nodes represents complete solutions means complete edit path transforming.",
            "One graph completely into the autograph."
        ],
        [
            "So since the complexity of exact graph edit distance is exponential in the number of nodes of the involved graphs, it's a matter of fact that exact graph edit distance is feasible for small graphs only.",
            "So, however, in order to speed up graph edit distance and make it also applicable to larger graphs, several suboptimal methods have been proposed."
        ],
        [
            "And in this work here we we introduce a new sub optimal method for graph edit distance based on the assignment problem.",
            "OK there."
        ],
        [
            "Classical assignment problem is.",
            "State does finding an optimal assignment of an elements of a set as 12 N elements of a set as two.",
            "So obviously we have to define a cost for each cost for each of these assignments.",
            "As you see here, and then the optimal assignment is then given by a permutation P of the integers 12 N that minimizes this sum here so."
        ],
        [
            "Normally we can state this assignment problem with the end times and cost matrix of real numbers, and each of these numbers corresponds to one assignment of one element of set, this one to one element of set as two.",
            "So the assignment problem can then be state it is finding a set of an independent elements of this cost matrix here such that the sum of these elements is a minimum.",
            "So in this example here that you see we have a cost matrix 3.",
            "Times 3 and we have all the possible independent sets permutations listed here and you have also the corresponding costs.",
            "So we see we have two.",
            "Possible assignments with minimum cost of 6.",
            "So of course, if you want to solve this assignment problem with a brute force algorithm, this will lead to a time complexity of an faculty, which is unreasonable."
        ],
        [
            "Course and in fact there is an algorithm for solving this problem in polynomial time complexity, so it finds.",
            "This algorithm, sorry I wait.",
            "OK, and so in fact this algorithm finds an end times N matrix and you matrix, which is equivalent to the initial one.",
            "The international cost matrix.",
            "But this new matrix has an independent zero elements and this an independent zero elements corresponds exactly to our assignments that we have found.",
            "So although the classical assignment problem considers two sets of equal size, monkey's algorithm can also be applied to two sets with different size.",
            "So for all technical details, we refer to our paper and."
        ],
        [
            "Here's a small example so that you have an idea how long Chris algorithm work.",
            "So as an input we have discussed matrix which represents the cost of all this possible assignments.",
            "Then what we are basically doing is we are adding and subtracting constants from lines, means rows and columns and then we mark independent sets of zeros with stars and remark possible candidates for the set with primes and finally after some transformations have been done, we have found a set of independence heroes marked with a star.",
            "We can look up the origin origonal cost matrix.",
            "The cost of this assignment and we see OK. We have found the optimal assignment 2 + 2 + 2 is cost 6 and we can match the two sets."
        ],
        [
            "So I think it's quite obvious that the problem of graph matching can be seen also as an assignment problem.",
            "So the question is how can we assign the notes of graph G1 to the notes of graph G2 such that the overall edit costs are minimal.",
            "So for instance here we are looking for the node assignment.",
            "OK, out of all possible node assignments which minimizes the sum of total total substitution costs.",
            "Oak."
        ],
        [
            "They do adapt now Monka's algorithm to the problem of graph edit distance.",
            "We have to define a cost matrix and OK will explain this here.",
            "Let us assume we have two graphs given T1 and T2 with node sets we one and V2.",
            "So then we have to define an end times and cost matrix where each entry in this cost matrix represents the cost of 1 node substitution of you see this.",
            "Here in this example.",
            "So obviously in this case here, this version of the algorithm, no information of the adjacent edges is taken to account.",
            "For building this cost matrix.",
            "And Furthermore, after we have found the optimal assignment of the nodes, we have to add possibly an minus N node insertions or the cost of these node insertions at the end.",
            "And Furthermore, since we are not considering the edges at all, we have to add at the end after we have found the optimal node assignment, the implied edge assignment and the costs are added to.",
            "So first we find an optimal node assignment.",
            "And then we are looking for the corresponding edge operations that have to be done."
        ],
        [
            "So to enhance the underlying cost matrix, we can use the information about the local structure of the graphs.",
            "This means for each entry and the cost matrix, we execute Moncus algorithm recursively for all the chase and edges of the corresponding nodes.",
            "This means that the entries in the cost matrix represent not only the cost for a node substitution.",
            "But also the minimum sum of costs of all adjacent edge substitutions can see you see this in the second line, and this minimized some can of course be computed by monkeys algorithm using an edge cost matrix.",
            "You see this in the example, not only the cost for node substitution, but also the costs for the minimum sum of total cost of the assignment of the edges.",
            "But here too, we have to add possibly an minasan node insertions at the end and after the optimal node assignment has been found we have to add the globally implied edge assignments also.",
            "So I think it's very important to see that this version of both versions of algorithms to compute graph edit distance is very fast, but it's also suboptimal in the sense of finding, not necessarily the exact graph edit distance, so monstrous algorithm.",
            "Find the optimal node assignment without considering the implied edge operations at all.",
            "This is in the plain version of our algorithm, or considering the local structure only, this is in the adjacent version of our algorithm, so the weather there one or the other is used to imply that operations have to be added at the end of the computation."
        ],
        [
            "So consequently, the node assignment and the implied it assignment found by our algorithm need not necessarily correspond to the exact gravity."
        ],
        [
            "Distance, so the crucial question is now whether or not the accuracy of the sub optimal distance that we found here remains sufficiently accurate for pattern recognition application, and this is exactly what we want to find out in our experiments.",
            "So here's the."
        ],
        [
            "Experimental setup.",
            "We use a KNN classifier in conjunction with graph edit distance, so optimal graph distance or exact graph edit distance and then we address classification problem.",
            "So we think that this classification accuracy given by the KNN classifier is a good indicator.",
            "How good or bad our approximation of the exact graph edit distance is.",
            "So we had several meta parameter values that we have to.",
            "We have to determine and to this end we use a validation set and the results that are reported next or applied on an independent test set.",
            "So we use three other systems to compare our new algorithm with first of all.",
            "Of course we use an optimal tree search based on a star implementation.",
            "We named this research and then we have also two suboptimal modifications of this standard tree search algorithm which we refer to as beam search and path length sonbeam search.",
            "What we are basically doing is we are pruning that research and in path length we making reweighting of the individual.",
            "Passes in the tree.",
            "OK."
        ],
        [
            "So here's the first data set we've used.",
            "This is the latter data set which consists of graphs representing capital letter line drawings out of 15 classes.",
            "So to construct these graphs, we first manually draw some prototype line drawings of each letter, and then we applied different distortion operators on this prototype line drawings and so we can obtain arbitrarily many drawings for each letter in arbitrarily high distortion levels.",
            "You see, we have applied.",
            "Quite high distortion level, so it's get it gets harder and harder to predict the real class and finally to convert these drawings into graphs, we represent lines by edges and ending points of lines by notes.",
            "So the results that you see here are achieved on a high distortion level.",
            "So first of all, you see that our algorithms both the plain version and also the chastened version are very fast, and they're much faster than the exact algorithm, and but they are also faster than the two suboptimal modifications being certain path length.",
            "So and when we are looking at the classification accuracy, we see that the classification accuracy is not negatively affected.",
            "So it is even increased and it is statistically significantly better.",
            "So when you first saw this, we were very surprised and thought, oh maybe something wrong here and but."
        ],
        [
            "I think we have found a good explanation for this phenomenon.",
            "So in this diagram here you see dots and distorts.",
            "Represents the graph edit distance between two graphs.",
            "So in the X axis you see the found exact edit distance between two graphs and in the Y axis you see the sub optimal distance found between two graphs.",
            "So as you see we distinguish between intra ask distances, the blue dots and these are distances found between two graphs out of the same class and.",
            "We have interclass distance is this are the red dots and these dots represent distances found between graphs out of different classes.",
            "So what we see is that the blue dots, the intraclass distances, are low, so they are low in the exact version, but also in the suboptimal version.",
            "And what is very important, they are not increased these distances by our suboptimal version.",
            "But when we are looking at the Inter class instances, they are quite high, so this is all right and they are even increased by the suboptimal version.",
            "OK, so to summarize, this means that the graphs in the domain of graphs are rearranged in respect to each other.",
            "OK, and to simplify this we can say that the classes are pulled apart from each other.",
            "And this is welcome effect regarding to classification tasks.",
            "So we do not claim that this happens on every data set, but it happens here.",
            "So to conclude, the suboptimality of our algorithm here mainly leads to an increase of interclass distances, while most of the intraclass distances are not strongly affected, and this is this is a good effect."
        ],
        [
            "So we have tested our algorithm on two other datasets, so the first is the image datasets which represent which consists of graphs representing images out of five classes.",
            "To convert these images into graphs, we first segment them into regions.",
            "Then we eliminate regions that were irrelevant for classification and then the remaining regions are represented by a region adjacency graph.",
            "So and again, here we see that our algorithm, the plain version is is faster than all the other systems that Jason Version is a bit slower, and this is due to the overhead for the computation of the adjacent information.",
            "And again we see that the classification accuracy is negatively affected, but it's not statistically significant."
        ],
        [
            "So in the last data set this team.",
            "Is the story.",
            "This fingerprint data set, which consists of graphs representing fingerprint images out of four classes.",
            "And to convert these fingerprints into graphs, we extract characteristic regions out of these fingerprints and then convert these regions into attributed graphs.",
            "So here we see that tree search, but also path links failed in computation due to the lack of memory and we have also applied only the plain version of our algorithm but not adjacent version.",
            "And this is the cause in this graph.",
            "Here all the important information is in the edges.",
            "So we apply our algorithm only on an edge cost matrix and it would be useless to use a chase in the information of the nodes since all the cost operations are set to 0.",
            "So, however, we see that our algorithm is much much faster than than all the other systems I have to say the reference method forgotten that is a method that we've used to have another reference system.",
            "This is a system proposed by Michel Neuhaus in his PhD, which is a sub optimal method too, but we see that our method is much faster than both suboptimal methods and the classification occurs.",
            "He is again not negatively affected."
        ],
        [
            "OK, and these were the results.",
            "I can say that we have tested this algorithm on many other data sets.",
            "Two in the mean time and it worked on all datasets and we have managed to apply these algorithms to graphs with up to 30 nodes and 60 edges and minimum.",
            "So I think it is applicable to quite large graphs.",
            "So before I draw conclusions, I want to report you that we have extended our algorithm in the mean time.",
            "So now our cost matrix considers the deletions and insertions of nodes explicitly.",
            "So you remember that I have told you that at the end of the computation of monkeys algorithm we have to add minus N node insertions.",
            "And in this version here we consider these node insertions node deletions explicitly.",
            "So we have to extend the cost matrix with M rows and columns.",
            "So then the right upper corner represents the cost of all possible node deletions.",
            "Of course you see this and the left bottom corner represents the cost of all possible node insertions.",
            "So I think with this version here that we apply now at our Institute we have increased the stability of this algorithm, but unfortunately the results in the paper are not conducted on this matrix, but on the other two versions.",
            "OK."
        ],
        [
            "So let me draw conclusions.",
            "Now I have 50 seconds.",
            "We propose a new suboptimum procedure for the computation of graph edit distance based on Moncrease algorithm.",
            "We have seen that this algorithm is much faster than the exact graph edit distance, but it's also faster data than other suboptimal methods.",
            "And as I told you before, our method can be applied to quite large growth, so they are not really large, but with 30 nodes and 60 edges.",
            "So it seems to be a quite good idea, and it was very surprisingly and it's very interesting point that the suboptimality of our algorithm mainly leads to an increase of interclass distances, while the intraclass distances are not strongly affected, or most of them are not strongly affected and.",
            "I think it's clear that these interclass distances are highly important for the classification task, so consequently the classification rates remain nearly unaffected or they are even increased.",
            "OK, so this was my talk.",
            "I thank you for your attention and."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "So my name is Kasper.",
                    "label": 0
                },
                {
                    "sent": "Listen and I'm a PhD student of Professor Bunker at the University of Bern in Switzerland.",
                    "label": 1
                },
                {
                    "sent": "So this talk here considers the general graph matching paradigm of graph edit distance.",
                    "label": 1
                },
                {
                    "sent": "So first of all I will talk about graph edit distance, so graph matching paradigm then.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And I will briefly talk about standard procedure for computing the graph.",
                    "label": 0
                },
                {
                    "sent": "Edit distance by means of a tree search algorithm, and then next I will talk about more Chris algorithm, which is in fact an algorithm for solving the assignment problem in polynomial time complexity, and then our contribution here is that we adapt this algorithm for solving the assignment problem to the problem of graph edit distance.",
                    "label": 0
                },
                {
                    "sent": "So I will talk about this.",
                    "label": 0
                },
                {
                    "sent": "Then of course we will provide several experimental results that we have achieved.",
                    "label": 0
                },
                {
                    "sent": "With our new algorithm for computing graph, edit distance and finally I will draw conclusions.",
                    "label": 1
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the main contribution of this talk or our work here is that we provide a very fast algorithm for computing graph edit distance and this algorithm is suboptimal in the sense of finding, not necessarily the exact graph edit distance.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Suppose all of you notice standard definition of graphs, but nevertheless I mentioned it here for the sake of completeness.",
                    "label": 0
                },
                {
                    "sent": "And there's one thing that I really want to point out here, and it is this concerns our label alphabet.",
                    "label": 0
                },
                {
                    "sent": "So as you see, we have no restrictions concerning the label alphabet for both nodes and edges, so the labels can be out of a set of integers.",
                    "label": 0
                },
                {
                    "sent": "Set of reals can be the real work to space.",
                    "label": 0
                },
                {
                    "sent": "It can be a set of discrete symbols, or it can even be a combination of two or.",
                    "label": 0
                },
                {
                    "sent": "More label alphabets.",
                    "label": 0
                },
                {
                    "sent": "Hence the patterns or objects to be transformed into graph based representations are manifold and they range from physical or logical networks to images and chemical structures.",
                    "label": 0
                },
                {
                    "sent": "So this flexibility in in our definition here is based in our graph matching parody.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And that we apply.",
                    "label": 0
                },
                {
                    "sent": "And this is graph edit distance.",
                    "label": 0
                },
                {
                    "sent": "So in graph edit, distance, dissimilarity or the distance of two graphs is basically defined by the minimum amount of distortion that is needed to transform one graph into another.",
                    "label": 1
                },
                {
                    "sent": "So in fact these distortions are given by edit operations and these edit operations consists of deletions, insertions and substitutions of both nodes and edges.",
                    "label": 0
                },
                {
                    "sent": "So here's an example.",
                    "label": 0
                },
                {
                    "sent": "We have two graphs, G1 and G2, so we have now an edit sequence which transform.",
                    "label": 0
                },
                {
                    "sent": "G1 completely into T2 and such a sequence is commonly referred to as Edit Path.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Possibly delete some edges with.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Leave some notes with.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Insert note.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So we insert it just and we substitute nodes and edges.",
                    "label": 1
                },
                {
                    "sent": "So finally we have transformed Chaewon completely into G2.",
                    "label": 1
                },
                {
                    "sent": "With this edit path, so of course not only one edit path exists between two rows by the number of different edit Pass.",
                    "label": 0
                },
                {
                    "sent": "So for instance you can think of an edit path where you delete all the nodes edges in G1 and insert.",
                    "label": 0
                },
                {
                    "sent": "Although its intentions in G2 it is would be possible Edit Path 2.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So formally.",
                    "label": 0
                },
                {
                    "sent": "The graph edit distance is defined as follows.",
                    "label": 1
                },
                {
                    "sent": "Let us assume we have two graphs given G1 as the source graph and chi two as the target graph.",
                    "label": 1
                },
                {
                    "sent": "Then the graph edit distance between the source and the target graph is given by the minimum cost edit path between the source and the target.",
                    "label": 1
                },
                {
                    "sent": "So obviously what we have to define here is a cost function which measures the strength of a given edit operation OK and this.",
                    "label": 0
                },
                {
                    "sent": "This is a cost function should of course.",
                    "label": 0
                },
                {
                    "sent": "Reflect the intuition that two nodes, for instance with very different labels, should have higher costs than two substitution of two nodes with very similar labels.",
                    "label": 0
                },
                {
                    "sent": "So we can.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Conclude that graph edit Distance provides us with a very general dissimilarity model for graphs which can handle any kind of label alphabet.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So let's consider now the possibilities we have for edit distance based classification, and we distinguish two different ways of edit distance based classification.",
                    "label": 1
                },
                {
                    "sent": "So first of all, of course you can apply classifiers directly in the domain of graphs, but in fact if you do so, you are.",
                    "label": 0
                },
                {
                    "sent": "Where I'm restricted to this and nearest neighbor classifiers.",
                    "label": 1
                },
                {
                    "sent": "But however we can also define graph kernels based on the edit distance, so I name here 3.",
                    "label": 1
                },
                {
                    "sent": "So for instance you can define a trivial graph kernel in conjunction with an SVM.",
                    "label": 0
                },
                {
                    "sent": "So what you have to do is you have to change to transform your similarity of graph, edit distance into a similarity measure.",
                    "label": 0
                },
                {
                    "sent": "This is an example here.",
                    "label": 0
                },
                {
                    "sent": "What you can also do is you can extend standard graph kernels, for instance the random walk kernel with edit distance.",
                    "label": 1
                },
                {
                    "sent": "So Michel Neuhaus has shown in his PhD that this is this might be a good idea.",
                    "label": 0
                },
                {
                    "sent": "For instance the random walk edit kernel.",
                    "label": 0
                },
                {
                    "sent": "And the third possibility you have with graph edit distance is that you use the information about gravity for graph edit distance to embed your graphs explicitly in a real vector space.",
                    "label": 0
                },
                {
                    "sent": "So this will be the topic of my second talk on Wednesday.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So for those of you who have already worked with gravity, distant distance, know that it's computational complexity is its major drawback.",
                    "label": 0
                },
                {
                    "sent": "So in contrast with exact graph matching algorithms, the notes of the source graph can potentially be mapped to any node of the target graph, so this might be a problem and consequently the computational complexity for graph edit distance is exponential in the number of nodes of the involved graphs, so it's well known that for graphs with unique node labels, the complexity is linear, but we do not consider these graphs.",
                    "label": 1
                },
                {
                    "sent": "Here we do consider general graphs.",
                    "label": 1
                },
                {
                    "sent": "So the computation of graph edit distance is usually carried out by means of a tree search algorithm.",
                    "label": 0
                },
                {
                    "sent": "So the idea is that you use the search tree as a representation formalism for the optimization problem.",
                    "label": 0
                },
                {
                    "sent": "So the root node of this research represents the starting point of your search, and then in the nodes represent partial solutions and leaf nodes represents complete solutions means complete edit path transforming.",
                    "label": 0
                },
                {
                    "sent": "One graph completely into the autograph.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So since the complexity of exact graph edit distance is exponential in the number of nodes of the involved graphs, it's a matter of fact that exact graph edit distance is feasible for small graphs only.",
                    "label": 0
                },
                {
                    "sent": "So, however, in order to speed up graph edit distance and make it also applicable to larger graphs, several suboptimal methods have been proposed.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And in this work here we we introduce a new sub optimal method for graph edit distance based on the assignment problem.",
                    "label": 0
                },
                {
                    "sent": "OK there.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Classical assignment problem is.",
                    "label": 0
                },
                {
                    "sent": "State does finding an optimal assignment of an elements of a set as 12 N elements of a set as two.",
                    "label": 1
                },
                {
                    "sent": "So obviously we have to define a cost for each cost for each of these assignments.",
                    "label": 1
                },
                {
                    "sent": "As you see here, and then the optimal assignment is then given by a permutation P of the integers 12 N that minimizes this sum here so.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Normally we can state this assignment problem with the end times and cost matrix of real numbers, and each of these numbers corresponds to one assignment of one element of set, this one to one element of set as two.",
                    "label": 0
                },
                {
                    "sent": "So the assignment problem can then be state it is finding a set of an independent elements of this cost matrix here such that the sum of these elements is a minimum.",
                    "label": 1
                },
                {
                    "sent": "So in this example here that you see we have a cost matrix 3.",
                    "label": 0
                },
                {
                    "sent": "Times 3 and we have all the possible independent sets permutations listed here and you have also the corresponding costs.",
                    "label": 0
                },
                {
                    "sent": "So we see we have two.",
                    "label": 0
                },
                {
                    "sent": "Possible assignments with minimum cost of 6.",
                    "label": 0
                },
                {
                    "sent": "So of course, if you want to solve this assignment problem with a brute force algorithm, this will lead to a time complexity of an faculty, which is unreasonable.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Course and in fact there is an algorithm for solving this problem in polynomial time complexity, so it finds.",
                    "label": 0
                },
                {
                    "sent": "This algorithm, sorry I wait.",
                    "label": 0
                },
                {
                    "sent": "OK, and so in fact this algorithm finds an end times N matrix and you matrix, which is equivalent to the initial one.",
                    "label": 1
                },
                {
                    "sent": "The international cost matrix.",
                    "label": 0
                },
                {
                    "sent": "But this new matrix has an independent zero elements and this an independent zero elements corresponds exactly to our assignments that we have found.",
                    "label": 0
                },
                {
                    "sent": "So although the classical assignment problem considers two sets of equal size, monkey's algorithm can also be applied to two sets with different size.",
                    "label": 0
                },
                {
                    "sent": "So for all technical details, we refer to our paper and.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here's a small example so that you have an idea how long Chris algorithm work.",
                    "label": 0
                },
                {
                    "sent": "So as an input we have discussed matrix which represents the cost of all this possible assignments.",
                    "label": 0
                },
                {
                    "sent": "Then what we are basically doing is we are adding and subtracting constants from lines, means rows and columns and then we mark independent sets of zeros with stars and remark possible candidates for the set with primes and finally after some transformations have been done, we have found a set of independence heroes marked with a star.",
                    "label": 0
                },
                {
                    "sent": "We can look up the origin origonal cost matrix.",
                    "label": 0
                },
                {
                    "sent": "The cost of this assignment and we see OK. We have found the optimal assignment 2 + 2 + 2 is cost 6 and we can match the two sets.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So I think it's quite obvious that the problem of graph matching can be seen also as an assignment problem.",
                    "label": 1
                },
                {
                    "sent": "So the question is how can we assign the notes of graph G1 to the notes of graph G2 such that the overall edit costs are minimal.",
                    "label": 1
                },
                {
                    "sent": "So for instance here we are looking for the node assignment.",
                    "label": 0
                },
                {
                    "sent": "OK, out of all possible node assignments which minimizes the sum of total total substitution costs.",
                    "label": 0
                },
                {
                    "sent": "Oak.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "They do adapt now Monka's algorithm to the problem of graph edit distance.",
                    "label": 0
                },
                {
                    "sent": "We have to define a cost matrix and OK will explain this here.",
                    "label": 1
                },
                {
                    "sent": "Let us assume we have two graphs given T1 and T2 with node sets we one and V2.",
                    "label": 0
                },
                {
                    "sent": "So then we have to define an end times and cost matrix where each entry in this cost matrix represents the cost of 1 node substitution of you see this.",
                    "label": 0
                },
                {
                    "sent": "Here in this example.",
                    "label": 0
                },
                {
                    "sent": "So obviously in this case here, this version of the algorithm, no information of the adjacent edges is taken to account.",
                    "label": 1
                },
                {
                    "sent": "For building this cost matrix.",
                    "label": 0
                },
                {
                    "sent": "And Furthermore, after we have found the optimal assignment of the nodes, we have to add possibly an minus N node insertions or the cost of these node insertions at the end.",
                    "label": 0
                },
                {
                    "sent": "And Furthermore, since we are not considering the edges at all, we have to add at the end after we have found the optimal node assignment, the implied edge assignment and the costs are added to.",
                    "label": 0
                },
                {
                    "sent": "So first we find an optimal node assignment.",
                    "label": 0
                },
                {
                    "sent": "And then we are looking for the corresponding edge operations that have to be done.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So to enhance the underlying cost matrix, we can use the information about the local structure of the graphs.",
                    "label": 0
                },
                {
                    "sent": "This means for each entry and the cost matrix, we execute Moncus algorithm recursively for all the chase and edges of the corresponding nodes.",
                    "label": 1
                },
                {
                    "sent": "This means that the entries in the cost matrix represent not only the cost for a node substitution.",
                    "label": 1
                },
                {
                    "sent": "But also the minimum sum of costs of all adjacent edge substitutions can see you see this in the second line, and this minimized some can of course be computed by monkeys algorithm using an edge cost matrix.",
                    "label": 0
                },
                {
                    "sent": "You see this in the example, not only the cost for node substitution, but also the costs for the minimum sum of total cost of the assignment of the edges.",
                    "label": 0
                },
                {
                    "sent": "But here too, we have to add possibly an minasan node insertions at the end and after the optimal node assignment has been found we have to add the globally implied edge assignments also.",
                    "label": 0
                },
                {
                    "sent": "So I think it's very important to see that this version of both versions of algorithms to compute graph edit distance is very fast, but it's also suboptimal in the sense of finding, not necessarily the exact graph edit distance, so monstrous algorithm.",
                    "label": 0
                },
                {
                    "sent": "Find the optimal node assignment without considering the implied edge operations at all.",
                    "label": 0
                },
                {
                    "sent": "This is in the plain version of our algorithm, or considering the local structure only, this is in the adjacent version of our algorithm, so the weather there one or the other is used to imply that operations have to be added at the end of the computation.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So consequently, the node assignment and the implied it assignment found by our algorithm need not necessarily correspond to the exact gravity.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Distance, so the crucial question is now whether or not the accuracy of the sub optimal distance that we found here remains sufficiently accurate for pattern recognition application, and this is exactly what we want to find out in our experiments.",
                    "label": 0
                },
                {
                    "sent": "So here's the.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Experimental setup.",
                    "label": 0
                },
                {
                    "sent": "We use a KNN classifier in conjunction with graph edit distance, so optimal graph distance or exact graph edit distance and then we address classification problem.",
                    "label": 1
                },
                {
                    "sent": "So we think that this classification accuracy given by the KNN classifier is a good indicator.",
                    "label": 0
                },
                {
                    "sent": "How good or bad our approximation of the exact graph edit distance is.",
                    "label": 1
                },
                {
                    "sent": "So we had several meta parameter values that we have to.",
                    "label": 0
                },
                {
                    "sent": "We have to determine and to this end we use a validation set and the results that are reported next or applied on an independent test set.",
                    "label": 0
                },
                {
                    "sent": "So we use three other systems to compare our new algorithm with first of all.",
                    "label": 1
                },
                {
                    "sent": "Of course we use an optimal tree search based on a star implementation.",
                    "label": 0
                },
                {
                    "sent": "We named this research and then we have also two suboptimal modifications of this standard tree search algorithm which we refer to as beam search and path length sonbeam search.",
                    "label": 0
                },
                {
                    "sent": "What we are basically doing is we are pruning that research and in path length we making reweighting of the individual.",
                    "label": 0
                },
                {
                    "sent": "Passes in the tree.",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So here's the first data set we've used.",
                    "label": 0
                },
                {
                    "sent": "This is the latter data set which consists of graphs representing capital letter line drawings out of 15 classes.",
                    "label": 1
                },
                {
                    "sent": "So to construct these graphs, we first manually draw some prototype line drawings of each letter, and then we applied different distortion operators on this prototype line drawings and so we can obtain arbitrarily many drawings for each letter in arbitrarily high distortion levels.",
                    "label": 0
                },
                {
                    "sent": "You see, we have applied.",
                    "label": 0
                },
                {
                    "sent": "Quite high distortion level, so it's get it gets harder and harder to predict the real class and finally to convert these drawings into graphs, we represent lines by edges and ending points of lines by notes.",
                    "label": 0
                },
                {
                    "sent": "So the results that you see here are achieved on a high distortion level.",
                    "label": 0
                },
                {
                    "sent": "So first of all, you see that our algorithms both the plain version and also the chastened version are very fast, and they're much faster than the exact algorithm, and but they are also faster than the two suboptimal modifications being certain path length.",
                    "label": 0
                },
                {
                    "sent": "So and when we are looking at the classification accuracy, we see that the classification accuracy is not negatively affected.",
                    "label": 1
                },
                {
                    "sent": "So it is even increased and it is statistically significantly better.",
                    "label": 0
                },
                {
                    "sent": "So when you first saw this, we were very surprised and thought, oh maybe something wrong here and but.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "I think we have found a good explanation for this phenomenon.",
                    "label": 0
                },
                {
                    "sent": "So in this diagram here you see dots and distorts.",
                    "label": 0
                },
                {
                    "sent": "Represents the graph edit distance between two graphs.",
                    "label": 0
                },
                {
                    "sent": "So in the X axis you see the found exact edit distance between two graphs and in the Y axis you see the sub optimal distance found between two graphs.",
                    "label": 0
                },
                {
                    "sent": "So as you see we distinguish between intra ask distances, the blue dots and these are distances found between two graphs out of the same class and.",
                    "label": 0
                },
                {
                    "sent": "We have interclass distance is this are the red dots and these dots represent distances found between graphs out of different classes.",
                    "label": 0
                },
                {
                    "sent": "So what we see is that the blue dots, the intraclass distances, are low, so they are low in the exact version, but also in the suboptimal version.",
                    "label": 0
                },
                {
                    "sent": "And what is very important, they are not increased these distances by our suboptimal version.",
                    "label": 0
                },
                {
                    "sent": "But when we are looking at the Inter class instances, they are quite high, so this is all right and they are even increased by the suboptimal version.",
                    "label": 0
                },
                {
                    "sent": "OK, so to summarize, this means that the graphs in the domain of graphs are rearranged in respect to each other.",
                    "label": 0
                },
                {
                    "sent": "OK, and to simplify this we can say that the classes are pulled apart from each other.",
                    "label": 0
                },
                {
                    "sent": "And this is welcome effect regarding to classification tasks.",
                    "label": 0
                },
                {
                    "sent": "So we do not claim that this happens on every data set, but it happens here.",
                    "label": 0
                },
                {
                    "sent": "So to conclude, the suboptimality of our algorithm here mainly leads to an increase of interclass distances, while most of the intraclass distances are not strongly affected, and this is this is a good effect.",
                    "label": 1
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So we have tested our algorithm on two other datasets, so the first is the image datasets which represent which consists of graphs representing images out of five classes.",
                    "label": 1
                },
                {
                    "sent": "To convert these images into graphs, we first segment them into regions.",
                    "label": 0
                },
                {
                    "sent": "Then we eliminate regions that were irrelevant for classification and then the remaining regions are represented by a region adjacency graph.",
                    "label": 0
                },
                {
                    "sent": "So and again, here we see that our algorithm, the plain version is is faster than all the other systems that Jason Version is a bit slower, and this is due to the overhead for the computation of the adjacent information.",
                    "label": 0
                },
                {
                    "sent": "And again we see that the classification accuracy is negatively affected, but it's not statistically significant.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So in the last data set this team.",
                    "label": 0
                },
                {
                    "sent": "Is the story.",
                    "label": 0
                },
                {
                    "sent": "This fingerprint data set, which consists of graphs representing fingerprint images out of four classes.",
                    "label": 1
                },
                {
                    "sent": "And to convert these fingerprints into graphs, we extract characteristic regions out of these fingerprints and then convert these regions into attributed graphs.",
                    "label": 0
                },
                {
                    "sent": "So here we see that tree search, but also path links failed in computation due to the lack of memory and we have also applied only the plain version of our algorithm but not adjacent version.",
                    "label": 0
                },
                {
                    "sent": "And this is the cause in this graph.",
                    "label": 0
                },
                {
                    "sent": "Here all the important information is in the edges.",
                    "label": 0
                },
                {
                    "sent": "So we apply our algorithm only on an edge cost matrix and it would be useless to use a chase in the information of the nodes since all the cost operations are set to 0.",
                    "label": 1
                },
                {
                    "sent": "So, however, we see that our algorithm is much much faster than than all the other systems I have to say the reference method forgotten that is a method that we've used to have another reference system.",
                    "label": 0
                },
                {
                    "sent": "This is a system proposed by Michel Neuhaus in his PhD, which is a sub optimal method too, but we see that our method is much faster than both suboptimal methods and the classification occurs.",
                    "label": 0
                },
                {
                    "sent": "He is again not negatively affected.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, and these were the results.",
                    "label": 0
                },
                {
                    "sent": "I can say that we have tested this algorithm on many other data sets.",
                    "label": 0
                },
                {
                    "sent": "Two in the mean time and it worked on all datasets and we have managed to apply these algorithms to graphs with up to 30 nodes and 60 edges and minimum.",
                    "label": 0
                },
                {
                    "sent": "So I think it is applicable to quite large graphs.",
                    "label": 0
                },
                {
                    "sent": "So before I draw conclusions, I want to report you that we have extended our algorithm in the mean time.",
                    "label": 0
                },
                {
                    "sent": "So now our cost matrix considers the deletions and insertions of nodes explicitly.",
                    "label": 1
                },
                {
                    "sent": "So you remember that I have told you that at the end of the computation of monkeys algorithm we have to add minus N node insertions.",
                    "label": 0
                },
                {
                    "sent": "And in this version here we consider these node insertions node deletions explicitly.",
                    "label": 0
                },
                {
                    "sent": "So we have to extend the cost matrix with M rows and columns.",
                    "label": 1
                },
                {
                    "sent": "So then the right upper corner represents the cost of all possible node deletions.",
                    "label": 0
                },
                {
                    "sent": "Of course you see this and the left bottom corner represents the cost of all possible node insertions.",
                    "label": 0
                },
                {
                    "sent": "So I think with this version here that we apply now at our Institute we have increased the stability of this algorithm, but unfortunately the results in the paper are not conducted on this matrix, but on the other two versions.",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So let me draw conclusions.",
                    "label": 0
                },
                {
                    "sent": "Now I have 50 seconds.",
                    "label": 0
                },
                {
                    "sent": "We propose a new suboptimum procedure for the computation of graph edit distance based on Moncrease algorithm.",
                    "label": 1
                },
                {
                    "sent": "We have seen that this algorithm is much faster than the exact graph edit distance, but it's also faster data than other suboptimal methods.",
                    "label": 0
                },
                {
                    "sent": "And as I told you before, our method can be applied to quite large growth, so they are not really large, but with 30 nodes and 60 edges.",
                    "label": 1
                },
                {
                    "sent": "So it seems to be a quite good idea, and it was very surprisingly and it's very interesting point that the suboptimality of our algorithm mainly leads to an increase of interclass distances, while the intraclass distances are not strongly affected, or most of them are not strongly affected and.",
                    "label": 0
                },
                {
                    "sent": "I think it's clear that these interclass distances are highly important for the classification task, so consequently the classification rates remain nearly unaffected or they are even increased.",
                    "label": 0
                },
                {
                    "sent": "OK, so this was my talk.",
                    "label": 0
                },
                {
                    "sent": "I thank you for your attention and.",
                    "label": 0
                }
            ]
        }
    }
}