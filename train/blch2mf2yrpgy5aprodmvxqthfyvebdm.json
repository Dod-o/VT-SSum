{
    "id": "blch2mf2yrpgy5aprodmvxqthfyvebdm",
    "title": "On learning regular expressions and patterns via membership and correction queries",
    "info": {
        "author": [
            "Efim Kinber, Sacred Heart University"
        ],
        "published": "Oct. 9, 2008",
        "recorded": "September 2008",
        "category": [
            "Top->Computer Science->Information Retrieval",
            "Top->Computer Science->Web Search"
        ]
    },
    "url": "http://videolectures.net/icgi08_kinber_olre/",
    "segmentation": [
        [
            "So we move to the next tool given by.",
            "I think Kimber and going to be on running regular expression and patterns via membership and correction queries.",
            "Well, OK. Um?",
            "Well, probably everyone in this room would agree that when it comes to learning.",
            "From examples, DFA probably is much more popular type of concept than.",
            "Regular expressions, however regular expressions seem to be much more suitable when it comes to understanding and learning regular languages from examples by human beings, and recently regular expressions have been successfully used also for learning.",
            "For presenting some practical learning tasks, for example for learning XML schema definition patterns also have been known as a good type of.",
            "Concepts presenting some learning tasks well.",
            "This research might go well.",
            "The algorithms that are suggested in this research don't really have immediate consequences in terms of.",
            "Practical learning methods.",
            "My goal in this research is rather maybe to spur more debate.",
            "More discussion on learnability of these two important classes of concepts."
        ],
        [
            "Now let me present the learning model being used in this research.",
            "It is so called well known query model where learning process is communication between the learner and the teacher.",
            "Formally an Oracle.",
            "The learner asks different types of questions and teacher returns appropriate answers.",
            "In this model in this research.",
            "We can see there are two types of queries membership queries.",
            "Where the learner asks if a particular string belongs to the target language and gets the answer yes or no and so called correction queries.",
            "Correction queries are similar to.",
            "Membership queries, but in case of negative answer the teacher returns also.",
            "Correction, a string closest in some way to the query string.",
            "So in this model learner asks a finite number of queries and returns at description for the target language, which may be what regular expression or DFA or a pattern.",
            "So the first conjecture it's not learning.",
            "In the limit, the first conjecture must be the correct one."
        ],
        [
            "Now let me clarify what kind of Corrections are being used in this research.",
            "There are several restrictions on the type of correction.",
            "First of all, every next correction must be not seen in the learning process so far.",
            "The correction must be the shortest edit distance from the given string from the given query string, and at this time preference is given to corrections of the same length as the query string.",
            "That is, if there is no such correction, then of course the teacher would return correction of a different.",
            "Lens, but if there exists one and this correction must be returned.",
            "Also, the correction must be smallest in the lexicographic order among those satisfying the above condition though this.",
            "Condition may be slightly relaxed.",
            "I will talk about this later.",
            "Originally corrections were suggested as shortest extensions of the query string introduced by this by this authors.",
            "I want to repeat their names.",
            "To make some mispronunciations for learning DFA's, then also for learning key reversible languages and patterns corrections that the shortest edit distance were introduced by this group of four.",
            "However, unlike.",
            "Corrections in my research, there were no particular restrictions on the type of Corrections queries returns in case of shortly stated distance."
        ],
        [
            "Now let me present the class of regular expressions that I worked with.",
            "As you can see regularly this regular expressions.",
            "Use Luke depth one.",
            "They use plus rather than cleaning star.",
            "There are no unions.",
            "An example of this expression you can see that in the middle of the slide, and the expressions must satisfy two more conditions.",
            "First of all, they must be left aligned, which means that every loop must be shifted to the left as much as possible, and the second condition is that there should be no subexpressions of the type given.",
            "On the slide, which means that there shouldn't be.",
            "Expressions neighboring expressions that use same.",
            "Different repetitions of the same.",
            "But of the same body."
        ],
        [
            "Now.",
            "For learning this class of expressions, my algorithm uses one correction query queries if empty string belongs to the target language, and the goal of it is just to find the shortest string.",
            "And then it proceeds using just membership query.",
            "So in fact if we use membership queries to find the shortest ring, then we wouldn't even need correction query.",
            "Any correction query in this case.",
            "But of course in this case we would need many more membership queries just to find the shortest tree.",
            "Then it proceeds."
        ],
        [
            "Um?",
            "With membership queries as I said, and here is an example of how this algorithm works on the first step it finds all loops of length one and the principle is very simple.",
            "It simply finds longest strings consisting of 1 character and then adds one extra copy of such character and makes a query.",
            "Now if the answer is positive, then obviously there there is a loop.",
            "There is a loop there.",
            "OK, so on this step the algorithm is pretty primitive.",
            "So well, maybe.",
            "Take a look at this expression.",
            "This is kind of intermediate result.",
            "After finding all loops of.",
            "Corresponding to one letter."
        ],
        [
            "Now here you can see kind of crucial part of the algorithm.",
            "Now we have this intermediate expression and we need to find loops of lengths to and then loops of length three loops of length four, etc.",
            "But I'm giving only loops of links to.",
            "Now what we do we find again the longest substrings.",
            "That are repetitions of.",
            "Two letter substrings and then we insert a copy.",
            "One extra copy of such two letter substring.",
            "However, there is a complication becausw like in this example.",
            "This extra copy could have been contributed by two letter loop on the right, for example by this loop.",
            "OK, now how to prevent this influence from happening?",
            "What you can do you can build a wall and that's what is done in this example kind of fence if you will.",
            "Between this alleged loop and.",
            "The possible loop on the right now if we unfold if we unfold this loop one time, this is enough.",
            "And if the answer is positive.",
            "One can show that in this case this extra copy is really resulting from just this first loop, and so we can claim that when we create this loop, this is really the loop that is needed in this case.",
            "Well, actually I meant that one now.",
            "Similarly, we insert one extra copy of string KB here.",
            "And again we have to build these two fences, this time on the left.",
            "That is expanding.",
            "Expanding this loop and then also on the right expanding.",
            "Unfolding this loop again, the reason is the same.",
            "We want to prevent influence from loops.",
            "From this loop and from possibility of a loop here we don't know if there is a one because we have not created a loop of links to there yet, but there is a possibility.",
            "So to prevent this from happening.",
            "We expand this too.",
            "One letter loop and thus we arrive to this new conjecture and then the algorithm proceeds further.",
            "So the key point of this algorithm is.",
            "Expanding this neighboring loops on the left and on the right in the current conjecture to prevent the influence of possible loops of the same size on the left and on the right.",
            "The proof of the correctness of this algorithm is presented in the paper."
        ],
        [
            "Now of complexity of the algorithm running time is bigoven thieves number of queries big O of N cube where N is the length of the target expression or equivalent with the length of the shortest example."
        ],
        [
            "No.",
            "Some discussion on this algorithm.",
            "I can transform this algorithm to a similar algorithm using cleaning star instead of plus, but in this case I can be lonely with one letter loops and I need also non empty strings between any two loops.",
            "Here is an example of expression of such an expression and this class is similar.",
            "Or rather I should say maybe.",
            "Resembles a class considered by Hanging Fernow learnable.",
            "He learns in the limit from positive data.",
            "It's in old paper, two or three, I guess right?",
            "And though in that glass he uses also unions, while in my class of course there are no union.",
            "Now what I want to mention here is that most of the classes of regular expressions considered literature are so called deterministic regular expressions or they are also called one unambiguous expressions, which essentially means that every string can be obtained only in one.",
            "Way while in my class of regular expressions.",
            "Any string can be not any but some strings can be obtained in various ways, so that's that's the difference."
        ],
        [
            "Now in the second part of my talk, I will consider learning patterns.",
            "Patterns is a very well known class.",
            "So I probably want to add anything to that.",
            "An example of a pattern is a string.",
            "Over the Alphabet Union of Sigma alphabet of constants and accountable set of variables.",
            "Here is an example of a pattern now as string in the language represented by the pattern is obtained by substitution of variables by strings in the alphabet.",
            "Sigma and non empty strings.",
            "Well we consider so-called non erasable patterns where.",
            "Every substitution is nonempty.",
            "The erasable patterns.",
            "It's completely different world.",
            "So making this substitution, we get the following string and the language consists of all such strings now."
        ],
        [
            "Learning patterns is a very hard problem.",
            "First, even membership problem for patterns is known to be NP hard, so well known, resolved within Angwin inclusion problem which could be helpful for example for learning patterns in the limit.",
            "Unfortunately also is well not also, but I mean is an decidable equivalence problem for patterns is decidable in linear.",
            "Time, but but unfortunately it doesn't help much.",
            "Learnability of patterns have been studied under various protocols quite widely.",
            "And recently I want to mention just this work by turn OK on learning patterns from queries where correction is the shortest extension of the query string.",
            "It's kind of was inspiration for my work in some respect.",
            "And learning ability is known to be at light to various practical problems, including learning, for example via main structure.",
            "There is a good survey by Shinohara and very cover on that matter.",
            "Whoever is interested."
        ],
        [
            "Now, um.",
            "So.",
            "Well, how much time do I have?",
            "7 minutes, something OK then I will have to speed it up a little bit anyway.",
            "Here is an example of.",
            "Pattern to find the first, we want to find the shortest string, shortest string rather.",
            "Querying if empty string belongs to the target language.",
            "Then we get the correction string, which because of the fact that we give the shortest in the lexicographic order, the string is.",
            "The string contains the largest number of zeros possible.",
            "Now then we query the string consisting of all once and then we get this correction string.",
            "Now it's easy to see that these two queries actually determine.",
            "All the constants and what remains is to find all the variables we know.",
            "Now the links of the pattern we need to find all the variables.",
            "So what we do we use some sort of placeholder representing all variables and now the algorithm valger."
        ],
        [
            "Some start finding variables.",
            "So first we try 1.",
            "Trying.",
            "Kind of guessing that.",
            "We have just one occurrence of 1 variable on the first position and if we get the answer, yes, this guess is right.",
            "It's really only one possibility here that X is a variable in the run.",
            "No occurrences of this variable in the expression.",
            "Then we try the same for the position 4.",
            "Again, the answer is positive and that convinces us that.",
            "Why is the only possibility for this new variable?",
            "Now we try one for the fifth position, using zeros wherever it is possible, But in this case the answer is no, but correction unfortunately for the algorithm.",
            "Unfortunately, at this moment gives you.",
            "These values of 1 and we already know that they are values of the variables X&Y, so there is no much help here, so we have to try it over again and we use now.",
            "This variables these values for this variables and try one over again for this now.",
            "This time the correction string again, it is smallest in lexicographic order.",
            "The correction string returns three values one.",
            "At the end and it still leaves all the ones that we already found.",
            "Well, it's not easy to see that this means that these three values represent occurrences of the same variable, so that's what we do.",
            "We add this variable at the end of the."
        ],
        [
            "Suppression now maybe a couple more.",
            "Steps so here is our current conjecture.",
            "Now we query one for the fifth position one more time.",
            "We have not succeeded yet with the fixed position and this time correction string is this one.",
            "So this gives us opportunity to add one more variable Z for this four positions and the last query which brings us.",
            "The final result, which is this.",
            "Expression."
        ],
        [
            "Now one more example, on the surface it's very simple, but it's just to demonstrate that in some cases, since the algorithm gets correction query.",
            "Gets the correction string that is longer than the.",
            "Size of the pattern, and this happens when there are no other correction strings available of this length.",
            "OK, so in some cases you get a longer string and when you get a longest drink, this is the end of the story.",
            "The end of the algorithm.",
            "Because this means that all placeholders represent values of the same variable, so we use we create the last variable and the algorithm stops at this.",
            "So the proof of this game is presented in the paper.",
            "I cannot elaborate unfortunately."
        ],
        [
            "Now running time of the algorithm is an cubed number of queries is N squared, where M is the length of the target pattern.",
            "Very."
        ],
        [
            "But I'm coming to the last flight, actually.",
            "Now.",
            "Some discussion on this algorithm and some modifications expansions possible and some related problem.",
            "First of all, the algorithm can be extended.",
            "I'm positive about that though.",
            "There is no word about this in the paper yet.",
            "I'm positive that the algorithm can be extended for an arbitrary alphabet Sigma, and it is very important for patterns because even though most of the known algorithms work for two letter alphabet for patterns, when it comes to practical applications, if any, then actually the larger the alphabet the better for practical applications, so that's that's probably an important thing now.",
            "Why corrections of the same length?",
            "Well, many years ago, one game week again when they presented their algorithm for learning patterns in the inductive inference paradigm, they actually showed that once you found the shortest string in the language, then strings of arbitrary links become essentially irrelevant for.",
            "For learning at that and so I kind of follow the same idea here.",
            "Now as I promised requirement of using quick psychographically smallest shortest example can be slightly relaxed in the following sense.",
            "If the teacher returns string that contains the largest number of zeros, it's enough.",
            "And of course the main question here is how far we can relax this conditions imposed on correction queries.",
            "Well, I started this problem.",
            "For quite awhile my conjecture is that patterns cannot be learned in polynomial time.",
            "Unfortunately, using corrections and the shortest distance with no constraints.",
            "On the correction string.",
            "Unfortunately though, I have not been able to prove this one way or the other.",
            "OK, thank you, thank you.",
            "Questions.",
            "Yes.",
            "Did you eat your non ambiguity of your regular expressions enrolled in your learning algorithm?",
            "With your example, I think that's true in a sense, but it could be easily transformed by shifting balloons a little bit further to the left and right basically into something which is sort of dynamic with our our deterministic well.",
            "For this particular example, yes, but I have to think about this.",
            "I'm not sure that it would be possible.",
            "For any arbitrary example, though, this is an interesting question that you are asking.",
            "Somewhere I'm under the impression that.",
            "As far as I know, regular expressions are basically give you class of whatever sort of paradigm is in the back.",
            "If you passed or breaker languages.",
            "The specific property that you can quite easily transform those regular expression into DFA which have beta same size.",
            "It might be true.",
            "I am not sure about that.",
            "I I have to think about this.",
            "Well, formally speaking, the class is is not deterministic.",
            "It seems to me at least.",
            "Yeah, but but you may be right.",
            "I have to think about this."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So we move to the next tool given by.",
                    "label": 0
                },
                {
                    "sent": "I think Kimber and going to be on running regular expression and patterns via membership and correction queries.",
                    "label": 1
                },
                {
                    "sent": "Well, OK. Um?",
                    "label": 0
                },
                {
                    "sent": "Well, probably everyone in this room would agree that when it comes to learning.",
                    "label": 0
                },
                {
                    "sent": "From examples, DFA probably is much more popular type of concept than.",
                    "label": 0
                },
                {
                    "sent": "Regular expressions, however regular expressions seem to be much more suitable when it comes to understanding and learning regular languages from examples by human beings, and recently regular expressions have been successfully used also for learning.",
                    "label": 0
                },
                {
                    "sent": "For presenting some practical learning tasks, for example for learning XML schema definition patterns also have been known as a good type of.",
                    "label": 0
                },
                {
                    "sent": "Concepts presenting some learning tasks well.",
                    "label": 0
                },
                {
                    "sent": "This research might go well.",
                    "label": 0
                },
                {
                    "sent": "The algorithms that are suggested in this research don't really have immediate consequences in terms of.",
                    "label": 0
                },
                {
                    "sent": "Practical learning methods.",
                    "label": 0
                },
                {
                    "sent": "My goal in this research is rather maybe to spur more debate.",
                    "label": 0
                },
                {
                    "sent": "More discussion on learnability of these two important classes of concepts.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now let me present the learning model being used in this research.",
                    "label": 0
                },
                {
                    "sent": "It is so called well known query model where learning process is communication between the learner and the teacher.",
                    "label": 0
                },
                {
                    "sent": "Formally an Oracle.",
                    "label": 0
                },
                {
                    "sent": "The learner asks different types of questions and teacher returns appropriate answers.",
                    "label": 0
                },
                {
                    "sent": "In this model in this research.",
                    "label": 0
                },
                {
                    "sent": "We can see there are two types of queries membership queries.",
                    "label": 0
                },
                {
                    "sent": "Where the learner asks if a particular string belongs to the target language and gets the answer yes or no and so called correction queries.",
                    "label": 1
                },
                {
                    "sent": "Correction queries are similar to.",
                    "label": 0
                },
                {
                    "sent": "Membership queries, but in case of negative answer the teacher returns also.",
                    "label": 1
                },
                {
                    "sent": "Correction, a string closest in some way to the query string.",
                    "label": 0
                },
                {
                    "sent": "So in this model learner asks a finite number of queries and returns at description for the target language, which may be what regular expression or DFA or a pattern.",
                    "label": 1
                },
                {
                    "sent": "So the first conjecture it's not learning.",
                    "label": 0
                },
                {
                    "sent": "In the limit, the first conjecture must be the correct one.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now let me clarify what kind of Corrections are being used in this research.",
                    "label": 0
                },
                {
                    "sent": "There are several restrictions on the type of correction.",
                    "label": 0
                },
                {
                    "sent": "First of all, every next correction must be not seen in the learning process so far.",
                    "label": 1
                },
                {
                    "sent": "The correction must be the shortest edit distance from the given string from the given query string, and at this time preference is given to corrections of the same length as the query string.",
                    "label": 1
                },
                {
                    "sent": "That is, if there is no such correction, then of course the teacher would return correction of a different.",
                    "label": 0
                },
                {
                    "sent": "Lens, but if there exists one and this correction must be returned.",
                    "label": 1
                },
                {
                    "sent": "Also, the correction must be smallest in the lexicographic order among those satisfying the above condition though this.",
                    "label": 1
                },
                {
                    "sent": "Condition may be slightly relaxed.",
                    "label": 0
                },
                {
                    "sent": "I will talk about this later.",
                    "label": 0
                },
                {
                    "sent": "Originally corrections were suggested as shortest extensions of the query string introduced by this by this authors.",
                    "label": 0
                },
                {
                    "sent": "I want to repeat their names.",
                    "label": 0
                },
                {
                    "sent": "To make some mispronunciations for learning DFA's, then also for learning key reversible languages and patterns corrections that the shortest edit distance were introduced by this group of four.",
                    "label": 0
                },
                {
                    "sent": "However, unlike.",
                    "label": 0
                },
                {
                    "sent": "Corrections in my research, there were no particular restrictions on the type of Corrections queries returns in case of shortly stated distance.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now let me present the class of regular expressions that I worked with.",
                    "label": 1
                },
                {
                    "sent": "As you can see regularly this regular expressions.",
                    "label": 0
                },
                {
                    "sent": "Use Luke depth one.",
                    "label": 0
                },
                {
                    "sent": "They use plus rather than cleaning star.",
                    "label": 0
                },
                {
                    "sent": "There are no unions.",
                    "label": 1
                },
                {
                    "sent": "An example of this expression you can see that in the middle of the slide, and the expressions must satisfy two more conditions.",
                    "label": 0
                },
                {
                    "sent": "First of all, they must be left aligned, which means that every loop must be shifted to the left as much as possible, and the second condition is that there should be no subexpressions of the type given.",
                    "label": 0
                },
                {
                    "sent": "On the slide, which means that there shouldn't be.",
                    "label": 0
                },
                {
                    "sent": "Expressions neighboring expressions that use same.",
                    "label": 0
                },
                {
                    "sent": "Different repetitions of the same.",
                    "label": 0
                },
                {
                    "sent": "But of the same body.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now.",
                    "label": 0
                },
                {
                    "sent": "For learning this class of expressions, my algorithm uses one correction query queries if empty string belongs to the target language, and the goal of it is just to find the shortest string.",
                    "label": 1
                },
                {
                    "sent": "And then it proceeds using just membership query.",
                    "label": 0
                },
                {
                    "sent": "So in fact if we use membership queries to find the shortest ring, then we wouldn't even need correction query.",
                    "label": 1
                },
                {
                    "sent": "Any correction query in this case.",
                    "label": 0
                },
                {
                    "sent": "But of course in this case we would need many more membership queries just to find the shortest tree.",
                    "label": 0
                },
                {
                    "sent": "Then it proceeds.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Um?",
                    "label": 0
                },
                {
                    "sent": "With membership queries as I said, and here is an example of how this algorithm works on the first step it finds all loops of length one and the principle is very simple.",
                    "label": 1
                },
                {
                    "sent": "It simply finds longest strings consisting of 1 character and then adds one extra copy of such character and makes a query.",
                    "label": 1
                },
                {
                    "sent": "Now if the answer is positive, then obviously there there is a loop.",
                    "label": 0
                },
                {
                    "sent": "There is a loop there.",
                    "label": 0
                },
                {
                    "sent": "OK, so on this step the algorithm is pretty primitive.",
                    "label": 0
                },
                {
                    "sent": "So well, maybe.",
                    "label": 0
                },
                {
                    "sent": "Take a look at this expression.",
                    "label": 0
                },
                {
                    "sent": "This is kind of intermediate result.",
                    "label": 0
                },
                {
                    "sent": "After finding all loops of.",
                    "label": 0
                },
                {
                    "sent": "Corresponding to one letter.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now here you can see kind of crucial part of the algorithm.",
                    "label": 0
                },
                {
                    "sent": "Now we have this intermediate expression and we need to find loops of lengths to and then loops of length three loops of length four, etc.",
                    "label": 0
                },
                {
                    "sent": "But I'm giving only loops of links to.",
                    "label": 0
                },
                {
                    "sent": "Now what we do we find again the longest substrings.",
                    "label": 0
                },
                {
                    "sent": "That are repetitions of.",
                    "label": 0
                },
                {
                    "sent": "Two letter substrings and then we insert a copy.",
                    "label": 0
                },
                {
                    "sent": "One extra copy of such two letter substring.",
                    "label": 0
                },
                {
                    "sent": "However, there is a complication becausw like in this example.",
                    "label": 0
                },
                {
                    "sent": "This extra copy could have been contributed by two letter loop on the right, for example by this loop.",
                    "label": 0
                },
                {
                    "sent": "OK, now how to prevent this influence from happening?",
                    "label": 0
                },
                {
                    "sent": "What you can do you can build a wall and that's what is done in this example kind of fence if you will.",
                    "label": 0
                },
                {
                    "sent": "Between this alleged loop and.",
                    "label": 0
                },
                {
                    "sent": "The possible loop on the right now if we unfold if we unfold this loop one time, this is enough.",
                    "label": 0
                },
                {
                    "sent": "And if the answer is positive.",
                    "label": 0
                },
                {
                    "sent": "One can show that in this case this extra copy is really resulting from just this first loop, and so we can claim that when we create this loop, this is really the loop that is needed in this case.",
                    "label": 0
                },
                {
                    "sent": "Well, actually I meant that one now.",
                    "label": 0
                },
                {
                    "sent": "Similarly, we insert one extra copy of string KB here.",
                    "label": 0
                },
                {
                    "sent": "And again we have to build these two fences, this time on the left.",
                    "label": 0
                },
                {
                    "sent": "That is expanding.",
                    "label": 0
                },
                {
                    "sent": "Expanding this loop and then also on the right expanding.",
                    "label": 0
                },
                {
                    "sent": "Unfolding this loop again, the reason is the same.",
                    "label": 0
                },
                {
                    "sent": "We want to prevent influence from loops.",
                    "label": 0
                },
                {
                    "sent": "From this loop and from possibility of a loop here we don't know if there is a one because we have not created a loop of links to there yet, but there is a possibility.",
                    "label": 0
                },
                {
                    "sent": "So to prevent this from happening.",
                    "label": 0
                },
                {
                    "sent": "We expand this too.",
                    "label": 0
                },
                {
                    "sent": "One letter loop and thus we arrive to this new conjecture and then the algorithm proceeds further.",
                    "label": 0
                },
                {
                    "sent": "So the key point of this algorithm is.",
                    "label": 1
                },
                {
                    "sent": "Expanding this neighboring loops on the left and on the right in the current conjecture to prevent the influence of possible loops of the same size on the left and on the right.",
                    "label": 1
                },
                {
                    "sent": "The proof of the correctness of this algorithm is presented in the paper.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now of complexity of the algorithm running time is bigoven thieves number of queries big O of N cube where N is the length of the target expression or equivalent with the length of the shortest example.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "No.",
                    "label": 0
                },
                {
                    "sent": "Some discussion on this algorithm.",
                    "label": 0
                },
                {
                    "sent": "I can transform this algorithm to a similar algorithm using cleaning star instead of plus, but in this case I can be lonely with one letter loops and I need also non empty strings between any two loops.",
                    "label": 1
                },
                {
                    "sent": "Here is an example of expression of such an expression and this class is similar.",
                    "label": 0
                },
                {
                    "sent": "Or rather I should say maybe.",
                    "label": 1
                },
                {
                    "sent": "Resembles a class considered by Hanging Fernow learnable.",
                    "label": 1
                },
                {
                    "sent": "He learns in the limit from positive data.",
                    "label": 1
                },
                {
                    "sent": "It's in old paper, two or three, I guess right?",
                    "label": 0
                },
                {
                    "sent": "And though in that glass he uses also unions, while in my class of course there are no union.",
                    "label": 0
                },
                {
                    "sent": "Now what I want to mention here is that most of the classes of regular expressions considered literature are so called deterministic regular expressions or they are also called one unambiguous expressions, which essentially means that every string can be obtained only in one.",
                    "label": 0
                },
                {
                    "sent": "Way while in my class of regular expressions.",
                    "label": 0
                },
                {
                    "sent": "Any string can be not any but some strings can be obtained in various ways, so that's that's the difference.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now in the second part of my talk, I will consider learning patterns.",
                    "label": 0
                },
                {
                    "sent": "Patterns is a very well known class.",
                    "label": 0
                },
                {
                    "sent": "So I probably want to add anything to that.",
                    "label": 0
                },
                {
                    "sent": "An example of a pattern is a string.",
                    "label": 1
                },
                {
                    "sent": "Over the Alphabet Union of Sigma alphabet of constants and accountable set of variables.",
                    "label": 1
                },
                {
                    "sent": "Here is an example of a pattern now as string in the language represented by the pattern is obtained by substitution of variables by strings in the alphabet.",
                    "label": 0
                },
                {
                    "sent": "Sigma and non empty strings.",
                    "label": 0
                },
                {
                    "sent": "Well we consider so-called non erasable patterns where.",
                    "label": 0
                },
                {
                    "sent": "Every substitution is nonempty.",
                    "label": 0
                },
                {
                    "sent": "The erasable patterns.",
                    "label": 1
                },
                {
                    "sent": "It's completely different world.",
                    "label": 0
                },
                {
                    "sent": "So making this substitution, we get the following string and the language consists of all such strings now.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Learning patterns is a very hard problem.",
                    "label": 0
                },
                {
                    "sent": "First, even membership problem for patterns is known to be NP hard, so well known, resolved within Angwin inclusion problem which could be helpful for example for learning patterns in the limit.",
                    "label": 0
                },
                {
                    "sent": "Unfortunately also is well not also, but I mean is an decidable equivalence problem for patterns is decidable in linear.",
                    "label": 0
                },
                {
                    "sent": "Time, but but unfortunately it doesn't help much.",
                    "label": 1
                },
                {
                    "sent": "Learnability of patterns have been studied under various protocols quite widely.",
                    "label": 0
                },
                {
                    "sent": "And recently I want to mention just this work by turn OK on learning patterns from queries where correction is the shortest extension of the query string.",
                    "label": 1
                },
                {
                    "sent": "It's kind of was inspiration for my work in some respect.",
                    "label": 1
                },
                {
                    "sent": "And learning ability is known to be at light to various practical problems, including learning, for example via main structure.",
                    "label": 0
                },
                {
                    "sent": "There is a good survey by Shinohara and very cover on that matter.",
                    "label": 0
                },
                {
                    "sent": "Whoever is interested.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now, um.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "Well, how much time do I have?",
                    "label": 0
                },
                {
                    "sent": "7 minutes, something OK then I will have to speed it up a little bit anyway.",
                    "label": 0
                },
                {
                    "sent": "Here is an example of.",
                    "label": 0
                },
                {
                    "sent": "Pattern to find the first, we want to find the shortest string, shortest string rather.",
                    "label": 1
                },
                {
                    "sent": "Querying if empty string belongs to the target language.",
                    "label": 1
                },
                {
                    "sent": "Then we get the correction string, which because of the fact that we give the shortest in the lexicographic order, the string is.",
                    "label": 0
                },
                {
                    "sent": "The string contains the largest number of zeros possible.",
                    "label": 0
                },
                {
                    "sent": "Now then we query the string consisting of all once and then we get this correction string.",
                    "label": 0
                },
                {
                    "sent": "Now it's easy to see that these two queries actually determine.",
                    "label": 0
                },
                {
                    "sent": "All the constants and what remains is to find all the variables we know.",
                    "label": 0
                },
                {
                    "sent": "Now the links of the pattern we need to find all the variables.",
                    "label": 0
                },
                {
                    "sent": "So what we do we use some sort of placeholder representing all variables and now the algorithm valger.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Some start finding variables.",
                    "label": 0
                },
                {
                    "sent": "So first we try 1.",
                    "label": 0
                },
                {
                    "sent": "Trying.",
                    "label": 0
                },
                {
                    "sent": "Kind of guessing that.",
                    "label": 0
                },
                {
                    "sent": "We have just one occurrence of 1 variable on the first position and if we get the answer, yes, this guess is right.",
                    "label": 1
                },
                {
                    "sent": "It's really only one possibility here that X is a variable in the run.",
                    "label": 0
                },
                {
                    "sent": "No occurrences of this variable in the expression.",
                    "label": 0
                },
                {
                    "sent": "Then we try the same for the position 4.",
                    "label": 1
                },
                {
                    "sent": "Again, the answer is positive and that convinces us that.",
                    "label": 0
                },
                {
                    "sent": "Why is the only possibility for this new variable?",
                    "label": 0
                },
                {
                    "sent": "Now we try one for the fifth position, using zeros wherever it is possible, But in this case the answer is no, but correction unfortunately for the algorithm.",
                    "label": 1
                },
                {
                    "sent": "Unfortunately, at this moment gives you.",
                    "label": 1
                },
                {
                    "sent": "These values of 1 and we already know that they are values of the variables X&Y, so there is no much help here, so we have to try it over again and we use now.",
                    "label": 0
                },
                {
                    "sent": "This variables these values for this variables and try one over again for this now.",
                    "label": 1
                },
                {
                    "sent": "This time the correction string again, it is smallest in lexicographic order.",
                    "label": 0
                },
                {
                    "sent": "The correction string returns three values one.",
                    "label": 0
                },
                {
                    "sent": "At the end and it still leaves all the ones that we already found.",
                    "label": 0
                },
                {
                    "sent": "Well, it's not easy to see that this means that these three values represent occurrences of the same variable, so that's what we do.",
                    "label": 0
                },
                {
                    "sent": "We add this variable at the end of the.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Suppression now maybe a couple more.",
                    "label": 0
                },
                {
                    "sent": "Steps so here is our current conjecture.",
                    "label": 0
                },
                {
                    "sent": "Now we query one for the fifth position one more time.",
                    "label": 1
                },
                {
                    "sent": "We have not succeeded yet with the fixed position and this time correction string is this one.",
                    "label": 0
                },
                {
                    "sent": "So this gives us opportunity to add one more variable Z for this four positions and the last query which brings us.",
                    "label": 1
                },
                {
                    "sent": "The final result, which is this.",
                    "label": 0
                },
                {
                    "sent": "Expression.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now one more example, on the surface it's very simple, but it's just to demonstrate that in some cases, since the algorithm gets correction query.",
                    "label": 1
                },
                {
                    "sent": "Gets the correction string that is longer than the.",
                    "label": 1
                },
                {
                    "sent": "Size of the pattern, and this happens when there are no other correction strings available of this length.",
                    "label": 0
                },
                {
                    "sent": "OK, so in some cases you get a longer string and when you get a longest drink, this is the end of the story.",
                    "label": 0
                },
                {
                    "sent": "The end of the algorithm.",
                    "label": 0
                },
                {
                    "sent": "Because this means that all placeholders represent values of the same variable, so we use we create the last variable and the algorithm stops at this.",
                    "label": 1
                },
                {
                    "sent": "So the proof of this game is presented in the paper.",
                    "label": 0
                },
                {
                    "sent": "I cannot elaborate unfortunately.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now running time of the algorithm is an cubed number of queries is N squared, where M is the length of the target pattern.",
                    "label": 0
                },
                {
                    "sent": "Very.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But I'm coming to the last flight, actually.",
                    "label": 0
                },
                {
                    "sent": "Now.",
                    "label": 0
                },
                {
                    "sent": "Some discussion on this algorithm and some modifications expansions possible and some related problem.",
                    "label": 0
                },
                {
                    "sent": "First of all, the algorithm can be extended.",
                    "label": 1
                },
                {
                    "sent": "I'm positive about that though.",
                    "label": 0
                },
                {
                    "sent": "There is no word about this in the paper yet.",
                    "label": 0
                },
                {
                    "sent": "I'm positive that the algorithm can be extended for an arbitrary alphabet Sigma, and it is very important for patterns because even though most of the known algorithms work for two letter alphabet for patterns, when it comes to practical applications, if any, then actually the larger the alphabet the better for practical applications, so that's that's probably an important thing now.",
                    "label": 0
                },
                {
                    "sent": "Why corrections of the same length?",
                    "label": 1
                },
                {
                    "sent": "Well, many years ago, one game week again when they presented their algorithm for learning patterns in the inductive inference paradigm, they actually showed that once you found the shortest string in the language, then strings of arbitrary links become essentially irrelevant for.",
                    "label": 0
                },
                {
                    "sent": "For learning at that and so I kind of follow the same idea here.",
                    "label": 1
                },
                {
                    "sent": "Now as I promised requirement of using quick psychographically smallest shortest example can be slightly relaxed in the following sense.",
                    "label": 0
                },
                {
                    "sent": "If the teacher returns string that contains the largest number of zeros, it's enough.",
                    "label": 1
                },
                {
                    "sent": "And of course the main question here is how far we can relax this conditions imposed on correction queries.",
                    "label": 0
                },
                {
                    "sent": "Well, I started this problem.",
                    "label": 0
                },
                {
                    "sent": "For quite awhile my conjecture is that patterns cannot be learned in polynomial time.",
                    "label": 1
                },
                {
                    "sent": "Unfortunately, using corrections and the shortest distance with no constraints.",
                    "label": 0
                },
                {
                    "sent": "On the correction string.",
                    "label": 0
                },
                {
                    "sent": "Unfortunately though, I have not been able to prove this one way or the other.",
                    "label": 0
                },
                {
                    "sent": "OK, thank you, thank you.",
                    "label": 0
                },
                {
                    "sent": "Questions.",
                    "label": 0
                },
                {
                    "sent": "Yes.",
                    "label": 0
                },
                {
                    "sent": "Did you eat your non ambiguity of your regular expressions enrolled in your learning algorithm?",
                    "label": 0
                },
                {
                    "sent": "With your example, I think that's true in a sense, but it could be easily transformed by shifting balloons a little bit further to the left and right basically into something which is sort of dynamic with our our deterministic well.",
                    "label": 0
                },
                {
                    "sent": "For this particular example, yes, but I have to think about this.",
                    "label": 0
                },
                {
                    "sent": "I'm not sure that it would be possible.",
                    "label": 0
                },
                {
                    "sent": "For any arbitrary example, though, this is an interesting question that you are asking.",
                    "label": 0
                },
                {
                    "sent": "Somewhere I'm under the impression that.",
                    "label": 0
                },
                {
                    "sent": "As far as I know, regular expressions are basically give you class of whatever sort of paradigm is in the back.",
                    "label": 0
                },
                {
                    "sent": "If you passed or breaker languages.",
                    "label": 0
                },
                {
                    "sent": "The specific property that you can quite easily transform those regular expression into DFA which have beta same size.",
                    "label": 0
                },
                {
                    "sent": "It might be true.",
                    "label": 0
                },
                {
                    "sent": "I am not sure about that.",
                    "label": 0
                },
                {
                    "sent": "I I have to think about this.",
                    "label": 0
                },
                {
                    "sent": "Well, formally speaking, the class is is not deterministic.",
                    "label": 0
                },
                {
                    "sent": "It seems to me at least.",
                    "label": 0
                },
                {
                    "sent": "Yeah, but but you may be right.",
                    "label": 0
                },
                {
                    "sent": "I have to think about this.",
                    "label": 0
                }
            ]
        }
    }
}