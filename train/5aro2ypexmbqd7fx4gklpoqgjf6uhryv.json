{
    "id": "5aro2ypexmbqd7fx4gklpoqgjf6uhryv",
    "title": "Semantics and Validation of Shapes Schemas for RDF",
    "info": {
        "author": [
            "Iovka Boneva, L'institut universitaire de technologie (IUT), Universit\u00e9 de Lille 1"
        ],
        "published": "Nov. 28, 2017",
        "recorded": "October 2017",
        "category": [
            "Top->Computer Science->Semantic Web"
        ]
    },
    "url": "http://videolectures.net/iswc2017_boneva_shapes_schemas/",
    "segmentation": [
        [
            "OK hello everybody, I'm your kabanova and I'm going to talk about schemas for RDF.",
            "So sorry.",
            "Let me start with an introduction and motivation."
        ],
        [
            "I, let's say this simple statement.",
            "Every person has a birth date.",
            "Is it true or false?",
            "So my answer is that it depends on the context.",
            "If I'm walking through the forest, thinking about life, then this statement is obviously true.",
            "But if I'm struggling with my RDF data set that talks about persons, this statement might very well not be true because maybe in my RDF data set.",
            "Every person does not have its database birthday that is present, so our work is motivated.",
            "This network is partly motivated in making the statement become true in this second situation."
        ],
        [
            "So we are interested in RDF schemas for RDF and for us for this dog.",
            "A schema is vocabulary plus constraints on the data, just to make it precise.",
            "For instance, XML Schema is a schema language with respect to this definition.",
            "It defines the tags that are allowed and the structure of the XML document, whereas RDF schema is not a schema language regarding to this definition, it's an ontology that talks about the world but not about the actual data.",
            "What for schemas for our Jeff?",
            "So it allows to ensure to increase data quality if you constrain the structure of the data, then you discount.",
            "This actually improves data quality.",
            "It makes it easier for programmers to write programs that consume RDF data because they can know exactly what is in the data in what is not in the data and also schemas allow two users to understand the structure of the data so queries can be written.",
            "More easily.",
            "Now the contributions of this work are the following.",
            "We defined shapes."
        ],
        [
            "Most we call it shape schemas.",
            "It's actually just an abstract version of the shape expressions language, which is concrete language with concrete syntax and with the available implementations and with you engineer friendly specification and this everything about checks can be found from this website that you can see here, including pointers to the specification and implementations.",
            "So in this talk, shakes and shape schemas will be.",
            "New names.",
            "These two are expressive languages that allow several operators for defining the structure of RDF graphs, and also they are independent from ontologies.",
            "They allowed to mix vocabularies from different ontologies, and you can validate against the check schema either before or after entailment so it's completely orthogonal on the available intelligence for your data.",
            "So the main aim of this work was to define formal semantics for shape schemas.",
            "That is for sex, and we also propose two algorithms for validation.",
            "Let me now go."
        ],
        [
            "Autoshape schemers and my aim here is to illustrate what you can do with Shaq schemas through an example.",
            "This example is a bit long but OK.",
            "I wanted to cover most most of the features.",
            "So in this example we have two kinds of constraints here.",
            "These are simple constraints that allow to constraint the value of an RDF node.",
            "For instance, string value.",
            "Shape, it just says that do not should be a string literal RRI value than not should be an IRA, and we can also define custom sets of allowed values, for instance, this one will be used for a programmer, and programmer can be a senior or junior program.",
            "Now we also have this more complex shape definitions.",
            "A user that is a note that satisfies the user shape should have a fourth name, which is a string of 4th and box which is an eye, right?",
            "And it is optional.",
            "Thanks to this 01 interval an this constraint here that I'm not going to explain into details, but it basically says that a user can also have any properties that are different from 4th name an from 4th Inbox and which.",
            "Which value is non constraint and there can be any number of days that is shake.",
            "Schemas allow you to talk only about parts of the vocabulary that is used in the graph and leave the other properties on constraint.",
            "Now a programmer has an experience which is senior or junior and and expertise zero.",
            "More expertise properties that are some high rise and then we come to a bit more complex shapes.",
            "The issue shape issue is reported by a client reproduced by at least one programmer, reproduced by probably reproduced by some users and it can be related to some other issues.",
            "So as you can see here, issue is the definition of issue uses other shape definitions.",
            "So you can recursively define the structure of the graph they intend the desired structure of the graph through these definitions, and we really have recursion here.",
            "I mean, even circular recursion, because the definition of issue depends on issue itself.",
            "And finally, different constraints can be combined through Boolean operators.",
            "This client here.",
            "This constraint here says that the client node should satisfy some regular expressions for the actual UI of the higher of the node, and there are some constraints on the neighborhood of the note."
        ],
        [
            "Now, if you are given an RDF data set or an RDF graph, we want we are able to ask to to answer two different questions.",
            "The first question is, given a node in a graph and a shape, does this note satisfy the shape?",
            "For instance, is it the case that this note here, such as face the issue shape?",
            "And the second question that we are able to answer is for every node of the graph, which are the shapes that are defined by this particular node.",
            "And I will come to this example later on."
        ],
        [
            "Now, on a more abstract level or shapes schema is a set of shape definitions which are to a shape libel.",
            "We associate its definition, which is a shape expression.",
            "A shape expression is a Boolean combination of two atomic constraints which are not constraints, that that's a constraint.",
            "The value of the node, an neighborhood constraints which constraint the neighborhoods of the nodes, and possibly recursively their neighbor neighbors, and so on.",
            "I'm not going into details in the different for the different operators that are allowed here, but you got an overview or with the example I think.",
            "So let's go to the semantics, which is one of the main contributions of this work."
        ],
        [
            "And we have the defining the semantics of this language is not obvious, is not trivial.",
            "I mean because we basically have two difficulties there.",
            "One difficulty is due to recursion.",
            "So let's consider this simple example.",
            "A pet owner is somebody who is an owner of a pet and a pet.",
            "It has an owner who is a pet owner.",
            "So consider this simple graph you."
        ],
        [
            "His master, the Master of Hedwig and Hedwig is has your car's owner.",
            "So the question is, is it the case that your good is a pet owner?",
            "Well, you should.",
            "We suppose that Hedwig is a pet, then you offer is a pet owner.",
            "But if we suppose that Hedrick is not a pet.",
            "Yoga is not a pet owner, but nothing in the graph allows us to choose between these two situations.",
            "So to the question whether you offer is also type here whether you have a pet owner, the answer is yes, and this is a design choice.",
            "Basically we had the choice between two possibilities.",
            "Either this, these are the types associated to the nodes, or this is the solution and we want to have the most permissive solution as possible.",
            "So we choose that both the offer is pet owner and Hedwig is a pet.",
            "Because nothing in the graph and in the schema allows to contradict this situation.",
            "No, another difficulty comes from negation, it is."
        ],
        [
            "We all know that if you combine recursion indication then you get into trouble and let me illustrate it with this more abstract example.",
            "I have the shape L and something is a shape L if it's.",
            "If it doesn't have a prop property that is of shape L. So consider this graph and one has a property to end two and then two has a property to anyone.",
            "So there are two possible situation."
        ],
        [
            "Is here either N one is of type of shape lol.",
            "But in this case and two cannot be of shape L."
        ],
        [
            "Or the other way around?",
            "And these two are really contradicting.",
            "We cannot if you choose the other they want, then the other will be false.",
            "So how do we solve this question?",
            "What there are ways in logical programming, for instance, to define semantics of such things?",
            "And you say both are true back.",
            "Basically it depends whether anyone of type type L depends on what are the types for four N 2, but it would delete nondeterministic behavior, and we want to be able to.",
            "Answer Precisely and uniquely to the question whether an N1 is of type L. So what we do here, we impose syntactic restriction on shake schemas, which is stratified negation.",
            "This is a well known way to restrict recursion and negation in order to have to have sound semantics.",
            "And this is not because negation is not used so often.",
            "This restriction is not so restriction restrictive in real examples.",
            "Now let's go to the semantics."
        ],
        [
            "How we define the semantics?",
            "Well, it's based on the notion of typing.",
            "A typing simply associate's shapes to the nodes of the graph and when typing is correct.",
            "If for every shape associated to some node, the neighborhood of this node, together with associated types satisfies the constraint.",
            "For instance, for a programmer I want to have an experience which is senior or junior and possibly expertise.",
            "That is some high right.",
            "So here with respect to this, typing is correct with respect to this Association becausw.",
            "The cost trend given by programmer is satisfied by this node, but then I still have a problem here because if you think about it, if I don't have associate any type to any node, any shape to any node, then it's correct because I have no constraint to check.",
            "So how do we solve this this one?"
        ],
        [
            "Now we solve it by defining a maximal typing.",
            "This basically is a typing in which every possible type is associated to an old.",
            "And here I I highlighted the types that I added with respect to the previous example."
        ],
        [
            "So the main property here is that for every graph and every schema, there exists a unique maximal typing which is correct, and this is possible thanks to the stratification and now to the question whether a node N satisfies type L. We answer yes if and only if.",
            "Shape L is this associated with the node N. When in the maximum typing.",
            "Now let's talk a bit about the validation.",
            "Validation is the problem of aftering the two questions that I asked whether or not satisfy some given type and what are the types or the shape satisfied by a note."
        ],
        [
            "We propose two validation algorithms.",
            "The 1st is a global refinement.",
            "We call it refinement algorithm.",
            "It consists of computing the the maximal typing.",
            "So it's based on the certification.",
            "We associate all types to all nodes and then whenever type doesn't hold, we remove it and this way a fixed point is reached.",
            "This this this algorithm has an advantage because once we computed the maximal typing, then for every node an every type you are able to answer immediately whether the node satisfies this shape.",
            "But the inconvenient.",
            "The drawback here is that you might turn out to make lots of useless computation."
        ],
        [
            "For instance, if I want to know whether Issue 2 is an issue.",
            "If you look at the schema, you will notice that this part of the graph does not need to be visited.",
            "I mean what is?",
            "What are the types of we should one of these three nodes here doesn't influence at all whether issue 2 is an issue.",
            "So we propose another algorithm, which is a recursive exploracion algorithm.",
            "Basically, we start by asking whether issue 2 is an issue, and then we propagate typing requirements in order.",
            "This to be of this type.",
            "This note should be a client.",
            "This not should be a programmer, and this node should be a user.",
            "Anne.",
            "What happened off?",
            "Sorry.",
            "No.",
            "Then this again recursively propagates other typing requirements, and we end up either with by constructing a correct typing, or by constructing of an empty typing, and we either ha.",
            "Sorry, we either deduce that issue 2 is of type issue or not.",
            "And now it's time for the conclusion."
        ],
        [
            "So we have the main purpose of this work is to define formal semantics for the shakes language.",
            "For the shape, expressions, language, and lots of the perspectives are also go towards extensions of shakes, SO1, ext is extending shakes with operators for comparing values, for instance, for now I'm not able to guarantee that the birth date of a person is before the birth date of his or her children.",
            "This kind of constraints we are.",
            "We are now adding this kind of constraints on the six language and we know how to formalize it.",
            "Another possible possible extension is to have a graph based graph.",
            "RDF graph transformations based on checks so you have a graph that is valid, valid with respect to a schema and then you transform it to a graph in another structure.",
            "We also plan to work on more efficient validation including incremental validation and to translate shackled to the shapes language.",
            "Thank you.",
            "I didn't really get the problematic of the of the your language because you said this is standard language, but then you again defined semantics of it.",
            "This is this is not a standard language.",
            "I don't think I said this.",
            "Sex is the language that we are now defining.",
            "OK, so there's no official semantics of it yet.",
            "This is the official semantics, and is it?",
            "I mean, in the specification that is defined, but in more engineer friendly terms.",
            "But here we prove because because with recursion and negation, OK, we had lots of questions.",
            "How are we going to guarantee this though?",
            "So here we prove that it is sound, but the semantics that you have defined that is defined for sex on the checks page is really based on this on this one.",
            "OK. And so basically then make so I can not really get so, then make correspondence between this engineering thing and the abstract syntax behind the two languages.",
            "Is the same?",
            "OK, so the semantics is defined on the abstract syntax and that's it.",
            "So another question so related to this maximal semantic.",
            "So yes, would it be also possible to choose some other semantics version?",
            "Yes, it would be.",
            "You could choose a minimal one, but then.",
            "Often we will get to a situation when nobody has notice that you have this incremental.",
            "You have this.",
            "In addition, although this move which which starts from the from a local Webex, can it deal work also in the situation when you have this recursion and this you are applying this this maximum maximal solution?",
            "How it can account for that?",
            "OK, here I was very brief on that, but basically the idea is that if I recurse too.",
            "Order to check this, I come back to the same node in the same type.",
            "The answer is yes because I'm considering the maximal solution if I was considering the minimal solution for instance in Datalog logical program you will answer no.",
            "And here the answer is yes.",
            "And so that's how I stop the recursion.",
            "So do you really consider the maximum semantics intuitive?",
            "So it goes?",
            "What is tradition?",
            "For example, in logic programming, and my intuition would be that if you consider this maximum semantics, you would get off an unexpected behavior because we have the tendency of specifying what you told, not of ruling out, but should not hold with the maximum semantics, you would get a lot of types in ferde that maybe the designer doesn't expect in the schema.",
            "Yes, but every of this type is provable to exist.",
            "I mean now if for instance, this node, I will return back to the maximal typing here.",
            "There is a type missing, but this note here is both the client and the user.",
            "My slide is incorrect here, so this means that in for this issue to node I have to consider this.",
            "The guy for the client and for this issue.",
            "Now I have to consider this as a user or the other way around actually, But then this node does have the two types.",
            "And maybe in some other situation I want to consider this type so this now has this type, but maybe for what I'm trying to prove it's not necessary to consider this type.",
            "So this is the recursive algorithm, it will only show you the types that are necessary for proving something.",
            "It might be OK, it might be counter intuitive.",
            "I agree that with respect to logical problems, yes.",
            "No, no, because for here for instance here this is not is not a string literal.",
            "Or this node is not as a client.",
            "He doesn't have a fourth name and a fourth Mabel inbox, so there's not.",
            "There's not a client.",
            "It is not the case that every because you have constraints.",
            "If you had no constraints, of course every node if.",
            "Yes, then there every node has one unique type, which is the any type which is satisfied by all nodes."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK hello everybody, I'm your kabanova and I'm going to talk about schemas for RDF.",
                    "label": 1
                },
                {
                    "sent": "So sorry.",
                    "label": 0
                },
                {
                    "sent": "Let me start with an introduction and motivation.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "I, let's say this simple statement.",
                    "label": 0
                },
                {
                    "sent": "Every person has a birth date.",
                    "label": 1
                },
                {
                    "sent": "Is it true or false?",
                    "label": 0
                },
                {
                    "sent": "So my answer is that it depends on the context.",
                    "label": 0
                },
                {
                    "sent": "If I'm walking through the forest, thinking about life, then this statement is obviously true.",
                    "label": 0
                },
                {
                    "sent": "But if I'm struggling with my RDF data set that talks about persons, this statement might very well not be true because maybe in my RDF data set.",
                    "label": 0
                },
                {
                    "sent": "Every person does not have its database birthday that is present, so our work is motivated.",
                    "label": 0
                },
                {
                    "sent": "This network is partly motivated in making the statement become true in this second situation.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So we are interested in RDF schemas for RDF and for us for this dog.",
                    "label": 0
                },
                {
                    "sent": "A schema is vocabulary plus constraints on the data, just to make it precise.",
                    "label": 0
                },
                {
                    "sent": "For instance, XML Schema is a schema language with respect to this definition.",
                    "label": 0
                },
                {
                    "sent": "It defines the tags that are allowed and the structure of the XML document, whereas RDF schema is not a schema language regarding to this definition, it's an ontology that talks about the world but not about the actual data.",
                    "label": 0
                },
                {
                    "sent": "What for schemas for our Jeff?",
                    "label": 0
                },
                {
                    "sent": "So it allows to ensure to increase data quality if you constrain the structure of the data, then you discount.",
                    "label": 0
                },
                {
                    "sent": "This actually improves data quality.",
                    "label": 0
                },
                {
                    "sent": "It makes it easier for programmers to write programs that consume RDF data because they can know exactly what is in the data in what is not in the data and also schemas allow two users to understand the structure of the data so queries can be written.",
                    "label": 1
                },
                {
                    "sent": "More easily.",
                    "label": 0
                },
                {
                    "sent": "Now the contributions of this work are the following.",
                    "label": 0
                },
                {
                    "sent": "We defined shapes.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Most we call it shape schemas.",
                    "label": 0
                },
                {
                    "sent": "It's actually just an abstract version of the shape expressions language, which is concrete language with concrete syntax and with the available implementations and with you engineer friendly specification and this everything about checks can be found from this website that you can see here, including pointers to the specification and implementations.",
                    "label": 1
                },
                {
                    "sent": "So in this talk, shakes and shape schemas will be.",
                    "label": 0
                },
                {
                    "sent": "New names.",
                    "label": 0
                },
                {
                    "sent": "These two are expressive languages that allow several operators for defining the structure of RDF graphs, and also they are independent from ontologies.",
                    "label": 0
                },
                {
                    "sent": "They allowed to mix vocabularies from different ontologies, and you can validate against the check schema either before or after entailment so it's completely orthogonal on the available intelligence for your data.",
                    "label": 1
                },
                {
                    "sent": "So the main aim of this work was to define formal semantics for shape schemas.",
                    "label": 0
                },
                {
                    "sent": "That is for sex, and we also propose two algorithms for validation.",
                    "label": 0
                },
                {
                    "sent": "Let me now go.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Autoshape schemers and my aim here is to illustrate what you can do with Shaq schemas through an example.",
                    "label": 0
                },
                {
                    "sent": "This example is a bit long but OK.",
                    "label": 0
                },
                {
                    "sent": "I wanted to cover most most of the features.",
                    "label": 0
                },
                {
                    "sent": "So in this example we have two kinds of constraints here.",
                    "label": 0
                },
                {
                    "sent": "These are simple constraints that allow to constraint the value of an RDF node.",
                    "label": 0
                },
                {
                    "sent": "For instance, string value.",
                    "label": 0
                },
                {
                    "sent": "Shape, it just says that do not should be a string literal RRI value than not should be an IRA, and we can also define custom sets of allowed values, for instance, this one will be used for a programmer, and programmer can be a senior or junior program.",
                    "label": 0
                },
                {
                    "sent": "Now we also have this more complex shape definitions.",
                    "label": 0
                },
                {
                    "sent": "A user that is a note that satisfies the user shape should have a fourth name, which is a string of 4th and box which is an eye, right?",
                    "label": 0
                },
                {
                    "sent": "And it is optional.",
                    "label": 0
                },
                {
                    "sent": "Thanks to this 01 interval an this constraint here that I'm not going to explain into details, but it basically says that a user can also have any properties that are different from 4th name an from 4th Inbox and which.",
                    "label": 0
                },
                {
                    "sent": "Which value is non constraint and there can be any number of days that is shake.",
                    "label": 0
                },
                {
                    "sent": "Schemas allow you to talk only about parts of the vocabulary that is used in the graph and leave the other properties on constraint.",
                    "label": 0
                },
                {
                    "sent": "Now a programmer has an experience which is senior or junior and and expertise zero.",
                    "label": 0
                },
                {
                    "sent": "More expertise properties that are some high rise and then we come to a bit more complex shapes.",
                    "label": 0
                },
                {
                    "sent": "The issue shape issue is reported by a client reproduced by at least one programmer, reproduced by probably reproduced by some users and it can be related to some other issues.",
                    "label": 0
                },
                {
                    "sent": "So as you can see here, issue is the definition of issue uses other shape definitions.",
                    "label": 0
                },
                {
                    "sent": "So you can recursively define the structure of the graph they intend the desired structure of the graph through these definitions, and we really have recursion here.",
                    "label": 0
                },
                {
                    "sent": "I mean, even circular recursion, because the definition of issue depends on issue itself.",
                    "label": 0
                },
                {
                    "sent": "And finally, different constraints can be combined through Boolean operators.",
                    "label": 0
                },
                {
                    "sent": "This client here.",
                    "label": 0
                },
                {
                    "sent": "This constraint here says that the client node should satisfy some regular expressions for the actual UI of the higher of the node, and there are some constraints on the neighborhood of the note.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now, if you are given an RDF data set or an RDF graph, we want we are able to ask to to answer two different questions.",
                    "label": 0
                },
                {
                    "sent": "The first question is, given a node in a graph and a shape, does this note satisfy the shape?",
                    "label": 0
                },
                {
                    "sent": "For instance, is it the case that this note here, such as face the issue shape?",
                    "label": 0
                },
                {
                    "sent": "And the second question that we are able to answer is for every node of the graph, which are the shapes that are defined by this particular node.",
                    "label": 0
                },
                {
                    "sent": "And I will come to this example later on.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now, on a more abstract level or shapes schema is a set of shape definitions which are to a shape libel.",
                    "label": 1
                },
                {
                    "sent": "We associate its definition, which is a shape expression.",
                    "label": 0
                },
                {
                    "sent": "A shape expression is a Boolean combination of two atomic constraints which are not constraints, that that's a constraint.",
                    "label": 0
                },
                {
                    "sent": "The value of the node, an neighborhood constraints which constraint the neighborhoods of the nodes, and possibly recursively their neighbor neighbors, and so on.",
                    "label": 1
                },
                {
                    "sent": "I'm not going into details in the different for the different operators that are allowed here, but you got an overview or with the example I think.",
                    "label": 0
                },
                {
                    "sent": "So let's go to the semantics, which is one of the main contributions of this work.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And we have the defining the semantics of this language is not obvious, is not trivial.",
                    "label": 0
                },
                {
                    "sent": "I mean because we basically have two difficulties there.",
                    "label": 0
                },
                {
                    "sent": "One difficulty is due to recursion.",
                    "label": 0
                },
                {
                    "sent": "So let's consider this simple example.",
                    "label": 0
                },
                {
                    "sent": "A pet owner is somebody who is an owner of a pet and a pet.",
                    "label": 0
                },
                {
                    "sent": "It has an owner who is a pet owner.",
                    "label": 1
                },
                {
                    "sent": "So consider this simple graph you.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "His master, the Master of Hedwig and Hedwig is has your car's owner.",
                    "label": 0
                },
                {
                    "sent": "So the question is, is it the case that your good is a pet owner?",
                    "label": 0
                },
                {
                    "sent": "Well, you should.",
                    "label": 0
                },
                {
                    "sent": "We suppose that Hedwig is a pet, then you offer is a pet owner.",
                    "label": 0
                },
                {
                    "sent": "But if we suppose that Hedrick is not a pet.",
                    "label": 0
                },
                {
                    "sent": "Yoga is not a pet owner, but nothing in the graph allows us to choose between these two situations.",
                    "label": 0
                },
                {
                    "sent": "So to the question whether you offer is also type here whether you have a pet owner, the answer is yes, and this is a design choice.",
                    "label": 1
                },
                {
                    "sent": "Basically we had the choice between two possibilities.",
                    "label": 0
                },
                {
                    "sent": "Either this, these are the types associated to the nodes, or this is the solution and we want to have the most permissive solution as possible.",
                    "label": 0
                },
                {
                    "sent": "So we choose that both the offer is pet owner and Hedwig is a pet.",
                    "label": 0
                },
                {
                    "sent": "Because nothing in the graph and in the schema allows to contradict this situation.",
                    "label": 0
                },
                {
                    "sent": "No, another difficulty comes from negation, it is.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We all know that if you combine recursion indication then you get into trouble and let me illustrate it with this more abstract example.",
                    "label": 0
                },
                {
                    "sent": "I have the shape L and something is a shape L if it's.",
                    "label": 1
                },
                {
                    "sent": "If it doesn't have a prop property that is of shape L. So consider this graph and one has a property to end two and then two has a property to anyone.",
                    "label": 0
                },
                {
                    "sent": "So there are two possible situation.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is here either N one is of type of shape lol.",
                    "label": 0
                },
                {
                    "sent": "But in this case and two cannot be of shape L.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Or the other way around?",
                    "label": 0
                },
                {
                    "sent": "And these two are really contradicting.",
                    "label": 0
                },
                {
                    "sent": "We cannot if you choose the other they want, then the other will be false.",
                    "label": 0
                },
                {
                    "sent": "So how do we solve this question?",
                    "label": 0
                },
                {
                    "sent": "What there are ways in logical programming, for instance, to define semantics of such things?",
                    "label": 0
                },
                {
                    "sent": "And you say both are true back.",
                    "label": 0
                },
                {
                    "sent": "Basically it depends whether anyone of type type L depends on what are the types for four N 2, but it would delete nondeterministic behavior, and we want to be able to.",
                    "label": 0
                },
                {
                    "sent": "Answer Precisely and uniquely to the question whether an N1 is of type L. So what we do here, we impose syntactic restriction on shake schemas, which is stratified negation.",
                    "label": 0
                },
                {
                    "sent": "This is a well known way to restrict recursion and negation in order to have to have sound semantics.",
                    "label": 1
                },
                {
                    "sent": "And this is not because negation is not used so often.",
                    "label": 0
                },
                {
                    "sent": "This restriction is not so restriction restrictive in real examples.",
                    "label": 0
                },
                {
                    "sent": "Now let's go to the semantics.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "How we define the semantics?",
                    "label": 0
                },
                {
                    "sent": "Well, it's based on the notion of typing.",
                    "label": 0
                },
                {
                    "sent": "A typing simply associate's shapes to the nodes of the graph and when typing is correct.",
                    "label": 0
                },
                {
                    "sent": "If for every shape associated to some node, the neighborhood of this node, together with associated types satisfies the constraint.",
                    "label": 0
                },
                {
                    "sent": "For instance, for a programmer I want to have an experience which is senior or junior and possibly expertise.",
                    "label": 0
                },
                {
                    "sent": "That is some high right.",
                    "label": 0
                },
                {
                    "sent": "So here with respect to this, typing is correct with respect to this Association becausw.",
                    "label": 0
                },
                {
                    "sent": "The cost trend given by programmer is satisfied by this node, but then I still have a problem here because if you think about it, if I don't have associate any type to any node, any shape to any node, then it's correct because I have no constraint to check.",
                    "label": 0
                },
                {
                    "sent": "So how do we solve this this one?",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now we solve it by defining a maximal typing.",
                    "label": 0
                },
                {
                    "sent": "This basically is a typing in which every possible type is associated to an old.",
                    "label": 0
                },
                {
                    "sent": "And here I I highlighted the types that I added with respect to the previous example.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So the main property here is that for every graph and every schema, there exists a unique maximal typing which is correct, and this is possible thanks to the stratification and now to the question whether a node N satisfies type L. We answer yes if and only if.",
                    "label": 1
                },
                {
                    "sent": "Shape L is this associated with the node N. When in the maximum typing.",
                    "label": 0
                },
                {
                    "sent": "Now let's talk a bit about the validation.",
                    "label": 0
                },
                {
                    "sent": "Validation is the problem of aftering the two questions that I asked whether or not satisfy some given type and what are the types or the shape satisfied by a note.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We propose two validation algorithms.",
                    "label": 0
                },
                {
                    "sent": "The 1st is a global refinement.",
                    "label": 1
                },
                {
                    "sent": "We call it refinement algorithm.",
                    "label": 1
                },
                {
                    "sent": "It consists of computing the the maximal typing.",
                    "label": 1
                },
                {
                    "sent": "So it's based on the certification.",
                    "label": 0
                },
                {
                    "sent": "We associate all types to all nodes and then whenever type doesn't hold, we remove it and this way a fixed point is reached.",
                    "label": 1
                },
                {
                    "sent": "This this this algorithm has an advantage because once we computed the maximal typing, then for every node an every type you are able to answer immediately whether the node satisfies this shape.",
                    "label": 0
                },
                {
                    "sent": "But the inconvenient.",
                    "label": 0
                },
                {
                    "sent": "The drawback here is that you might turn out to make lots of useless computation.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "For instance, if I want to know whether Issue 2 is an issue.",
                    "label": 0
                },
                {
                    "sent": "If you look at the schema, you will notice that this part of the graph does not need to be visited.",
                    "label": 0
                },
                {
                    "sent": "I mean what is?",
                    "label": 0
                },
                {
                    "sent": "What are the types of we should one of these three nodes here doesn't influence at all whether issue 2 is an issue.",
                    "label": 0
                },
                {
                    "sent": "So we propose another algorithm, which is a recursive exploracion algorithm.",
                    "label": 0
                },
                {
                    "sent": "Basically, we start by asking whether issue 2 is an issue, and then we propagate typing requirements in order.",
                    "label": 1
                },
                {
                    "sent": "This to be of this type.",
                    "label": 0
                },
                {
                    "sent": "This note should be a client.",
                    "label": 0
                },
                {
                    "sent": "This not should be a programmer, and this node should be a user.",
                    "label": 0
                },
                {
                    "sent": "Anne.",
                    "label": 0
                },
                {
                    "sent": "What happened off?",
                    "label": 0
                },
                {
                    "sent": "Sorry.",
                    "label": 0
                },
                {
                    "sent": "No.",
                    "label": 0
                },
                {
                    "sent": "Then this again recursively propagates other typing requirements, and we end up either with by constructing a correct typing, or by constructing of an empty typing, and we either ha.",
                    "label": 0
                },
                {
                    "sent": "Sorry, we either deduce that issue 2 is of type issue or not.",
                    "label": 0
                },
                {
                    "sent": "And now it's time for the conclusion.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So we have the main purpose of this work is to define formal semantics for the shakes language.",
                    "label": 0
                },
                {
                    "sent": "For the shape, expressions, language, and lots of the perspectives are also go towards extensions of shakes, SO1, ext is extending shakes with operators for comparing values, for instance, for now I'm not able to guarantee that the birth date of a person is before the birth date of his or her children.",
                    "label": 0
                },
                {
                    "sent": "This kind of constraints we are.",
                    "label": 0
                },
                {
                    "sent": "We are now adding this kind of constraints on the six language and we know how to formalize it.",
                    "label": 0
                },
                {
                    "sent": "Another possible possible extension is to have a graph based graph.",
                    "label": 0
                },
                {
                    "sent": "RDF graph transformations based on checks so you have a graph that is valid, valid with respect to a schema and then you transform it to a graph in another structure.",
                    "label": 0
                },
                {
                    "sent": "We also plan to work on more efficient validation including incremental validation and to translate shackled to the shapes language.",
                    "label": 1
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "I didn't really get the problematic of the of the your language because you said this is standard language, but then you again defined semantics of it.",
                    "label": 0
                },
                {
                    "sent": "This is this is not a standard language.",
                    "label": 0
                },
                {
                    "sent": "I don't think I said this.",
                    "label": 0
                },
                {
                    "sent": "Sex is the language that we are now defining.",
                    "label": 0
                },
                {
                    "sent": "OK, so there's no official semantics of it yet.",
                    "label": 0
                },
                {
                    "sent": "This is the official semantics, and is it?",
                    "label": 0
                },
                {
                    "sent": "I mean, in the specification that is defined, but in more engineer friendly terms.",
                    "label": 0
                },
                {
                    "sent": "But here we prove because because with recursion and negation, OK, we had lots of questions.",
                    "label": 0
                },
                {
                    "sent": "How are we going to guarantee this though?",
                    "label": 0
                },
                {
                    "sent": "So here we prove that it is sound, but the semantics that you have defined that is defined for sex on the checks page is really based on this on this one.",
                    "label": 0
                },
                {
                    "sent": "OK. And so basically then make so I can not really get so, then make correspondence between this engineering thing and the abstract syntax behind the two languages.",
                    "label": 0
                },
                {
                    "sent": "Is the same?",
                    "label": 0
                },
                {
                    "sent": "OK, so the semantics is defined on the abstract syntax and that's it.",
                    "label": 0
                },
                {
                    "sent": "So another question so related to this maximal semantic.",
                    "label": 0
                },
                {
                    "sent": "So yes, would it be also possible to choose some other semantics version?",
                    "label": 0
                },
                {
                    "sent": "Yes, it would be.",
                    "label": 0
                },
                {
                    "sent": "You could choose a minimal one, but then.",
                    "label": 0
                },
                {
                    "sent": "Often we will get to a situation when nobody has notice that you have this incremental.",
                    "label": 0
                },
                {
                    "sent": "You have this.",
                    "label": 0
                },
                {
                    "sent": "In addition, although this move which which starts from the from a local Webex, can it deal work also in the situation when you have this recursion and this you are applying this this maximum maximal solution?",
                    "label": 0
                },
                {
                    "sent": "How it can account for that?",
                    "label": 0
                },
                {
                    "sent": "OK, here I was very brief on that, but basically the idea is that if I recurse too.",
                    "label": 0
                },
                {
                    "sent": "Order to check this, I come back to the same node in the same type.",
                    "label": 0
                },
                {
                    "sent": "The answer is yes because I'm considering the maximal solution if I was considering the minimal solution for instance in Datalog logical program you will answer no.",
                    "label": 0
                },
                {
                    "sent": "And here the answer is yes.",
                    "label": 0
                },
                {
                    "sent": "And so that's how I stop the recursion.",
                    "label": 0
                },
                {
                    "sent": "So do you really consider the maximum semantics intuitive?",
                    "label": 0
                },
                {
                    "sent": "So it goes?",
                    "label": 0
                },
                {
                    "sent": "What is tradition?",
                    "label": 0
                },
                {
                    "sent": "For example, in logic programming, and my intuition would be that if you consider this maximum semantics, you would get off an unexpected behavior because we have the tendency of specifying what you told, not of ruling out, but should not hold with the maximum semantics, you would get a lot of types in ferde that maybe the designer doesn't expect in the schema.",
                    "label": 0
                },
                {
                    "sent": "Yes, but every of this type is provable to exist.",
                    "label": 0
                },
                {
                    "sent": "I mean now if for instance, this node, I will return back to the maximal typing here.",
                    "label": 0
                },
                {
                    "sent": "There is a type missing, but this note here is both the client and the user.",
                    "label": 0
                },
                {
                    "sent": "My slide is incorrect here, so this means that in for this issue to node I have to consider this.",
                    "label": 0
                },
                {
                    "sent": "The guy for the client and for this issue.",
                    "label": 0
                },
                {
                    "sent": "Now I have to consider this as a user or the other way around actually, But then this node does have the two types.",
                    "label": 0
                },
                {
                    "sent": "And maybe in some other situation I want to consider this type so this now has this type, but maybe for what I'm trying to prove it's not necessary to consider this type.",
                    "label": 0
                },
                {
                    "sent": "So this is the recursive algorithm, it will only show you the types that are necessary for proving something.",
                    "label": 0
                },
                {
                    "sent": "It might be OK, it might be counter intuitive.",
                    "label": 0
                },
                {
                    "sent": "I agree that with respect to logical problems, yes.",
                    "label": 0
                },
                {
                    "sent": "No, no, because for here for instance here this is not is not a string literal.",
                    "label": 0
                },
                {
                    "sent": "Or this node is not as a client.",
                    "label": 0
                },
                {
                    "sent": "He doesn't have a fourth name and a fourth Mabel inbox, so there's not.",
                    "label": 0
                },
                {
                    "sent": "There's not a client.",
                    "label": 0
                },
                {
                    "sent": "It is not the case that every because you have constraints.",
                    "label": 0
                },
                {
                    "sent": "If you had no constraints, of course every node if.",
                    "label": 0
                },
                {
                    "sent": "Yes, then there every node has one unique type, which is the any type which is satisfied by all nodes.",
                    "label": 0
                }
            ]
        }
    }
}