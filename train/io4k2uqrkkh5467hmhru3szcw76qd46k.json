{
    "id": "io4k2uqrkkh5467hmhru3szcw76qd46k",
    "title": "RDFS with Attribute Equations via SPARQL Rewriting",
    "info": {
        "author": [
            "Stefan Bischof, Siemens AG \u00d6sterreich"
        ],
        "published": "July 8, 2013",
        "recorded": "May 2013",
        "category": [
            "Top->Computer Science->Semantic Web",
            "Top->Computer Science->Big Data"
        ]
    },
    "url": "http://videolectures.net/eswc2013_bischof_sparql_rewriting/",
    "segmentation": [
        [
            "The work I'm presenting today is joint work of Teal, Vienna and Siemens, Austria, and it's about the project of sustainable cities.",
            "And one very good example, City is the city."
        ],
        [
            "We're in now, it's Montpelier.",
            "And we hear it's.",
            "It's very nice.",
            "It is so far and, but we also want to find some data or have some data about Montpelier, and there's several kinds of data that we can find on the on DB pedia on euros that there are several kinds of open data we can find in different sources.",
            "For example, we have numbers for population.",
            "We have numbers for the area.",
            "We also have a number for the average temperature in May, and currently it's actually a little bit below their average temperature than it should be.",
            "But there also."
        ],
        [
            "Gaps in this data, so we cannot find any any numbers for the CO2 emissions per person of the city, or.",
            "The average temperature in May in Fahrenheit.",
            "Or another example would be the population density."
        ],
        [
            "But if you know what well the population density is normally defined by dividing the population number by the area, and we have both values for the city, but we don't have a value for population density.",
            "So our contribution will be to to add equations to a tee box so that we can actually infer infer concrete values.",
            "Numbers in this case.",
            "Like for example, the population density.",
            "Current semantic web reasoners.",
            "They don't cope really well with normal numbers, so you can't do any kind of inference or computations on these numbers.",
            "So we have to invent this ourselves.",
            "And the first question, if you want to have the population densities, what's the area in square kilometers?",
            "But because if we look at DB pedia, we find numbers for the population 253 thousand people and we have an area which is 56 million square meters.",
            "So we first would have to compute the area in square kilometers."
        ],
        [
            "So as a first step, if the question is what is the population density of mobilia, we would have to formalize our query as well.",
            "So we have our data in different data sources.",
            "We have TV pedia, we have euro stats.",
            "And for the sake of this presentation, we assume we have all this in a triple store.",
            "We have it already collected, so we don't have to think about Federated queries or things like that.",
            "So in an except we have the data we want the results.",
            "First we need a query."
        ],
        [
            "Naturally, we expressed this in sparkle and it's this very short query we see here on the top, but of course you can also have more complex queries using filters or optionals or any other kind of more complex operators.",
            "So what's the population then?"
        ],
        [
            "We have to query now.",
            "Next step we have to query.",
            "We have the data as a next step we would need an RDF's ontology.",
            "And why is that?"
        ],
        [
            "Well, because we have, our data are collected now from these different sources.",
            "But they all use different vocabulary, so they have every one of those has their own namespace.",
            "So when DB Pedia talks about population total in their own namespace.",
            "Then we don't know if that's the same when geonames talks about population, so we use our DFS rules RDS inclusion axioms in this case, sub property of to infer that population total of DB pedia is the same as population in geonames.",
            "There are already lots of our DFS reasoners around and we would like to extend one that works for by rewriting sparkle queries."
        ],
        [
            "So.",
            "The next would be to extend this artifacts ontology by adding equations so that it supports that we can root, do reasoning or numbers by using these equations.",
            "How can we do?"
        ],
        [
            "So first, let's let's fix the syntax, so most of the things you see here is standard RDF's we have subclass of domain and range and sub property of.",
            "So all the things that are not in boxes.",
            "Old stuff, so to say.",
            "The thing in the blue boxes it's so we distinguish between what we know from our less object properties and we call them attributes here.",
            "So attributes are those properties that .2 numbers.",
            "So we have our DFS domain for numbers as well.",
            "So for example if we have."
        ],
        [
            "DP population the property population from DB Pedia that has as domain populated place so that makes sense that something that has a population is populated place.",
            "Onyx."
        ],
        [
            "Ample for sub property would be.",
            "The one year we have seen before already, or to say that the geonames population is a sub property of population so we can have a unified vocabulary for this."
        ],
        [
            "For the a box.",
            "That's pretty straightforward.",
            "You can see it here, but it says that Montpelier has a population of 253 thousand people."
        ],
        [
            "Our extension is then to add extent equations here, so we also have a.",
            "We first need a syntax for the equations and from for the RDF site.",
            "This would be if we have a population density.",
            "We invented a new property that's called defined by equation.",
            "And the object of this triple would be the function with the remaining two things.",
            "So in this case we would say that is triple that the population density is defined by the function dividing population by area."
        ],
        [
            "If we have the syntax, we only need the semantics and the semantic.",
            "Sorry.",
            "I mean for our DFS and attributes, the semantics is given, so we know that already.",
            "We only have to add the rule or the semantics of of the equation extension and intuitively this is.",
            "Intuitively this says that if we have values for all the remaining attributes in the equation, we can infer the new value.",
            "So for example."
        ],
        [
            "If we have the equation population density which is defined by dividing population by area and we have to."
        ],
        [
            "Two values for population in the area.",
            "We can infer the new value."
        ],
        [
            "Which is then the population density and the remaining part is defined here.",
            "Just make sure that we don't have a division by zero.",
            "In general, the query answers are not necessarily finite, but we will come to that later as well."
        ],
        [
            "So how can we?",
            "How can we implement this kind of system?",
            "How can we implement this semantics?",
            "One way would be to use forward forward chaining engine.",
            "No, that's the slide before.",
            "So if we have this first have to use a forward chaining engineer rule engine and one possibilities if we have this equation already, we formulate this equation as a rule as you see here.",
            "If you have an equation in square kilometers, we formula that equation as a rule.",
            "But if we want to ask for population density, we also need more rules for for each.",
            "So we need one rule for each variable.",
            "It occurs in the equation up there, so we need 3 rules for three variables.",
            "Now let's start.",
            "Let's try to run this on a forward chaining engine."
        ],
        [
            "We have 3 rules.",
            "We have two data values.",
            "We have the population number.",
            "We have the area number.",
            "And we can apply the first rule.",
            "Which says that we compute the population density by dividing the population by the area and we will get this very nice numbers, which has actually lots of digits after the comma, but they skipped some of those here.",
            "But if we have now this number as well, then the forward chaining engine will say.",
            "Now we have number for population density and we have a number for population.",
            "So we can apply the second rule.",
            "We also have the area into population density, so we can apply the third rule.",
            "Unfortunately, so in well in an ideal world will get the same values again, but in an implementation you will get rounding errors.",
            "So here on the last digit areas one rounding error and tease 2 numbers should be the same, but they're not.",
            "Here we have the same a rounding error on the last digit.",
            "The two numbers are not the same.",
            "Then we are in the same situation as in the beginning already.",
            "We have now two more values for for population and area.",
            "And we can compute the population density again, but now it's a different number as well.",
            "So we have a rounding error here.",
            "Now it's in the last two digits digits already.",
            "And this will continue forever.",
            "That's why I have the waiting sign here.",
            "You will wait forever."
        ],
        [
            "Well, if forward chaining is not working, why not?",
            "Why not backward chaining?",
            "Again, we want to ask for population density and we have a rule for that.",
            "It's the first rule, so we try to we use the first rule and the backward chaining engine works the other way around.",
            "So we go from the rule from the rule head from the result to the body of the rule.",
            "As we have population and area in the body of the rule, the backward chaining engine will try to expand both both of them.",
            "So it will try to when we ask for population density it will try to compute the population.",
            "But what will happen here is if we try to compute the population density to get to if we try to query for population for population, but we want to query for population density then this rule would actually expect that we know the population density already.",
            "So that would mean to compute the population density.",
            "We have to know the population density, which makes no sense.",
            "And again, this rule application would also continue forever, so we will get an arbitrarily big query and we're back to the same.",
            "We wait forever."
        ],
        [
            "So what can we do?",
            "The problem with rules is that we have to specify them in all directions, so we have N rules for N variables.",
            "We have seen forward chaining does not terminate because of the rounding errors.",
            "And backward chaining.",
            "If we do it in this naive way, it also won't terminate because the recursive rules blow up the query arbitrarily.",
            "And that was even the case only for a single equation.",
            "If we have more than one equations which will only get worse.",
            "So since we also want to do query rewriting, we have to somehow break this infinite series of rule applications to get this terminating to get a finite query actually.",
            "Will come to this later.",
            "Let me just one minute introduced per."
        ],
        [
            "Rick Griffin algorithm.",
            "We have heard about it 2 times.",
            "I think today already.",
            "So I don't want to say too much about this."
        ],
        [
            "Perfect Drift was introduced by Calvin's and his colleagues in 2007.",
            "If I remember correctly, and in 2009 they published a very extensive summer School Report on that.",
            "So if you want to have more details and you can look it up there, but what it does in general is.",
            "Query rewriting, So what it does is it tries to it as input, so that would be the algorithm it had this input a tee box and a conjunctive query and it will encode the tee box the relevant parts of the tee box in the query.",
            "So now there you will only have a query and all you have to do is evaluate the query on the box and the tee box is not used anymore.",
            "In the end, get the certain answers and we will extend this perfect drift in our implementation by the equations."
        ],
        [
            "OK. We have to.",
            "We have perfect graph.",
            "Now we have to extend it by equations and one problem that we see here is that originally we have a sparkle query, but the perfect graph algorithm takes this input conjunctive query.",
            "So there must be something.",
            "In between, that transforms between these two.",
            "But first about extending perfect drift by equations."
        ],
        [
            "So let's look at at an example how we can break this infinite series of rule applications that we've seen before.",
            "Let's imagine we have we have three different equations and we query for the population density.",
            "When we query for this, the first thing we do is we look at all our equations.",
            "If we can find one that applies and there is one equation, the first one where population density occurs.",
            "The same as before we have to query for the area square, kilometers and population.",
            "Now what we would do again is we would do the same procedure for these two, so we have to query for the area in square kilometers.",
            "We look at our equations and we see.",
            "Yeah, they respond and that's the original one that we have seen already.",
            "But we want to.",
            "That's exactly the thing this kind of cycle is.",
            "The thing we want to avoid.",
            "So what we do is we adorn these two queries by the attribute name that we used in the beginning for the query.",
            "And intuitively, the semantics of this is if we query for this value for the area in square kilometers.",
            "Then we do not want to use any equation that contains population density, so this will be ruled out because population density.",
            "The one here occurs also in the equation, so we don't use that and look at our equations again if we can find another one.",
            "There is the second one that converts area in square meters to area in square kilometers.",
            "This one doesn't contain the population density, so we can use that.",
            "We ask for the area in square meters here, and we do the same again.",
            "We adorn them by the attribute names that the ones that we used here and here so that we do not use any equations anymore that contain population density or area in square kilometers.",
            "The same we do for the conversion between square miles and square kilometers.",
            "We do all the adornment so that we cannot use any equation that population density or area contains which rules out all the other queries and we're finished for this case.",
            "So now we have.",
            "A finite set of queries.",
            "That also gives us a finite result."
        ],
        [
            "Now to the algorithm itself.",
            "This is a already reduced version of the perfect graph algorithm that would thing in the box would be the extension and normally there is also a reduction part.",
            "A second part that we could leave out because we used only our DFS reasoning where we don't need this.",
            "So in this extension it says that if you have a have an equation axiom in the tee box.",
            "And we have an attribute in our query and attribute Atom.",
            "This attribute item occurs in the.",
            "In the equation and.",
            "That the variables in the equation and the adorned attribute names of the attribute.",
            "That's exactly what we have seen here.",
            "That the things in the adornments don't occur in the equation.",
            "So this just captures this semantics.",
            "If that happens then we can copy the rule and replace an Atom by by the computation."
        ],
        [
            "So in the example, again, if we have now only two.",
            "Equations and the original query asking for population density.",
            "Then what the algorithm does is.",
            "It will go over their query and try to apply the equations.",
            "So first it will find the equation about population density E1.",
            "It will copy the original query and replace the pop tents.",
            "The population density Atom by the computation first selects the population in the area in square kilometers.",
            "Does the computation here and this X is then the result the same as we have in the original query?",
            "So we have computed the population density.",
            "For this one, we cannot apply any other equations, so we but we have added a second query, which is this one.",
            "So we tried to apply the equations to this query.",
            "For this population again we could apply the first equation, but since we have population density in the adornment here.",
            "Which is also in the query.",
            "That violates our conditions, so we cannot apply it.",
            "But for the second one for the area in square kilometers, we have an equation and states the equation 2.",
            "And that one we can apply again.",
            "We copy the whole query so we have also population density population here with the population density adornment.",
            "And we replace the area in square kilometers by area in square meters and the corresponding computation.",
            "Now we cannot apply any other equations anymore.",
            "So we're finished.",
            "We have.",
            "We have three conjunctive queries and that concludes our rewriting.",
            "I think I will skip this."
        ],
        [
            "So what we have now is the perfect rewriter.",
            "This extension by equations we have unions of conjunctive queries.",
            "They also contain computations.",
            "And we need one thing we need is the sparkle transformator which is."
        ],
        [
            "Essentially, transforms which first the basic graph patterns rewrites the basic graph patterns to conjunctive queries."
        ],
        [
            "So they can be used by the perfect riff algorithm.",
            "Here we have contracted queries.",
            "The perfect drift algorithm will return conjunctive queries with equations and this partial transformator."
        ],
        [
            "Will then transform, will then collect all these rewritten queries and spit out and use partial query.",
            "Where the equations so that variable assignments are rewritten to Sparkle 1 one point."
        ],
        [
            "If we look at the example again, we have.",
            "These are the three rules.",
            "The three conjunctive queries that were the output of the perfect of the extended perfect REF algorithm.",
            "This was the original query.",
            "And the sparkle Transformator will then make replace this original query by the rewriting, which is in this case.",
            "I said if unions so we have free reunions.",
            "The first query will be replaced by this one, so the second query is this one.",
            "Here you see the bind, we have the computation here.",
            "XS P / A and we have the same equation here.",
            "So we say that the population the population divided by the area is the population density.",
            "That's the extent is selected here.",
            "The same for the last one.",
            "So all we need now."
        ],
        [
            "Is a sparkle engine because the output of this partial transformator is a spark queries that we can use any kind of sparkle engine.",
            "To evaluate this.",
            "I don't have my."
        ],
        [
            "Time left, but we also did some preliminary evaluation where we compared China forward rules.",
            "With our implementation with our rewriting."
        ],
        [
            "Normally."
        ],
        [
            "Normally the if you have forward rules, you get the problem that I explained in the beginning already.",
            "We have rounding errors, so this just didn't terminate transfer for no query we had.",
            "For."
        ],
        [
            "This alternative implementation where which is kind of an alternative implementation of our semantics.",
            "It did.",
            "Terminate, but our rewriting was normally faster.",
            "It's around 7:00 or 8 seconds and the channel forward rules with this no value.",
            "Was took around 30 seconds."
        ],
        [
            "So conclusions the most important part is that we have lots of numbers.",
            "In the in open data, so we have lots of numbers, so reasoning on them and using equations is important and using equation equations is also feasible.",
            "We have seen rule engines are not very well suited if you do it in a naive way.",
            "But if you do query rewriting, you can do this even on Publix, Publix, partial endpoints, and in the end we have seen that it can be faster.",
            "So if you don't know it by now, the population density of Mobile is 4447.9.",
            "Thank you.",
            "So my question is about more less the complexity of the algorithm of the perfect rewriting or with a table decorations.",
            "So can it?",
            "Is it exponential because I think it can go into exponential algorithm easily, because if you have nested nested function ratings then.",
            "You can, you can have equations that are, so did use the same attributes over and over again.",
            "Yeah, well in general for dialight.",
            "I mean we use only the RDF's fragment of delight, but in general for delight you have already a problem.",
            "The complexity, the data complexity is is extractable but the rewriting will blow up exponentially anyways.",
            "So and we will have this exponential blowup.",
            "I think we have that exponential blowup as well so well, it's not better than dialight, but it's also not worse.",
            "You said that you said something about 8 seconds of rewriting.",
            "That seems pretty long is it?",
            "Can you explain that that was the query evaluation that was not the rewriting itself?",
            "That was only the query evaluation, so I can assume that query writing is really fast.",
            "Or I think yeah, yeah, OK, sorry misunderstood.",
            "More questions.",
            "OK.",
            "In this scenario, you actually are only allowed to define functions for for the same individual that that you also have assigned the other values to write.",
            "So you might ask for give me the average weight of the monkey gay people and you want actually to get this by collecting all the citizens of multi year and then, but then assign the function actually to the city of monkey.",
            "What so I mean, what do you think of that?",
            "That's very different, and that's I think that that's harder to do or no.",
            "Yeah, something else.",
            "So I mean that would be you could do this with sparkle.",
            "On top of that, if you define I'm just I mean there you just would use normal sparkle aggregates.",
            "I would say for that.",
            "If you had the symptoms anyway, but that would be more expressive than.",
            "So.",
            "That's yeah, yeah yeah, we yeah, yeah, we still have a few minutes so we can of course.",
            "Still on aggregates, why is aggregate changing so much?",
            "The thing I mean?",
            "Is it the message issue or do you think that it's it's more expressive than we have here, but you can?",
            "We could define a rewriting that uses aggregates in this part website, yes, but then we cannot use unions of conjunctive queries in the middle anymore because aggregates are more expressive than you conjunctive queries.",
            "Well, I mean what I wanted to say was, I mean basically you don't need to the aggregate in this formalism, because since we support so we we just take any basic graph pattern in the sparkle query and apply the rewriting.",
            "OK so if you have an aggregate outside aggregate and all other operators or sparkler always evaluated on top of basic graph pattern evaluation.",
            "So you can absolutely just have an aggregate in sparkly.",
            "It doesn't have to do anything with our formalism, that's the same as having optional cruise or whatever on top.",
            "But you would have aggregates in the definition of your functions, right?",
            "So that's and that makes it more complex.",
            "Like the average population density by an aggregate, yeah?",
            "Ah OK, that's what I meant.",
            "I mean, we need to be happy.",
            "Would be interesting.",
            "OK, more questions comments.",
            "How?",
            "So we compared to the previous session about special data.",
            "The focus is out to to write a query with a special query on.",
            "After all the staff are special stuff is made in a, you know put a Postgres SQL database.",
            "Why do you want that sparkle of that?",
            "The series owner is able to make aggravation because in database system like data Warehouse under there is aggregation function on something like that which perform.",
            "Very good, So what is the use case of?",
            "Building a specific things with Buckle on his owner.",
            "So yeah, originally the delight system that Diego Calvanese and his colleagues introduced is working on relational databases so.",
            "That's that's the main use case, or the scenario of ontology based data access.",
            "In our case, we say we want to query open data and open data that is already available.",
            "As our DFS is RDF.",
            "The other thing is that we had.",
            "Quite the big ontology and the problem is that normally you have very sparse data.",
            "We had for some cities we have lots of data, so we have hundreds or even thousands of attributes.",
            "And for some cities we have only two numbers.",
            "So if we put it in a in a relational databases it will.",
            "It will be very sparse.",
            "That's why we used RDF and we used sparkly because we used RDF.",
            "OK, so let's think I will speak again."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The work I'm presenting today is joint work of Teal, Vienna and Siemens, Austria, and it's about the project of sustainable cities.",
                    "label": 0
                },
                {
                    "sent": "And one very good example, City is the city.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We're in now, it's Montpelier.",
                    "label": 0
                },
                {
                    "sent": "And we hear it's.",
                    "label": 0
                },
                {
                    "sent": "It's very nice.",
                    "label": 0
                },
                {
                    "sent": "It is so far and, but we also want to find some data or have some data about Montpelier, and there's several kinds of data that we can find on the on DB pedia on euros that there are several kinds of open data we can find in different sources.",
                    "label": 0
                },
                {
                    "sent": "For example, we have numbers for population.",
                    "label": 0
                },
                {
                    "sent": "We have numbers for the area.",
                    "label": 0
                },
                {
                    "sent": "We also have a number for the average temperature in May, and currently it's actually a little bit below their average temperature than it should be.",
                    "label": 0
                },
                {
                    "sent": "But there also.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Gaps in this data, so we cannot find any any numbers for the CO2 emissions per person of the city, or.",
                    "label": 0
                },
                {
                    "sent": "The average temperature in May in Fahrenheit.",
                    "label": 0
                },
                {
                    "sent": "Or another example would be the population density.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But if you know what well the population density is normally defined by dividing the population number by the area, and we have both values for the city, but we don't have a value for population density.",
                    "label": 1
                },
                {
                    "sent": "So our contribution will be to to add equations to a tee box so that we can actually infer infer concrete values.",
                    "label": 0
                },
                {
                    "sent": "Numbers in this case.",
                    "label": 0
                },
                {
                    "sent": "Like for example, the population density.",
                    "label": 1
                },
                {
                    "sent": "Current semantic web reasoners.",
                    "label": 0
                },
                {
                    "sent": "They don't cope really well with normal numbers, so you can't do any kind of inference or computations on these numbers.",
                    "label": 0
                },
                {
                    "sent": "So we have to invent this ourselves.",
                    "label": 0
                },
                {
                    "sent": "And the first question, if you want to have the population densities, what's the area in square kilometers?",
                    "label": 0
                },
                {
                    "sent": "But because if we look at DB pedia, we find numbers for the population 253 thousand people and we have an area which is 56 million square meters.",
                    "label": 1
                },
                {
                    "sent": "So we first would have to compute the area in square kilometers.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So as a first step, if the question is what is the population density of mobilia, we would have to formalize our query as well.",
                    "label": 0
                },
                {
                    "sent": "So we have our data in different data sources.",
                    "label": 0
                },
                {
                    "sent": "We have TV pedia, we have euro stats.",
                    "label": 0
                },
                {
                    "sent": "And for the sake of this presentation, we assume we have all this in a triple store.",
                    "label": 1
                },
                {
                    "sent": "We have it already collected, so we don't have to think about Federated queries or things like that.",
                    "label": 0
                },
                {
                    "sent": "So in an except we have the data we want the results.",
                    "label": 0
                },
                {
                    "sent": "First we need a query.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Naturally, we expressed this in sparkle and it's this very short query we see here on the top, but of course you can also have more complex queries using filters or optionals or any other kind of more complex operators.",
                    "label": 0
                },
                {
                    "sent": "So what's the population then?",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We have to query now.",
                    "label": 0
                },
                {
                    "sent": "Next step we have to query.",
                    "label": 0
                },
                {
                    "sent": "We have the data as a next step we would need an RDF's ontology.",
                    "label": 1
                },
                {
                    "sent": "And why is that?",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Well, because we have, our data are collected now from these different sources.",
                    "label": 0
                },
                {
                    "sent": "But they all use different vocabulary, so they have every one of those has their own namespace.",
                    "label": 0
                },
                {
                    "sent": "So when DB Pedia talks about population total in their own namespace.",
                    "label": 0
                },
                {
                    "sent": "Then we don't know if that's the same when geonames talks about population, so we use our DFS rules RDS inclusion axioms in this case, sub property of to infer that population total of DB pedia is the same as population in geonames.",
                    "label": 0
                },
                {
                    "sent": "There are already lots of our DFS reasoners around and we would like to extend one that works for by rewriting sparkle queries.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "The next would be to extend this artifacts ontology by adding equations so that it supports that we can root, do reasoning or numbers by using these equations.",
                    "label": 0
                },
                {
                    "sent": "How can we do?",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So first, let's let's fix the syntax, so most of the things you see here is standard RDF's we have subclass of domain and range and sub property of.",
                    "label": 0
                },
                {
                    "sent": "So all the things that are not in boxes.",
                    "label": 0
                },
                {
                    "sent": "Old stuff, so to say.",
                    "label": 0
                },
                {
                    "sent": "The thing in the blue boxes it's so we distinguish between what we know from our less object properties and we call them attributes here.",
                    "label": 0
                },
                {
                    "sent": "So attributes are those properties that .2 numbers.",
                    "label": 0
                },
                {
                    "sent": "So we have our DFS domain for numbers as well.",
                    "label": 0
                },
                {
                    "sent": "So for example if we have.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "DP population the property population from DB Pedia that has as domain populated place so that makes sense that something that has a population is populated place.",
                    "label": 0
                },
                {
                    "sent": "Onyx.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Ample for sub property would be.",
                    "label": 0
                },
                {
                    "sent": "The one year we have seen before already, or to say that the geonames population is a sub property of population so we can have a unified vocabulary for this.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "For the a box.",
                    "label": 0
                },
                {
                    "sent": "That's pretty straightforward.",
                    "label": 0
                },
                {
                    "sent": "You can see it here, but it says that Montpelier has a population of 253 thousand people.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Our extension is then to add extent equations here, so we also have a.",
                    "label": 0
                },
                {
                    "sent": "We first need a syntax for the equations and from for the RDF site.",
                    "label": 0
                },
                {
                    "sent": "This would be if we have a population density.",
                    "label": 0
                },
                {
                    "sent": "We invented a new property that's called defined by equation.",
                    "label": 0
                },
                {
                    "sent": "And the object of this triple would be the function with the remaining two things.",
                    "label": 0
                },
                {
                    "sent": "So in this case we would say that is triple that the population density is defined by the function dividing population by area.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "If we have the syntax, we only need the semantics and the semantic.",
                    "label": 1
                },
                {
                    "sent": "Sorry.",
                    "label": 0
                },
                {
                    "sent": "I mean for our DFS and attributes, the semantics is given, so we know that already.",
                    "label": 0
                },
                {
                    "sent": "We only have to add the rule or the semantics of of the equation extension and intuitively this is.",
                    "label": 0
                },
                {
                    "sent": "Intuitively this says that if we have values for all the remaining attributes in the equation, we can infer the new value.",
                    "label": 1
                },
                {
                    "sent": "So for example.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "If we have the equation population density which is defined by dividing population by area and we have to.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Two values for population in the area.",
                    "label": 0
                },
                {
                    "sent": "We can infer the new value.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Which is then the population density and the remaining part is defined here.",
                    "label": 1
                },
                {
                    "sent": "Just make sure that we don't have a division by zero.",
                    "label": 1
                },
                {
                    "sent": "In general, the query answers are not necessarily finite, but we will come to that later as well.",
                    "label": 1
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So how can we?",
                    "label": 0
                },
                {
                    "sent": "How can we implement this kind of system?",
                    "label": 0
                },
                {
                    "sent": "How can we implement this semantics?",
                    "label": 0
                },
                {
                    "sent": "One way would be to use forward forward chaining engine.",
                    "label": 0
                },
                {
                    "sent": "No, that's the slide before.",
                    "label": 0
                },
                {
                    "sent": "So if we have this first have to use a forward chaining engineer rule engine and one possibilities if we have this equation already, we formulate this equation as a rule as you see here.",
                    "label": 0
                },
                {
                    "sent": "If you have an equation in square kilometers, we formula that equation as a rule.",
                    "label": 1
                },
                {
                    "sent": "But if we want to ask for population density, we also need more rules for for each.",
                    "label": 1
                },
                {
                    "sent": "So we need one rule for each variable.",
                    "label": 0
                },
                {
                    "sent": "It occurs in the equation up there, so we need 3 rules for three variables.",
                    "label": 0
                },
                {
                    "sent": "Now let's start.",
                    "label": 0
                },
                {
                    "sent": "Let's try to run this on a forward chaining engine.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We have 3 rules.",
                    "label": 0
                },
                {
                    "sent": "We have two data values.",
                    "label": 0
                },
                {
                    "sent": "We have the population number.",
                    "label": 0
                },
                {
                    "sent": "We have the area number.",
                    "label": 0
                },
                {
                    "sent": "And we can apply the first rule.",
                    "label": 0
                },
                {
                    "sent": "Which says that we compute the population density by dividing the population by the area and we will get this very nice numbers, which has actually lots of digits after the comma, but they skipped some of those here.",
                    "label": 0
                },
                {
                    "sent": "But if we have now this number as well, then the forward chaining engine will say.",
                    "label": 1
                },
                {
                    "sent": "Now we have number for population density and we have a number for population.",
                    "label": 1
                },
                {
                    "sent": "So we can apply the second rule.",
                    "label": 1
                },
                {
                    "sent": "We also have the area into population density, so we can apply the third rule.",
                    "label": 0
                },
                {
                    "sent": "Unfortunately, so in well in an ideal world will get the same values again, but in an implementation you will get rounding errors.",
                    "label": 0
                },
                {
                    "sent": "So here on the last digit areas one rounding error and tease 2 numbers should be the same, but they're not.",
                    "label": 0
                },
                {
                    "sent": "Here we have the same a rounding error on the last digit.",
                    "label": 0
                },
                {
                    "sent": "The two numbers are not the same.",
                    "label": 0
                },
                {
                    "sent": "Then we are in the same situation as in the beginning already.",
                    "label": 0
                },
                {
                    "sent": "We have now two more values for for population and area.",
                    "label": 1
                },
                {
                    "sent": "And we can compute the population density again, but now it's a different number as well.",
                    "label": 1
                },
                {
                    "sent": "So we have a rounding error here.",
                    "label": 0
                },
                {
                    "sent": "Now it's in the last two digits digits already.",
                    "label": 0
                },
                {
                    "sent": "And this will continue forever.",
                    "label": 0
                },
                {
                    "sent": "That's why I have the waiting sign here.",
                    "label": 0
                },
                {
                    "sent": "You will wait forever.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Well, if forward chaining is not working, why not?",
                    "label": 0
                },
                {
                    "sent": "Why not backward chaining?",
                    "label": 0
                },
                {
                    "sent": "Again, we want to ask for population density and we have a rule for that.",
                    "label": 0
                },
                {
                    "sent": "It's the first rule, so we try to we use the first rule and the backward chaining engine works the other way around.",
                    "label": 0
                },
                {
                    "sent": "So we go from the rule from the rule head from the result to the body of the rule.",
                    "label": 0
                },
                {
                    "sent": "As we have population and area in the body of the rule, the backward chaining engine will try to expand both both of them.",
                    "label": 0
                },
                {
                    "sent": "So it will try to when we ask for population density it will try to compute the population.",
                    "label": 1
                },
                {
                    "sent": "But what will happen here is if we try to compute the population density to get to if we try to query for population for population, but we want to query for population density then this rule would actually expect that we know the population density already.",
                    "label": 0
                },
                {
                    "sent": "So that would mean to compute the population density.",
                    "label": 1
                },
                {
                    "sent": "We have to know the population density, which makes no sense.",
                    "label": 0
                },
                {
                    "sent": "And again, this rule application would also continue forever, so we will get an arbitrarily big query and we're back to the same.",
                    "label": 0
                },
                {
                    "sent": "We wait forever.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So what can we do?",
                    "label": 0
                },
                {
                    "sent": "The problem with rules is that we have to specify them in all directions, so we have N rules for N variables.",
                    "label": 0
                },
                {
                    "sent": "We have seen forward chaining does not terminate because of the rounding errors.",
                    "label": 1
                },
                {
                    "sent": "And backward chaining.",
                    "label": 0
                },
                {
                    "sent": "If we do it in this naive way, it also won't terminate because the recursive rules blow up the query arbitrarily.",
                    "label": 1
                },
                {
                    "sent": "And that was even the case only for a single equation.",
                    "label": 0
                },
                {
                    "sent": "If we have more than one equations which will only get worse.",
                    "label": 1
                },
                {
                    "sent": "So since we also want to do query rewriting, we have to somehow break this infinite series of rule applications to get this terminating to get a finite query actually.",
                    "label": 0
                },
                {
                    "sent": "Will come to this later.",
                    "label": 0
                },
                {
                    "sent": "Let me just one minute introduced per.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Rick Griffin algorithm.",
                    "label": 0
                },
                {
                    "sent": "We have heard about it 2 times.",
                    "label": 0
                },
                {
                    "sent": "I think today already.",
                    "label": 0
                },
                {
                    "sent": "So I don't want to say too much about this.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Perfect Drift was introduced by Calvin's and his colleagues in 2007.",
                    "label": 0
                },
                {
                    "sent": "If I remember correctly, and in 2009 they published a very extensive summer School Report on that.",
                    "label": 0
                },
                {
                    "sent": "So if you want to have more details and you can look it up there, but what it does in general is.",
                    "label": 0
                },
                {
                    "sent": "Query rewriting, So what it does is it tries to it as input, so that would be the algorithm it had this input a tee box and a conjunctive query and it will encode the tee box the relevant parts of the tee box in the query.",
                    "label": 0
                },
                {
                    "sent": "So now there you will only have a query and all you have to do is evaluate the query on the box and the tee box is not used anymore.",
                    "label": 0
                },
                {
                    "sent": "In the end, get the certain answers and we will extend this perfect drift in our implementation by the equations.",
                    "label": 1
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK. We have to.",
                    "label": 0
                },
                {
                    "sent": "We have perfect graph.",
                    "label": 0
                },
                {
                    "sent": "Now we have to extend it by equations and one problem that we see here is that originally we have a sparkle query, but the perfect graph algorithm takes this input conjunctive query.",
                    "label": 0
                },
                {
                    "sent": "So there must be something.",
                    "label": 0
                },
                {
                    "sent": "In between, that transforms between these two.",
                    "label": 0
                },
                {
                    "sent": "But first about extending perfect drift by equations.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So let's look at at an example how we can break this infinite series of rule applications that we've seen before.",
                    "label": 0
                },
                {
                    "sent": "Let's imagine we have we have three different equations and we query for the population density.",
                    "label": 0
                },
                {
                    "sent": "When we query for this, the first thing we do is we look at all our equations.",
                    "label": 0
                },
                {
                    "sent": "If we can find one that applies and there is one equation, the first one where population density occurs.",
                    "label": 0
                },
                {
                    "sent": "The same as before we have to query for the area square, kilometers and population.",
                    "label": 0
                },
                {
                    "sent": "Now what we would do again is we would do the same procedure for these two, so we have to query for the area in square kilometers.",
                    "label": 0
                },
                {
                    "sent": "We look at our equations and we see.",
                    "label": 0
                },
                {
                    "sent": "Yeah, they respond and that's the original one that we have seen already.",
                    "label": 0
                },
                {
                    "sent": "But we want to.",
                    "label": 0
                },
                {
                    "sent": "That's exactly the thing this kind of cycle is.",
                    "label": 0
                },
                {
                    "sent": "The thing we want to avoid.",
                    "label": 0
                },
                {
                    "sent": "So what we do is we adorn these two queries by the attribute name that we used in the beginning for the query.",
                    "label": 0
                },
                {
                    "sent": "And intuitively, the semantics of this is if we query for this value for the area in square kilometers.",
                    "label": 0
                },
                {
                    "sent": "Then we do not want to use any equation that contains population density, so this will be ruled out because population density.",
                    "label": 0
                },
                {
                    "sent": "The one here occurs also in the equation, so we don't use that and look at our equations again if we can find another one.",
                    "label": 0
                },
                {
                    "sent": "There is the second one that converts area in square meters to area in square kilometers.",
                    "label": 0
                },
                {
                    "sent": "This one doesn't contain the population density, so we can use that.",
                    "label": 0
                },
                {
                    "sent": "We ask for the area in square meters here, and we do the same again.",
                    "label": 0
                },
                {
                    "sent": "We adorn them by the attribute names that the ones that we used here and here so that we do not use any equations anymore that contain population density or area in square kilometers.",
                    "label": 0
                },
                {
                    "sent": "The same we do for the conversion between square miles and square kilometers.",
                    "label": 0
                },
                {
                    "sent": "We do all the adornment so that we cannot use any equation that population density or area contains which rules out all the other queries and we're finished for this case.",
                    "label": 0
                },
                {
                    "sent": "So now we have.",
                    "label": 0
                },
                {
                    "sent": "A finite set of queries.",
                    "label": 0
                },
                {
                    "sent": "That also gives us a finite result.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now to the algorithm itself.",
                    "label": 0
                },
                {
                    "sent": "This is a already reduced version of the perfect graph algorithm that would thing in the box would be the extension and normally there is also a reduction part.",
                    "label": 0
                },
                {
                    "sent": "A second part that we could leave out because we used only our DFS reasoning where we don't need this.",
                    "label": 0
                },
                {
                    "sent": "So in this extension it says that if you have a have an equation axiom in the tee box.",
                    "label": 0
                },
                {
                    "sent": "And we have an attribute in our query and attribute Atom.",
                    "label": 0
                },
                {
                    "sent": "This attribute item occurs in the.",
                    "label": 0
                },
                {
                    "sent": "In the equation and.",
                    "label": 0
                },
                {
                    "sent": "That the variables in the equation and the adorned attribute names of the attribute.",
                    "label": 0
                },
                {
                    "sent": "That's exactly what we have seen here.",
                    "label": 0
                },
                {
                    "sent": "That the things in the adornments don't occur in the equation.",
                    "label": 0
                },
                {
                    "sent": "So this just captures this semantics.",
                    "label": 0
                },
                {
                    "sent": "If that happens then we can copy the rule and replace an Atom by by the computation.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So in the example, again, if we have now only two.",
                    "label": 0
                },
                {
                    "sent": "Equations and the original query asking for population density.",
                    "label": 0
                },
                {
                    "sent": "Then what the algorithm does is.",
                    "label": 0
                },
                {
                    "sent": "It will go over their query and try to apply the equations.",
                    "label": 0
                },
                {
                    "sent": "So first it will find the equation about population density E1.",
                    "label": 0
                },
                {
                    "sent": "It will copy the original query and replace the pop tents.",
                    "label": 0
                },
                {
                    "sent": "The population density Atom by the computation first selects the population in the area in square kilometers.",
                    "label": 0
                },
                {
                    "sent": "Does the computation here and this X is then the result the same as we have in the original query?",
                    "label": 0
                },
                {
                    "sent": "So we have computed the population density.",
                    "label": 0
                },
                {
                    "sent": "For this one, we cannot apply any other equations, so we but we have added a second query, which is this one.",
                    "label": 0
                },
                {
                    "sent": "So we tried to apply the equations to this query.",
                    "label": 0
                },
                {
                    "sent": "For this population again we could apply the first equation, but since we have population density in the adornment here.",
                    "label": 0
                },
                {
                    "sent": "Which is also in the query.",
                    "label": 0
                },
                {
                    "sent": "That violates our conditions, so we cannot apply it.",
                    "label": 0
                },
                {
                    "sent": "But for the second one for the area in square kilometers, we have an equation and states the equation 2.",
                    "label": 0
                },
                {
                    "sent": "And that one we can apply again.",
                    "label": 0
                },
                {
                    "sent": "We copy the whole query so we have also population density population here with the population density adornment.",
                    "label": 0
                },
                {
                    "sent": "And we replace the area in square kilometers by area in square meters and the corresponding computation.",
                    "label": 0
                },
                {
                    "sent": "Now we cannot apply any other equations anymore.",
                    "label": 0
                },
                {
                    "sent": "So we're finished.",
                    "label": 0
                },
                {
                    "sent": "We have.",
                    "label": 0
                },
                {
                    "sent": "We have three conjunctive queries and that concludes our rewriting.",
                    "label": 0
                },
                {
                    "sent": "I think I will skip this.",
                    "label": 0
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So what we have now is the perfect rewriter.",
                    "label": 0
                },
                {
                    "sent": "This extension by equations we have unions of conjunctive queries.",
                    "label": 0
                },
                {
                    "sent": "They also contain computations.",
                    "label": 0
                },
                {
                    "sent": "And we need one thing we need is the sparkle transformator which is.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Essentially, transforms which first the basic graph patterns rewrites the basic graph patterns to conjunctive queries.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So they can be used by the perfect riff algorithm.",
                    "label": 0
                },
                {
                    "sent": "Here we have contracted queries.",
                    "label": 0
                },
                {
                    "sent": "The perfect drift algorithm will return conjunctive queries with equations and this partial transformator.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Will then transform, will then collect all these rewritten queries and spit out and use partial query.",
                    "label": 0
                },
                {
                    "sent": "Where the equations so that variable assignments are rewritten to Sparkle 1 one point.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "If we look at the example again, we have.",
                    "label": 0
                },
                {
                    "sent": "These are the three rules.",
                    "label": 0
                },
                {
                    "sent": "The three conjunctive queries that were the output of the perfect of the extended perfect REF algorithm.",
                    "label": 0
                },
                {
                    "sent": "This was the original query.",
                    "label": 0
                },
                {
                    "sent": "And the sparkle Transformator will then make replace this original query by the rewriting, which is in this case.",
                    "label": 0
                },
                {
                    "sent": "I said if unions so we have free reunions.",
                    "label": 0
                },
                {
                    "sent": "The first query will be replaced by this one, so the second query is this one.",
                    "label": 0
                },
                {
                    "sent": "Here you see the bind, we have the computation here.",
                    "label": 0
                },
                {
                    "sent": "XS P / A and we have the same equation here.",
                    "label": 0
                },
                {
                    "sent": "So we say that the population the population divided by the area is the population density.",
                    "label": 0
                },
                {
                    "sent": "That's the extent is selected here.",
                    "label": 0
                },
                {
                    "sent": "The same for the last one.",
                    "label": 0
                },
                {
                    "sent": "So all we need now.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is a sparkle engine because the output of this partial transformator is a spark queries that we can use any kind of sparkle engine.",
                    "label": 0
                },
                {
                    "sent": "To evaluate this.",
                    "label": 0
                },
                {
                    "sent": "I don't have my.",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Time left, but we also did some preliminary evaluation where we compared China forward rules.",
                    "label": 0
                },
                {
                    "sent": "With our implementation with our rewriting.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Normally.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Normally the if you have forward rules, you get the problem that I explained in the beginning already.",
                    "label": 0
                },
                {
                    "sent": "We have rounding errors, so this just didn't terminate transfer for no query we had.",
                    "label": 0
                },
                {
                    "sent": "For.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This alternative implementation where which is kind of an alternative implementation of our semantics.",
                    "label": 0
                },
                {
                    "sent": "It did.",
                    "label": 0
                },
                {
                    "sent": "Terminate, but our rewriting was normally faster.",
                    "label": 0
                },
                {
                    "sent": "It's around 7:00 or 8 seconds and the channel forward rules with this no value.",
                    "label": 0
                },
                {
                    "sent": "Was took around 30 seconds.",
                    "label": 0
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So conclusions the most important part is that we have lots of numbers.",
                    "label": 0
                },
                {
                    "sent": "In the in open data, so we have lots of numbers, so reasoning on them and using equations is important and using equation equations is also feasible.",
                    "label": 1
                },
                {
                    "sent": "We have seen rule engines are not very well suited if you do it in a naive way.",
                    "label": 0
                },
                {
                    "sent": "But if you do query rewriting, you can do this even on Publix, Publix, partial endpoints, and in the end we have seen that it can be faster.",
                    "label": 0
                },
                {
                    "sent": "So if you don't know it by now, the population density of Mobile is 4447.9.",
                    "label": 0
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "So my question is about more less the complexity of the algorithm of the perfect rewriting or with a table decorations.",
                    "label": 0
                },
                {
                    "sent": "So can it?",
                    "label": 0
                },
                {
                    "sent": "Is it exponential because I think it can go into exponential algorithm easily, because if you have nested nested function ratings then.",
                    "label": 0
                },
                {
                    "sent": "You can, you can have equations that are, so did use the same attributes over and over again.",
                    "label": 0
                },
                {
                    "sent": "Yeah, well in general for dialight.",
                    "label": 0
                },
                {
                    "sent": "I mean we use only the RDF's fragment of delight, but in general for delight you have already a problem.",
                    "label": 0
                },
                {
                    "sent": "The complexity, the data complexity is is extractable but the rewriting will blow up exponentially anyways.",
                    "label": 0
                },
                {
                    "sent": "So and we will have this exponential blowup.",
                    "label": 0
                },
                {
                    "sent": "I think we have that exponential blowup as well so well, it's not better than dialight, but it's also not worse.",
                    "label": 0
                },
                {
                    "sent": "You said that you said something about 8 seconds of rewriting.",
                    "label": 0
                },
                {
                    "sent": "That seems pretty long is it?",
                    "label": 0
                },
                {
                    "sent": "Can you explain that that was the query evaluation that was not the rewriting itself?",
                    "label": 0
                },
                {
                    "sent": "That was only the query evaluation, so I can assume that query writing is really fast.",
                    "label": 0
                },
                {
                    "sent": "Or I think yeah, yeah, OK, sorry misunderstood.",
                    "label": 0
                },
                {
                    "sent": "More questions.",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "In this scenario, you actually are only allowed to define functions for for the same individual that that you also have assigned the other values to write.",
                    "label": 0
                },
                {
                    "sent": "So you might ask for give me the average weight of the monkey gay people and you want actually to get this by collecting all the citizens of multi year and then, but then assign the function actually to the city of monkey.",
                    "label": 0
                },
                {
                    "sent": "What so I mean, what do you think of that?",
                    "label": 0
                },
                {
                    "sent": "That's very different, and that's I think that that's harder to do or no.",
                    "label": 0
                },
                {
                    "sent": "Yeah, something else.",
                    "label": 1
                },
                {
                    "sent": "So I mean that would be you could do this with sparkle.",
                    "label": 0
                },
                {
                    "sent": "On top of that, if you define I'm just I mean there you just would use normal sparkle aggregates.",
                    "label": 0
                },
                {
                    "sent": "I would say for that.",
                    "label": 0
                },
                {
                    "sent": "If you had the symptoms anyway, but that would be more expressive than.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "That's yeah, yeah yeah, we yeah, yeah, we still have a few minutes so we can of course.",
                    "label": 0
                },
                {
                    "sent": "Still on aggregates, why is aggregate changing so much?",
                    "label": 0
                },
                {
                    "sent": "The thing I mean?",
                    "label": 0
                },
                {
                    "sent": "Is it the message issue or do you think that it's it's more expressive than we have here, but you can?",
                    "label": 0
                },
                {
                    "sent": "We could define a rewriting that uses aggregates in this part website, yes, but then we cannot use unions of conjunctive queries in the middle anymore because aggregates are more expressive than you conjunctive queries.",
                    "label": 0
                },
                {
                    "sent": "Well, I mean what I wanted to say was, I mean basically you don't need to the aggregate in this formalism, because since we support so we we just take any basic graph pattern in the sparkle query and apply the rewriting.",
                    "label": 0
                },
                {
                    "sent": "OK so if you have an aggregate outside aggregate and all other operators or sparkler always evaluated on top of basic graph pattern evaluation.",
                    "label": 0
                },
                {
                    "sent": "So you can absolutely just have an aggregate in sparkly.",
                    "label": 0
                },
                {
                    "sent": "It doesn't have to do anything with our formalism, that's the same as having optional cruise or whatever on top.",
                    "label": 0
                },
                {
                    "sent": "But you would have aggregates in the definition of your functions, right?",
                    "label": 0
                },
                {
                    "sent": "So that's and that makes it more complex.",
                    "label": 0
                },
                {
                    "sent": "Like the average population density by an aggregate, yeah?",
                    "label": 0
                },
                {
                    "sent": "Ah OK, that's what I meant.",
                    "label": 0
                },
                {
                    "sent": "I mean, we need to be happy.",
                    "label": 0
                },
                {
                    "sent": "Would be interesting.",
                    "label": 0
                },
                {
                    "sent": "OK, more questions comments.",
                    "label": 0
                },
                {
                    "sent": "How?",
                    "label": 0
                },
                {
                    "sent": "So we compared to the previous session about special data.",
                    "label": 0
                },
                {
                    "sent": "The focus is out to to write a query with a special query on.",
                    "label": 0
                },
                {
                    "sent": "After all the staff are special stuff is made in a, you know put a Postgres SQL database.",
                    "label": 0
                },
                {
                    "sent": "Why do you want that sparkle of that?",
                    "label": 0
                },
                {
                    "sent": "The series owner is able to make aggravation because in database system like data Warehouse under there is aggregation function on something like that which perform.",
                    "label": 0
                },
                {
                    "sent": "Very good, So what is the use case of?",
                    "label": 0
                },
                {
                    "sent": "Building a specific things with Buckle on his owner.",
                    "label": 0
                },
                {
                    "sent": "So yeah, originally the delight system that Diego Calvanese and his colleagues introduced is working on relational databases so.",
                    "label": 0
                },
                {
                    "sent": "That's that's the main use case, or the scenario of ontology based data access.",
                    "label": 0
                },
                {
                    "sent": "In our case, we say we want to query open data and open data that is already available.",
                    "label": 0
                },
                {
                    "sent": "As our DFS is RDF.",
                    "label": 0
                },
                {
                    "sent": "The other thing is that we had.",
                    "label": 0
                },
                {
                    "sent": "Quite the big ontology and the problem is that normally you have very sparse data.",
                    "label": 0
                },
                {
                    "sent": "We had for some cities we have lots of data, so we have hundreds or even thousands of attributes.",
                    "label": 0
                },
                {
                    "sent": "And for some cities we have only two numbers.",
                    "label": 0
                },
                {
                    "sent": "So if we put it in a in a relational databases it will.",
                    "label": 0
                },
                {
                    "sent": "It will be very sparse.",
                    "label": 0
                },
                {
                    "sent": "That's why we used RDF and we used sparkly because we used RDF.",
                    "label": 0
                },
                {
                    "sent": "OK, so let's think I will speak again.",
                    "label": 0
                }
            ]
        }
    }
}