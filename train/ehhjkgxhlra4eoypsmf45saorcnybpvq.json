{
    "id": "ehhjkgxhlra4eoypsmf45saorcnybpvq",
    "title": "Directed Search for Generalized Plans Using Classical Planners",
    "info": {
        "author": [
            "Siddharth Srivastava, University of Massachusetts Amherst"
        ],
        "published": "July 21, 2011",
        "recorded": "June 2011",
        "category": [
            "Top->Computer Science->Artificial Intelligence->Planning and Scheduling"
        ]
    },
    "url": "http://videolectures.net/icaps2011_srivastava_planners/",
    "segmentation": [
        [
            "So this is joint work with Neil ever manage to Mozilla Steen and Kathy Shank?"
        ],
        [
            "So.",
            "Let me let me start by describing what I mean by the generalized planning problem.",
            "So we are given a domain and set of initial States and a goal formula, and we want to find a generalized plan that solves all of those initial states.",
            "So the interesting part is that those initial states could come from different state spaces, and there could be infinitely many of them.",
            "OK, so you can imagine a grid traversal problem where your agent is at the square marked X and you want to traverse the entire grid.",
            "Now the initial state could come from any of those grids.",
            "Or another interesting problem is where you can imagine a singly linked list and you're planning problem is to reverse this link list with generalized version of.",
            "That is to look at a linked list of an unknown size or look at a bunch of linked lists of different sizes and to find a generalized plan.",
            "On an algorithm that will reverse the linked list of any size.",
            "So intuitively this is a good formalization in the sense that it captures lots of interesting problems and I'm going to make this a little more specific because everything in italics.",
            "There is quite vague."
        ],
        [
            "Right now.",
            "So there have been a few approaches addressing such problems, and in the early 70s and 80s there were approaches addressing the issues of plan reuse, but these approaches didn't really address the problems of finding plans with loops, which we'll see are really required to address such problems.",
            "Now more recently, in planning there has been a revival of interest in finding plans with loops and the approaches here are mostly about recognizing repetitive patterns in plants or on finding cyclic controllers for solving problems partially observable problems.",
            "So in the work that I'm going to present here, we're going to focus on three main objectives.",
            "We want to find generalized plans that are guaranteed to be terminating and correct, and we also want to work in the paradigm of directed generalization where we are given a class of problem instances of interest, and we want to find a generalized plan that solves all of them rather than first producing a generalization and then discovering the class of problems that it might solve.",
            "So these factors.",
            "This combination of factors is not really addressed by the existing approaches, and I'm going to try to describe 'em."
        ],
        [
            "Thanks for doing that.",
            "OK, so I'll first describe state in action representation and this has been discussed earlier, represented earlier, so I'm."
        ],
        [
            "I'm going to discuss only the main point.",
            "So we describe states as logical structures in first order logic with transitive closure.",
            "So in the blocks world, for instance, we use this vocabulary or this set of predicates an.",
            "The only interesting thing here is that we are also using the transitive closure of on and I'll describe why that is useful.",
            "So in our approach we use a state abstraction technique from model checking, and the way this abstraction works is that first you define the role of an element as the set of unary predicates that it satisfies.",
            "So in this example, for instance we have 3 rules in play, a, B&C, and you can see that there's only one object which satisfies roll A.",
            "It is clear and there a couple of objects that satisfies the role B or the OR the.",
            "Rule where the objects are neither clear nor on table.",
            "And in the abstraction, what we do is simply collapse all objects of the same role into a collected object.",
            "So this element here for instance is a summary element or a collection representing multiple objects.",
            "And to make things formally correct, what we do is we change the truth values of relationships with these objects so that any relationship where you have multiple possible truth values, you just make them half.",
            "To indicate an unknown.",
            "So the interesting part of this abstraction is that such abstract states basically represent infinitely many real states, so this.",
            "This abstract state where you have a block on top of block at the bottom and an unknown number of blocks in the middle, actually represents towers of blocks of unknown height.",
            "OK, and this is very transitive.",
            "Closure comes in because even in the abstraction, transitive closure preserves some properties.",
            "So here we can see for instance, that the block marked A is above all blocks in the collection B, so that truth value is 1."
        ],
        [
            "OK, now applying actions on such states, we basically have an action mechanism that produces all possible results when applied on an abstract state.",
            "So here we are trying to move a block to the table and we get two possible results, one where there's nothing left in the middle of the tower and one where we still have blocks in the middle.",
            "So this captures all possibilities of applying an action on an abstract state.",
            "And such action operations are actually quite general or quite expressive.",
            "An using this kind of an operation and then changing predicates.",
            "You can exponentially express any computation.",
            "So this is quite a rich framework using just this kind of an action representation."
        ],
        [
            "OK, so.",
            "I'm now going to define what I mean by a generalized plan.",
            "So we use directed acyclic or directed cyclic graphs to represent generalize plans.",
            "So on the right we see a generalized plan for traversing a grid.",
            "It has a special start state and a special stop state, and its nodes are labeled by actions and edges are labeled by conditions.",
            "So if you can't see this very clearly, it's it's not very important and I'll actually describe a more specific generalized plan later.",
            "So if you like to look at it as automater, then you can think of generalized planets execution as the execution of a finite state transducer, where you have a generalized plan automatron which takes an observation at each step and generates an action to be executed."
        ],
        [
            "OK so I'm not ready to describe the generalized planning problem more formally, so as I said before, we have a domain and by the domain I mean a predicate vocabulary or the set of predicates that we can use in a problem.",
            "A set of actions and a set of integrity constraints.",
            "So I'm going to give you an example of what I mean by integrity constraints.",
            "And we are given a goal formula in first order logic with transitive closure.",
            "So the goal formula could be something like for all X on table legs or so.",
            "We just want all blocks in the table.",
            "Now our problem is to find a generalized plan that solves every initial state and what do I mean by solving, I mean that every possible execution of that generalized plan on the initial state should end at the goal state in a finite number of steps."
        ],
        [
            "OK.",
            "So I'm not ready to describe our algorithm for generalized."
        ],
        [
            "Synthesis and the overall idea here is to use classical planners because our observation is that classical planners are really good at solving fully specified problem instances fully specified small problem instances or tractable problem instances.",
            "So what we're going to do is take an example unsolved problem instance and then generate a classical plan for solving that particular instance.",
            "We're then going to generalize it and merge it back into an existing generalized plan.",
            "And repeat this process until either we run out of open problems that is recovered the whole initial state initial class of problems of interest or until we reach a pre specified resource limit."
        ],
        [
            "So let me illustrate the whole idea with this simple example and I'm saying simple.",
            "It's actually really trivial.",
            "You have a tower of blocks and you want them all to be on the table, right?",
            "The complication is that you don't know how many blocks there are.",
            "OK, so let's say this is our initial abstract state, and that's going to be the start node of our generalized plan, so I'm going to use a dual representation here, because that just makes it easier to describe the algorithm.",
            "So that's our start node.",
            "The first thing we do is to create an instance of this initial abstract state.",
            "So let's say we get simple three block tower where we hand it to a classical planner and the classical planner will give us a plan that looks something like this.",
            "It simply moves those two blocks to the table.",
            "Now the idea is to apply these.",
            "This sequence of actions or this classical plan back on the abstract state.",
            "But the problem is that these object names that the classical plan uses don't really mean anything in the general problem, and they don't even exist in the abstract state.",
            "So what we do is we take this classical plan and we add choice actions or actions which are telling us that instead of moving block one to the table, you choose a block which satisfies the same role as block one and move that to the table.",
            "So by generating such action with the.",
            "Joyce, operations before the actions we can go ahead and apply this action on the abstract state just like I."
        ],
        [
            "Earlier and we get something like this, so that gives us all the possibilities of applying a move to table operation on this tower of unknown height.",
            "Right now in the next step we need to choose where we want to apply the next action, so we apply it only on the structure that matches what we saw in the classical plan execution that is, in the execution of this plan.",
            "Here an in this case, that is this structure.",
            "So we go ahead and apply the next action and that leads us to the.",
            "Goldstate OK, So what this trace means is that some of the initial states represented by the initial abstract state are actually taken to the goal by this sequence of actions.",
            "But there are some other states represented by the initial state by the state that end up in this.",
            "Abstract state so these are our unhandled problem instances or the problems that this example plan did not really address, so we go ahead and call this an open note for our plan or node that is terminal but not the goal node.",
            "So."
        ],
        [
            "So the overall idea is to keep finding these open nodes and creating example plans for solving them."
        ],
        [
            "Right, so we take an example.",
            "An instance of this abstract state.",
            "We go ahead and do our classical planner in vacation and we apply the resulting plan back into this abstract state that in this case gives us another open node.",
            "So we take this and now some interesting things start happening.",
            "We see that when we apply the first move to table operation, we actually get an abstract structure here, which exists in the generalized plan so far, so in.",
            "When we get into such situations, we try to merge that state back into what exists already in a generalized plan in the generalized plan, and so this is described in detail in the paper, but sometimes what happens is if you look at this abstract state, it's identical to this one, and if we go ahead and merge them together, we get a loop here.",
            "Now the interesting problem is that such loops may not really terminate, and."
        ],
        [
            "Lately, the action mechanism that we have is expressive enough that it's undecidable in general to prove that such a loop with terminate.",
            "So we use some methods that we developed and presented last year at icaps to find out if a loop abroad classes of a class of broad class of loops created in this way is actually going to terminate.",
            "So this is a sound approach.",
            "It's not complete.",
            "Then we use those methods to determine if a loop that's being created in the generalized plan is actually going to terminate.",
            "OK, so in this case we have a very simple loop and we can assert that it will terminate and the structure that we get at the end of this if you observe there are no open nodes and the only terminal node is the goal state.",
            "So we have a complete plan in the sense that this if you follow the sequence of actions outlined by this plan, then you're going to.",
            "Move all blocks from this from any instance represented by this abstract state to the table."
        ],
        [
            "OK.",
            "So that's an overall picture of the algorithm.",
            "We start with a generalized plan which is initially empty.",
            "We get an open node, generate an instance for it, give it to a classical planner.",
            "We add choice actions to the plan that we get from the classical planner, trace it on the abstract state, and then simply merge it back into the generalized plan.",
            "OK."
        ],
        [
            "So.",
            "In the next few slides, I'll focus on a very small part of this approach, which is on instance generation, and here we want to take a nap SAC state and create a particular instance of this state.",
            "This is actually quite complicated because we want to make sure that the domains properties any integrity constraints in the domain are satisfied when we choose when we are creating that instance.",
            "So what we do is create a first order formula for representing such abstract structures, and these formulas have different components like.",
            "You want to say that there's an element of each role prison.",
            "For example, you would say that there's something that's cleared as something that's on table, and so on, and you want to specify that which elements are exactly unique singletons, so they're not collections you want exactly one element for.",
            "For example, in this structure we have exactly 1 block, that's clear.",
            "So you go ahead and specify all the true and false predicate tuples and also integrity constraints.",
            "And this is the example that I promised, so an integrity constraint here would be something like you can have at most one block above another block on top of another block, right?",
            "So you compose this into a first order logic formula with transitive closure and.",
            "You can hand it off to a model Gen."
        ],
        [
            "Later, except that there is 1 final complication that transitive closure cannot really be handled by a first order model generator.",
            "So what we do is we use this formula here to simulate transitive closure and this formula is accurate for acyclic finite models.",
            "It's accurate in the sense that in terms of the properties entailed, it's going to be sound and complete in these models, so that gives us a way of using an off the shelf model generator to do our instance generation."
        ],
        [
            "And the formal guarantees of this approach.",
            "So I'm not going to go into the details here, but the main point is that if we can prove that the plan terminates and there are no open nodes, then we have a complete solution for the initial abstract states.",
            "So we.",
            "So that's the basic formal guarantee that we provide."
        ],
        [
            "So now."
        ],
        [
            "A few quick results.",
            "This is a description of our instance generation process and we have a bunch of different problem examples here, so the grid problems have a fixed number of rows but unknown or unbounded number of columns, and there are a few blocks problems and these graphs or these lines are simply telling us that whenever you have multiple transitive closure predicates to be synchronized it becomes unscalable very fast.",
            "So those are these.",
            "These three lines here are basically dealing with transitive closure.",
            "And I can answer questions about this if there's any."
        ],
        [
            "Stressed so here are our main results and there are too many numbers here, so I'm going to focus mostly on this rule for the reverse problem.",
            "So this is the reverse linkage problem and the other problems here are in there.",
            "Some in transport, some in the grid world navigation and some in the blocks world.",
            "So the interesting problems are reversed and sorting, which are algorithms synthesis problems in reverse.",
            "We basically used seven planner invocations and the largest problem structure that we used was of size.",
            "8 and this is.",
            "6 is the largest plan that we generated, so these are very simple problems for classical planners.",
            "And we produced a plan that was terminating.",
            "That is, it is guaranteed to terminate.",
            "It had complete coverage, but there's no P in this column, and that's basically indicating that we didn't get a proof of complete coverage because our approach generated an open node that was unreachable, so we couldn't.",
            "The abstraction was a little imprecise there, so on the other hand, if we used an instance generation mode where.",
            "For each collection we generated at least five objects, we could find a generalized plan for reversing the linked list, which was which terminated, which is guaranteed to terminate had complete coverage, and also had a proof of complete coverage in the sense that there were no open roads left."
        ],
        [
            "So to conclude, we have an approach here which utilizes the heuristic search capabilities of classical planners to do a search in the abstract state space, and in doing so we are actually searching over simultaneously over infinitely many problem instances, and this is very useful because otherwise we'd have to develop some new heuristics for searching in the abstract state trace directly.",
            "Now in the future, the most challenging aspect is developing more robust termination tests, because that's the current stublic box block that we're facing.",
            "We can do everything, but as long as we cannot analyze a more general class of loops for termination, we cannot find more general.",
            "We cannot solve more general classes of problems.",
            "And also identification of those open nodes that are actually unreachable or unsolvable so that we can save time and not try to give those open nodes to classical planners to solve, thank you.",
            "Hi so.",
            "If the examples you were using to reserve the ideas were representative got all problems were about.",
            "An some it's called resource or.",
            "The set of objects that are identical applications on the grid or blocks stacked on top of the tower that we should.",
            "Do something with all of them, or with many of them.",
            "I don't know something like that.",
            "So I wonder whether this particular class of problem cannot be translate compiled into something like.",
            "You know blocking the tower is higher than two blocks or not.",
            "And then we have a non deterministic problem.",
            "So picking a block at putting until onto the table either.",
            "Leaves you with, you know, no tower or keep.",
            "Keeps you at the same state.",
            "And then I don't know, for example, applying by Bly and the actor for devising controller.",
            "So right so so the whole thing is that we actually go into a state into a problem into an abstract state space that has exactly that kind of an action mechanism.",
            "But the difference is that we want to prove that that loop that you create is going to terminate.",
            "So you can have a situation where you have multiple possible loops and they see they all seem to look fine, but.",
            "We want to determine that they terminate.",
            "Yeah.",
            "Related to that question, so any way to characterize the type of problems with these will work OK.",
            "I'm not asking for a for my completeness with salt, but some idea Pro.",
            "For instance, the example that he had.",
            "If you had dropped.",
            "Above predicate is a transitive closure of on.",
            "Probably would not have worked OK, so any idea?",
            "But what is gonna work when you have to engineer the the predicates in the domain so that will work and so on, right?",
            "So as you mentioned, the transitive closure is something that we tend to use very often.",
            "Whenever binary relations are involved, but one class of domains where which depending on your perspective may or may not be interesting.",
            "Where this will always work is if you had only unary predicates.",
            "In your domain, then the problem is relatively easy to analyze.",
            "It still undesirable in general, but the basic approach of finding out preconditions of plans, etc.",
            "Those approaches will work straightforward.",
            "You won't run out of abstraction predicates in that case.",
            "So usually if you try to engineer your domain so that you have unary predicates to represent the key important properties, then these kind of methods tend to work.",
            "So it looks like you can.",
            "The way you solve these problems that you construct.",
            "These generalized plans is that you group the objects in the domain into sort of boundary objects and then objects that aren't boundary, and so for the non boundary objects you basically generalizing over N, right?",
            "So how does that relate to some of the generalizing numbers?",
            "Stuff that was done?",
            "I think back in the 80s I so are you referring to something like Jude Shavlik's approach?",
            "Yeah yeah yeah.",
            "So so.",
            "So to clarify the abstraction that we have is not really about boundary and on boundary that happens if you use transitive closure.",
            "In general we're trying to collect objects that looks similar in terms of unary predicates together an in comparison with approaches like generalization to N. There you were.",
            "So those approaches are about looking at the structure of a proof.",
            "For via plan works, and to generalize that structure.",
            "But again, you get loops there, but you don't know whether they will ever terminate so.",
            "If they will terminate, so that is a difference with those approaches as well.",
            "So what kind of termination check do you use?",
            "I mean, I know there is some work by undress, put their skin and so on.",
            "Also, like the more sophisticated termination checker, so can you say some more words about right?",
            "So we had some work that we presented last year about this specific termination check we use, But the idea is to look at the number of elements in each role or the number of elements that satisfy your role and to see the changes in that in every strongly connected component that you find.",
            "And just like.",
            "A ranking function.",
            "For instance, you show that there is some element whose role is always decreasing in the loop.",
            "Or you?",
            "I mean, you move from that idea that you want to find an element or a role whose count is decreasing in the loop and it cannot decrease forever.",
            "So it must terminate.",
            "That's the general idea.",
            "So you found the standard techniques from verification community are not very suitable in those applications.",
            "Well, they could be useful.",
            "So for instance, the abstraction that I described is actually based on a method from the program verification community.",
            "I'll ask a final question and thank the speaker at the same time, just related to Hector's question.",
            "I'm wondering whether if there's a bound on on some sort of resource founder on, for example, the capacity of a table or the weather that that puts a limit on on this looping structure as well.",
            "So let's say that you're putting blocks onto a table, but the table can only contain 10 blocks, so so it works.",
            "For instance one to 10, but then after that you hit this sort of transition point.",
            "So are you asking about the bounds on the method, or if we can solve a plan with such bounds or solve a problem with such power, whether that class of problems would work with your right?",
            "So so we've thought about different ways of expressing those thresholds or counts, and in some cases we can just convert them into role counts an express a goal as saying something like we need at least five objects in the tower and at least 10 on the table and so on.",
            "So in some cases we can handle them.",
            "But you have to know apriori that that's going to limit your plan in some way so that you can integrate.",
            "It's going to give you an exit condition for a loop, so depending on how many such conditions you have, you may want to fix it as a constant or in some cases you could do it symbolically."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So this is joint work with Neil ever manage to Mozilla Steen and Kathy Shank?",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "Let me let me start by describing what I mean by the generalized planning problem.",
                    "label": 0
                },
                {
                    "sent": "So we are given a domain and set of initial States and a goal formula, and we want to find a generalized plan that solves all of those initial states.",
                    "label": 1
                },
                {
                    "sent": "So the interesting part is that those initial states could come from different state spaces, and there could be infinitely many of them.",
                    "label": 0
                },
                {
                    "sent": "OK, so you can imagine a grid traversal problem where your agent is at the square marked X and you want to traverse the entire grid.",
                    "label": 0
                },
                {
                    "sent": "Now the initial state could come from any of those grids.",
                    "label": 0
                },
                {
                    "sent": "Or another interesting problem is where you can imagine a singly linked list and you're planning problem is to reverse this link list with generalized version of.",
                    "label": 0
                },
                {
                    "sent": "That is to look at a linked list of an unknown size or look at a bunch of linked lists of different sizes and to find a generalized plan.",
                    "label": 0
                },
                {
                    "sent": "On an algorithm that will reverse the linked list of any size.",
                    "label": 0
                },
                {
                    "sent": "So intuitively this is a good formalization in the sense that it captures lots of interesting problems and I'm going to make this a little more specific because everything in italics.",
                    "label": 0
                },
                {
                    "sent": "There is quite vague.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Right now.",
                    "label": 0
                },
                {
                    "sent": "So there have been a few approaches addressing such problems, and in the early 70s and 80s there were approaches addressing the issues of plan reuse, but these approaches didn't really address the problems of finding plans with loops, which we'll see are really required to address such problems.",
                    "label": 0
                },
                {
                    "sent": "Now more recently, in planning there has been a revival of interest in finding plans with loops and the approaches here are mostly about recognizing repetitive patterns in plants or on finding cyclic controllers for solving problems partially observable problems.",
                    "label": 1
                },
                {
                    "sent": "So in the work that I'm going to present here, we're going to focus on three main objectives.",
                    "label": 0
                },
                {
                    "sent": "We want to find generalized plans that are guaranteed to be terminating and correct, and we also want to work in the paradigm of directed generalization where we are given a class of problem instances of interest, and we want to find a generalized plan that solves all of them rather than first producing a generalization and then discovering the class of problems that it might solve.",
                    "label": 0
                },
                {
                    "sent": "So these factors.",
                    "label": 1
                },
                {
                    "sent": "This combination of factors is not really addressed by the existing approaches, and I'm going to try to describe 'em.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Thanks for doing that.",
                    "label": 0
                },
                {
                    "sent": "OK, so I'll first describe state in action representation and this has been discussed earlier, represented earlier, so I'm.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "I'm going to discuss only the main point.",
                    "label": 0
                },
                {
                    "sent": "So we describe states as logical structures in first order logic with transitive closure.",
                    "label": 1
                },
                {
                    "sent": "So in the blocks world, for instance, we use this vocabulary or this set of predicates an.",
                    "label": 0
                },
                {
                    "sent": "The only interesting thing here is that we are also using the transitive closure of on and I'll describe why that is useful.",
                    "label": 0
                },
                {
                    "sent": "So in our approach we use a state abstraction technique from model checking, and the way this abstraction works is that first you define the role of an element as the set of unary predicates that it satisfies.",
                    "label": 1
                },
                {
                    "sent": "So in this example, for instance we have 3 rules in play, a, B&C, and you can see that there's only one object which satisfies roll A.",
                    "label": 0
                },
                {
                    "sent": "It is clear and there a couple of objects that satisfies the role B or the OR the.",
                    "label": 0
                },
                {
                    "sent": "Rule where the objects are neither clear nor on table.",
                    "label": 0
                },
                {
                    "sent": "And in the abstraction, what we do is simply collapse all objects of the same role into a collected object.",
                    "label": 0
                },
                {
                    "sent": "So this element here for instance is a summary element or a collection representing multiple objects.",
                    "label": 0
                },
                {
                    "sent": "And to make things formally correct, what we do is we change the truth values of relationships with these objects so that any relationship where you have multiple possible truth values, you just make them half.",
                    "label": 0
                },
                {
                    "sent": "To indicate an unknown.",
                    "label": 0
                },
                {
                    "sent": "So the interesting part of this abstraction is that such abstract states basically represent infinitely many real states, so this.",
                    "label": 0
                },
                {
                    "sent": "This abstract state where you have a block on top of block at the bottom and an unknown number of blocks in the middle, actually represents towers of blocks of unknown height.",
                    "label": 0
                },
                {
                    "sent": "OK, and this is very transitive.",
                    "label": 1
                },
                {
                    "sent": "Closure comes in because even in the abstraction, transitive closure preserves some properties.",
                    "label": 0
                },
                {
                    "sent": "So here we can see for instance, that the block marked A is above all blocks in the collection B, so that truth value is 1.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, now applying actions on such states, we basically have an action mechanism that produces all possible results when applied on an abstract state.",
                    "label": 0
                },
                {
                    "sent": "So here we are trying to move a block to the table and we get two possible results, one where there's nothing left in the middle of the tower and one where we still have blocks in the middle.",
                    "label": 0
                },
                {
                    "sent": "So this captures all possibilities of applying an action on an abstract state.",
                    "label": 0
                },
                {
                    "sent": "And such action operations are actually quite general or quite expressive.",
                    "label": 0
                },
                {
                    "sent": "An using this kind of an operation and then changing predicates.",
                    "label": 0
                },
                {
                    "sent": "You can exponentially express any computation.",
                    "label": 0
                },
                {
                    "sent": "So this is quite a rich framework using just this kind of an action representation.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so.",
                    "label": 0
                },
                {
                    "sent": "I'm now going to define what I mean by a generalized plan.",
                    "label": 0
                },
                {
                    "sent": "So we use directed acyclic or directed cyclic graphs to represent generalize plans.",
                    "label": 0
                },
                {
                    "sent": "So on the right we see a generalized plan for traversing a grid.",
                    "label": 0
                },
                {
                    "sent": "It has a special start state and a special stop state, and its nodes are labeled by actions and edges are labeled by conditions.",
                    "label": 0
                },
                {
                    "sent": "So if you can't see this very clearly, it's it's not very important and I'll actually describe a more specific generalized plan later.",
                    "label": 0
                },
                {
                    "sent": "So if you like to look at it as automater, then you can think of generalized planets execution as the execution of a finite state transducer, where you have a generalized plan automatron which takes an observation at each step and generates an action to be executed.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK so I'm not ready to describe the generalized planning problem more formally, so as I said before, we have a domain and by the domain I mean a predicate vocabulary or the set of predicates that we can use in a problem.",
                    "label": 0
                },
                {
                    "sent": "A set of actions and a set of integrity constraints.",
                    "label": 1
                },
                {
                    "sent": "So I'm going to give you an example of what I mean by integrity constraints.",
                    "label": 0
                },
                {
                    "sent": "And we are given a goal formula in first order logic with transitive closure.",
                    "label": 0
                },
                {
                    "sent": "So the goal formula could be something like for all X on table legs or so.",
                    "label": 0
                },
                {
                    "sent": "We just want all blocks in the table.",
                    "label": 0
                },
                {
                    "sent": "Now our problem is to find a generalized plan that solves every initial state and what do I mean by solving, I mean that every possible execution of that generalized plan on the initial state should end at the goal state in a finite number of steps.",
                    "label": 1
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "So I'm not ready to describe our algorithm for generalized.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Synthesis and the overall idea here is to use classical planners because our observation is that classical planners are really good at solving fully specified problem instances fully specified small problem instances or tractable problem instances.",
                    "label": 0
                },
                {
                    "sent": "So what we're going to do is take an example unsolved problem instance and then generate a classical plan for solving that particular instance.",
                    "label": 1
                },
                {
                    "sent": "We're then going to generalize it and merge it back into an existing generalized plan.",
                    "label": 0
                },
                {
                    "sent": "And repeat this process until either we run out of open problems that is recovered the whole initial state initial class of problems of interest or until we reach a pre specified resource limit.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So let me illustrate the whole idea with this simple example and I'm saying simple.",
                    "label": 0
                },
                {
                    "sent": "It's actually really trivial.",
                    "label": 0
                },
                {
                    "sent": "You have a tower of blocks and you want them all to be on the table, right?",
                    "label": 0
                },
                {
                    "sent": "The complication is that you don't know how many blocks there are.",
                    "label": 0
                },
                {
                    "sent": "OK, so let's say this is our initial abstract state, and that's going to be the start node of our generalized plan, so I'm going to use a dual representation here, because that just makes it easier to describe the algorithm.",
                    "label": 0
                },
                {
                    "sent": "So that's our start node.",
                    "label": 1
                },
                {
                    "sent": "The first thing we do is to create an instance of this initial abstract state.",
                    "label": 0
                },
                {
                    "sent": "So let's say we get simple three block tower where we hand it to a classical planner and the classical planner will give us a plan that looks something like this.",
                    "label": 0
                },
                {
                    "sent": "It simply moves those two blocks to the table.",
                    "label": 0
                },
                {
                    "sent": "Now the idea is to apply these.",
                    "label": 0
                },
                {
                    "sent": "This sequence of actions or this classical plan back on the abstract state.",
                    "label": 0
                },
                {
                    "sent": "But the problem is that these object names that the classical plan uses don't really mean anything in the general problem, and they don't even exist in the abstract state.",
                    "label": 1
                },
                {
                    "sent": "So what we do is we take this classical plan and we add choice actions or actions which are telling us that instead of moving block one to the table, you choose a block which satisfies the same role as block one and move that to the table.",
                    "label": 0
                },
                {
                    "sent": "So by generating such action with the.",
                    "label": 0
                },
                {
                    "sent": "Joyce, operations before the actions we can go ahead and apply this action on the abstract state just like I.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Earlier and we get something like this, so that gives us all the possibilities of applying a move to table operation on this tower of unknown height.",
                    "label": 0
                },
                {
                    "sent": "Right now in the next step we need to choose where we want to apply the next action, so we apply it only on the structure that matches what we saw in the classical plan execution that is, in the execution of this plan.",
                    "label": 0
                },
                {
                    "sent": "Here an in this case, that is this structure.",
                    "label": 0
                },
                {
                    "sent": "So we go ahead and apply the next action and that leads us to the.",
                    "label": 0
                },
                {
                    "sent": "Goldstate OK, So what this trace means is that some of the initial states represented by the initial abstract state are actually taken to the goal by this sequence of actions.",
                    "label": 1
                },
                {
                    "sent": "But there are some other states represented by the initial state by the state that end up in this.",
                    "label": 0
                },
                {
                    "sent": "Abstract state so these are our unhandled problem instances or the problems that this example plan did not really address, so we go ahead and call this an open note for our plan or node that is terminal but not the goal node.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the overall idea is to keep finding these open nodes and creating example plans for solving them.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Right, so we take an example.",
                    "label": 0
                },
                {
                    "sent": "An instance of this abstract state.",
                    "label": 0
                },
                {
                    "sent": "We go ahead and do our classical planner in vacation and we apply the resulting plan back into this abstract state that in this case gives us another open node.",
                    "label": 0
                },
                {
                    "sent": "So we take this and now some interesting things start happening.",
                    "label": 0
                },
                {
                    "sent": "We see that when we apply the first move to table operation, we actually get an abstract structure here, which exists in the generalized plan so far, so in.",
                    "label": 0
                },
                {
                    "sent": "When we get into such situations, we try to merge that state back into what exists already in a generalized plan in the generalized plan, and so this is described in detail in the paper, but sometimes what happens is if you look at this abstract state, it's identical to this one, and if we go ahead and merge them together, we get a loop here.",
                    "label": 0
                },
                {
                    "sent": "Now the interesting problem is that such loops may not really terminate, and.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Lately, the action mechanism that we have is expressive enough that it's undecidable in general to prove that such a loop with terminate.",
                    "label": 0
                },
                {
                    "sent": "So we use some methods that we developed and presented last year at icaps to find out if a loop abroad classes of a class of broad class of loops created in this way is actually going to terminate.",
                    "label": 0
                },
                {
                    "sent": "So this is a sound approach.",
                    "label": 0
                },
                {
                    "sent": "It's not complete.",
                    "label": 0
                },
                {
                    "sent": "Then we use those methods to determine if a loop that's being created in the generalized plan is actually going to terminate.",
                    "label": 1
                },
                {
                    "sent": "OK, so in this case we have a very simple loop and we can assert that it will terminate and the structure that we get at the end of this if you observe there are no open nodes and the only terminal node is the goal state.",
                    "label": 1
                },
                {
                    "sent": "So we have a complete plan in the sense that this if you follow the sequence of actions outlined by this plan, then you're going to.",
                    "label": 1
                },
                {
                    "sent": "Move all blocks from this from any instance represented by this abstract state to the table.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "So that's an overall picture of the algorithm.",
                    "label": 0
                },
                {
                    "sent": "We start with a generalized plan which is initially empty.",
                    "label": 0
                },
                {
                    "sent": "We get an open node, generate an instance for it, give it to a classical planner.",
                    "label": 1
                },
                {
                    "sent": "We add choice actions to the plan that we get from the classical planner, trace it on the abstract state, and then simply merge it back into the generalized plan.",
                    "label": 1
                },
                {
                    "sent": "OK.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "In the next few slides, I'll focus on a very small part of this approach, which is on instance generation, and here we want to take a nap SAC state and create a particular instance of this state.",
                    "label": 1
                },
                {
                    "sent": "This is actually quite complicated because we want to make sure that the domains properties any integrity constraints in the domain are satisfied when we choose when we are creating that instance.",
                    "label": 0
                },
                {
                    "sent": "So what we do is create a first order formula for representing such abstract structures, and these formulas have different components like.",
                    "label": 0
                },
                {
                    "sent": "You want to say that there's an element of each role prison.",
                    "label": 0
                },
                {
                    "sent": "For example, you would say that there's something that's cleared as something that's on table, and so on, and you want to specify that which elements are exactly unique singletons, so they're not collections you want exactly one element for.",
                    "label": 0
                },
                {
                    "sent": "For example, in this structure we have exactly 1 block, that's clear.",
                    "label": 0
                },
                {
                    "sent": "So you go ahead and specify all the true and false predicate tuples and also integrity constraints.",
                    "label": 0
                },
                {
                    "sent": "And this is the example that I promised, so an integrity constraint here would be something like you can have at most one block above another block on top of another block, right?",
                    "label": 0
                },
                {
                    "sent": "So you compose this into a first order logic formula with transitive closure and.",
                    "label": 0
                },
                {
                    "sent": "You can hand it off to a model Gen.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Later, except that there is 1 final complication that transitive closure cannot really be handled by a first order model generator.",
                    "label": 0
                },
                {
                    "sent": "So what we do is we use this formula here to simulate transitive closure and this formula is accurate for acyclic finite models.",
                    "label": 0
                },
                {
                    "sent": "It's accurate in the sense that in terms of the properties entailed, it's going to be sound and complete in these models, so that gives us a way of using an off the shelf model generator to do our instance generation.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And the formal guarantees of this approach.",
                    "label": 0
                },
                {
                    "sent": "So I'm not going to go into the details here, but the main point is that if we can prove that the plan terminates and there are no open nodes, then we have a complete solution for the initial abstract states.",
                    "label": 0
                },
                {
                    "sent": "So we.",
                    "label": 0
                },
                {
                    "sent": "So that's the basic formal guarantee that we provide.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So now.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "A few quick results.",
                    "label": 0
                },
                {
                    "sent": "This is a description of our instance generation process and we have a bunch of different problem examples here, so the grid problems have a fixed number of rows but unknown or unbounded number of columns, and there are a few blocks problems and these graphs or these lines are simply telling us that whenever you have multiple transitive closure predicates to be synchronized it becomes unscalable very fast.",
                    "label": 0
                },
                {
                    "sent": "So those are these.",
                    "label": 0
                },
                {
                    "sent": "These three lines here are basically dealing with transitive closure.",
                    "label": 0
                },
                {
                    "sent": "And I can answer questions about this if there's any.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Stressed so here are our main results and there are too many numbers here, so I'm going to focus mostly on this rule for the reverse problem.",
                    "label": 0
                },
                {
                    "sent": "So this is the reverse linkage problem and the other problems here are in there.",
                    "label": 0
                },
                {
                    "sent": "Some in transport, some in the grid world navigation and some in the blocks world.",
                    "label": 0
                },
                {
                    "sent": "So the interesting problems are reversed and sorting, which are algorithms synthesis problems in reverse.",
                    "label": 0
                },
                {
                    "sent": "We basically used seven planner invocations and the largest problem structure that we used was of size.",
                    "label": 0
                },
                {
                    "sent": "8 and this is.",
                    "label": 0
                },
                {
                    "sent": "6 is the largest plan that we generated, so these are very simple problems for classical planners.",
                    "label": 0
                },
                {
                    "sent": "And we produced a plan that was terminating.",
                    "label": 0
                },
                {
                    "sent": "That is, it is guaranteed to terminate.",
                    "label": 0
                },
                {
                    "sent": "It had complete coverage, but there's no P in this column, and that's basically indicating that we didn't get a proof of complete coverage because our approach generated an open node that was unreachable, so we couldn't.",
                    "label": 0
                },
                {
                    "sent": "The abstraction was a little imprecise there, so on the other hand, if we used an instance generation mode where.",
                    "label": 0
                },
                {
                    "sent": "For each collection we generated at least five objects, we could find a generalized plan for reversing the linked list, which was which terminated, which is guaranteed to terminate had complete coverage, and also had a proof of complete coverage in the sense that there were no open roads left.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So to conclude, we have an approach here which utilizes the heuristic search capabilities of classical planners to do a search in the abstract state space, and in doing so we are actually searching over simultaneously over infinitely many problem instances, and this is very useful because otherwise we'd have to develop some new heuristics for searching in the abstract state trace directly.",
                    "label": 1
                },
                {
                    "sent": "Now in the future, the most challenging aspect is developing more robust termination tests, because that's the current stublic box block that we're facing.",
                    "label": 0
                },
                {
                    "sent": "We can do everything, but as long as we cannot analyze a more general class of loops for termination, we cannot find more general.",
                    "label": 0
                },
                {
                    "sent": "We cannot solve more general classes of problems.",
                    "label": 0
                },
                {
                    "sent": "And also identification of those open nodes that are actually unreachable or unsolvable so that we can save time and not try to give those open nodes to classical planners to solve, thank you.",
                    "label": 0
                },
                {
                    "sent": "Hi so.",
                    "label": 0
                },
                {
                    "sent": "If the examples you were using to reserve the ideas were representative got all problems were about.",
                    "label": 0
                },
                {
                    "sent": "An some it's called resource or.",
                    "label": 0
                },
                {
                    "sent": "The set of objects that are identical applications on the grid or blocks stacked on top of the tower that we should.",
                    "label": 0
                },
                {
                    "sent": "Do something with all of them, or with many of them.",
                    "label": 0
                },
                {
                    "sent": "I don't know something like that.",
                    "label": 0
                },
                {
                    "sent": "So I wonder whether this particular class of problem cannot be translate compiled into something like.",
                    "label": 0
                },
                {
                    "sent": "You know blocking the tower is higher than two blocks or not.",
                    "label": 0
                },
                {
                    "sent": "And then we have a non deterministic problem.",
                    "label": 0
                },
                {
                    "sent": "So picking a block at putting until onto the table either.",
                    "label": 0
                },
                {
                    "sent": "Leaves you with, you know, no tower or keep.",
                    "label": 0
                },
                {
                    "sent": "Keeps you at the same state.",
                    "label": 0
                },
                {
                    "sent": "And then I don't know, for example, applying by Bly and the actor for devising controller.",
                    "label": 0
                },
                {
                    "sent": "So right so so the whole thing is that we actually go into a state into a problem into an abstract state space that has exactly that kind of an action mechanism.",
                    "label": 0
                },
                {
                    "sent": "But the difference is that we want to prove that that loop that you create is going to terminate.",
                    "label": 0
                },
                {
                    "sent": "So you can have a situation where you have multiple possible loops and they see they all seem to look fine, but.",
                    "label": 0
                },
                {
                    "sent": "We want to determine that they terminate.",
                    "label": 0
                },
                {
                    "sent": "Yeah.",
                    "label": 0
                },
                {
                    "sent": "Related to that question, so any way to characterize the type of problems with these will work OK.",
                    "label": 0
                },
                {
                    "sent": "I'm not asking for a for my completeness with salt, but some idea Pro.",
                    "label": 0
                },
                {
                    "sent": "For instance, the example that he had.",
                    "label": 0
                },
                {
                    "sent": "If you had dropped.",
                    "label": 0
                },
                {
                    "sent": "Above predicate is a transitive closure of on.",
                    "label": 0
                },
                {
                    "sent": "Probably would not have worked OK, so any idea?",
                    "label": 0
                },
                {
                    "sent": "But what is gonna work when you have to engineer the the predicates in the domain so that will work and so on, right?",
                    "label": 0
                },
                {
                    "sent": "So as you mentioned, the transitive closure is something that we tend to use very often.",
                    "label": 0
                },
                {
                    "sent": "Whenever binary relations are involved, but one class of domains where which depending on your perspective may or may not be interesting.",
                    "label": 0
                },
                {
                    "sent": "Where this will always work is if you had only unary predicates.",
                    "label": 0
                },
                {
                    "sent": "In your domain, then the problem is relatively easy to analyze.",
                    "label": 0
                },
                {
                    "sent": "It still undesirable in general, but the basic approach of finding out preconditions of plans, etc.",
                    "label": 0
                },
                {
                    "sent": "Those approaches will work straightforward.",
                    "label": 0
                },
                {
                    "sent": "You won't run out of abstraction predicates in that case.",
                    "label": 0
                },
                {
                    "sent": "So usually if you try to engineer your domain so that you have unary predicates to represent the key important properties, then these kind of methods tend to work.",
                    "label": 0
                },
                {
                    "sent": "So it looks like you can.",
                    "label": 0
                },
                {
                    "sent": "The way you solve these problems that you construct.",
                    "label": 0
                },
                {
                    "sent": "These generalized plans is that you group the objects in the domain into sort of boundary objects and then objects that aren't boundary, and so for the non boundary objects you basically generalizing over N, right?",
                    "label": 0
                },
                {
                    "sent": "So how does that relate to some of the generalizing numbers?",
                    "label": 0
                },
                {
                    "sent": "Stuff that was done?",
                    "label": 0
                },
                {
                    "sent": "I think back in the 80s I so are you referring to something like Jude Shavlik's approach?",
                    "label": 0
                },
                {
                    "sent": "Yeah yeah yeah.",
                    "label": 0
                },
                {
                    "sent": "So so.",
                    "label": 0
                },
                {
                    "sent": "So to clarify the abstraction that we have is not really about boundary and on boundary that happens if you use transitive closure.",
                    "label": 0
                },
                {
                    "sent": "In general we're trying to collect objects that looks similar in terms of unary predicates together an in comparison with approaches like generalization to N. There you were.",
                    "label": 0
                },
                {
                    "sent": "So those approaches are about looking at the structure of a proof.",
                    "label": 0
                },
                {
                    "sent": "For via plan works, and to generalize that structure.",
                    "label": 0
                },
                {
                    "sent": "But again, you get loops there, but you don't know whether they will ever terminate so.",
                    "label": 0
                },
                {
                    "sent": "If they will terminate, so that is a difference with those approaches as well.",
                    "label": 0
                },
                {
                    "sent": "So what kind of termination check do you use?",
                    "label": 0
                },
                {
                    "sent": "I mean, I know there is some work by undress, put their skin and so on.",
                    "label": 0
                },
                {
                    "sent": "Also, like the more sophisticated termination checker, so can you say some more words about right?",
                    "label": 0
                },
                {
                    "sent": "So we had some work that we presented last year about this specific termination check we use, But the idea is to look at the number of elements in each role or the number of elements that satisfy your role and to see the changes in that in every strongly connected component that you find.",
                    "label": 0
                },
                {
                    "sent": "And just like.",
                    "label": 0
                },
                {
                    "sent": "A ranking function.",
                    "label": 0
                },
                {
                    "sent": "For instance, you show that there is some element whose role is always decreasing in the loop.",
                    "label": 0
                },
                {
                    "sent": "Or you?",
                    "label": 0
                },
                {
                    "sent": "I mean, you move from that idea that you want to find an element or a role whose count is decreasing in the loop and it cannot decrease forever.",
                    "label": 0
                },
                {
                    "sent": "So it must terminate.",
                    "label": 0
                },
                {
                    "sent": "That's the general idea.",
                    "label": 0
                },
                {
                    "sent": "So you found the standard techniques from verification community are not very suitable in those applications.",
                    "label": 0
                },
                {
                    "sent": "Well, they could be useful.",
                    "label": 0
                },
                {
                    "sent": "So for instance, the abstraction that I described is actually based on a method from the program verification community.",
                    "label": 0
                },
                {
                    "sent": "I'll ask a final question and thank the speaker at the same time, just related to Hector's question.",
                    "label": 0
                },
                {
                    "sent": "I'm wondering whether if there's a bound on on some sort of resource founder on, for example, the capacity of a table or the weather that that puts a limit on on this looping structure as well.",
                    "label": 0
                },
                {
                    "sent": "So let's say that you're putting blocks onto a table, but the table can only contain 10 blocks, so so it works.",
                    "label": 0
                },
                {
                    "sent": "For instance one to 10, but then after that you hit this sort of transition point.",
                    "label": 0
                },
                {
                    "sent": "So are you asking about the bounds on the method, or if we can solve a plan with such bounds or solve a problem with such power, whether that class of problems would work with your right?",
                    "label": 0
                },
                {
                    "sent": "So so we've thought about different ways of expressing those thresholds or counts, and in some cases we can just convert them into role counts an express a goal as saying something like we need at least five objects in the tower and at least 10 on the table and so on.",
                    "label": 0
                },
                {
                    "sent": "So in some cases we can handle them.",
                    "label": 0
                },
                {
                    "sent": "But you have to know apriori that that's going to limit your plan in some way so that you can integrate.",
                    "label": 0
                },
                {
                    "sent": "It's going to give you an exit condition for a loop, so depending on how many such conditions you have, you may want to fix it as a constant or in some cases you could do it symbolically.",
                    "label": 0
                }
            ]
        }
    }
}