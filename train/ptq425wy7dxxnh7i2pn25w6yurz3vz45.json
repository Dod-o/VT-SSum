{
    "id": "ptq425wy7dxxnh7i2pn25w6yurz3vz45",
    "title": "Schema-Agnostic Query Rewriting in SPARQL 1.1",
    "info": {
        "author": [
            "Sebastian Rudolph, Dresden University of Technology"
        ],
        "published": "Dec. 19, 2014",
        "recorded": "October 2014",
        "category": [
            "Top->Computer Science->Semantic Web"
        ]
    },
    "url": "http://videolectures.net/iswc2014_rudolph_schema_agnostic_query/",
    "segmentation": [
        [
            "This is joint work with Vienna or between Vienna and racism, so.",
            "My colleagues are Stephen Bishop.",
            "Marco's, Coachella, Polaris.",
            "And so this is about schema agnostic query rewriting, which is essentially.",
            "Rewriting without knowing anything without knowing anything about the ontology so you don't know anything about the schema, you don't know anything about the data, so how can that actually work?",
            "So we will see it in a second so."
        ],
        [
            "Luckily my colleagues already set the stage pretty well in terms of what people are looking into.",
            "What ontology based query answering is about so, but let me start from the beginning to also maybe emphasize the nuances that we have in our approach.",
            "So I mean playing query answering has been around since ancient Greek, probably so you have some data.",
            "You have some query and you want to answer the query over the data typically have some, some, well, some.",
            "Database and your query would be SQL and then people got interested in ontology based or ontology cool query answering so you have some ontology in between that well helps you.",
            "Or that provides some glue code in terms of vocabulary that makes your data more complete or things like that.",
            "And essentially if you look at this from a very abstract viewpoint, there's there's two ways or two perspectives that you can have when you look at this task.",
            "One of the views which I called."
        ],
        [
            "The knowledge representation view is, you think, well, the ontology is actually part of the data.",
            "So this is all a big description of how the world is.",
            "You have some factoids and then you have some some more high level knowledge, and this all describes your world an I have a query about this world, and this essentially suggests one approach to query answering which is known as material."
        ],
        [
            "Station, so essentially you take your high level knowledge, apply it to your data, and complete your factoids so that in the end you get bigger database where against you can answer your query directly.",
            "The other viewpoint, which I call."
        ],
        [
            "The database view would rather be this."
        ],
        [
            "This way you see well, actually I have my query and I actually use the theory I look used.",
            "Ontology in order to make my query language more expressive.",
            "And I actually have something which people call an ontology mediated query which I want to ask oppose against the data as is.",
            "And if you take this viewpoint, it's actually rather straightforward then.",
            "Then you want to do something like query rewriting so you want."
        ],
        [
            "To compile your ontology into the query language so so you want to.",
            "Transform the ontology made it query into an easier query that can be.",
            "Asked or post more directly against the data, so these are the two approaches and of course they are there to the combined approach which mixes the two the two views a little bit, but this is essentially what people understand when you say query rewriting."
        ],
        [
            "Now our scenario is a bit specific and a bit different, so we're looking into conjunctive queries over our QL ontologies.",
            "And well again, it's the ontological query answering approach, so you want to answer a query a conjunctive query with non distinguished variables against some data under some ontological knowledge.",
            "And I mean, yeah, we've heard a lot about alcohol already so.",
            "I don't need to go into detail about that one.",
            "QL also captures or covers RDF's reasoning.",
            "If you restrict to standard you, so no ontology hijacking, so no strange so preferential schematic.",
            "Yeah, schematic things that you do there."
        ],
        [
            "So now if you look or how does an alcohol ontology look like when you?",
            "Encounter it in the wild.",
            "So in the World Wide Web.",
            "So it looks like data.",
            "Essentially it looks like a big RDF graph, so you have your data.",
            "As is and then you have the ontology expressed in terms of RDF triples.",
            "So using some sort of special vocabulary like RDF, subclass, off and and other things, and now the question that we actually ask ourselves.",
            "OK, assume we have this representation of anarchy Ontology and we want to ask conjunctive query against it.",
            "Can we do it in some way?",
            "Well, by just read."
        ],
        [
            "Writing our original query into a query that we can ask against this.",
            "Big RDF graph, so that's what we call schema agnostic query writing because we want to do it without knowing anything about this big RDF graph in advance.",
            "Other than that, it is LQL.",
            "OK, so can we do this, so let's try.",
            "Let's look into an example."
        ],
        [
            "So assume we have a query that we want to ask very simple one.",
            "So give me all the individuals known to be persons OK. Of course you could come up with with this pocket query asking for all things which are of type person.",
            "OK, works for playing RDF.",
            "Doesn't work for Audio S more for LCL because of course being a person can be inferred, for instance via subclass relationship which we have here.",
            "OK, so let's let's make another attempt and say, well."
        ],
        [
            "It could be in the data itself.",
            "It could be inferred via one step subclass of expression.",
            "Well, of course, then we easily come up with another example because we also may have chains of subclass relationships.",
            "OK, is there a way to actually incorporate all this?",
            "Type of types of."
        ],
        [
            "Inference as well.",
            "We would need to express arbitrarily long subclass chains.",
            "Well Luckily we have Sparkle 11 which allows for such for regular expressions for path expressions and so we could.",
            "Come up with something like, well, we're interested in all individuals which are of type something which has a subclass of chain to person.",
            "So that would solve our.",
            "A problem well.",
            "Not quite because."
        ],
        [
            "So I mean, we all know that already.",
            "In Audio S There's many, many different ways of actually inferring typing state."
        ],
        [
            "Something like this?",
            "I mean, here we have Shakespeare, author of Hamlet.",
            "And then we know whenever somebody is author of something is also creative, something of the same thing.",
            "Actually, an creator has a domain which is artist and every artist is a person.",
            "So you know, I mean you can."
        ],
        [
            "Do this inferencing stuff.",
            "There's the duction calculus for RDS.",
            "There's also one for our QL, and so this would allow you to infer that Shakespeare is actually a person, and that therefore a Shakespeare should be delivered as a result of our query.",
            "Now it's it's a bit tricky, but there are some interesting observations that you can make.",
            "First of all, the proof tree is essentially linear.",
            "I mean it has the side branches that that use.",
            "Leaves or leaf triples which are in your initial data set, but actually there's no no really big forking going on.",
            "And the other thing is that if you look at the leaf triples or the black ones which have been there right from the beginning, they are actually in some sort of some sort of chain which allow you for essentially expressing some some.",
            "Chain of properties.",
            "In order to cover what you want to do.",
            "So to cut a Long story short."
        ],
        [
            "It's possible.",
            "And so for.",
            "Almost all I I will refer to the almost bit later on, because as one nuisance that we cannot actually overcome, But essentially for our QL there you can express or translate reasoning tasks into sparkle.",
            "11 query that would answer things like is the ontology consistent?",
            "Which is interesting gods.",
            "This is just a query that you can come up with without knowing anything about the ontology before hand, so there's one fixed Sparkle 11 query that you can execute against another QL ontology expressed in RDF and that would solve that question for you.",
            "You can ask for a consistent class.",
            "You can essentially ask for schematic information and also of course for.",
            "Data, information and also here we can have this week and have schema queries, which means we can use meter variables so all these classes and properties that you have there you can actually put a variable for them, so you can actually ask for all the subclasses of a given class.",
            "Or maybe you can ask for all subclass relationships that are there in the ontology."
        ],
        [
            "OK, um it's possible doesn't mean mean.",
            "It looks nice, so I have put here the sparkle on one query that actually would retrieve you all the inconsistent classes in and out QL ontology.",
            "And actually it's not the full story becausw all the things that are written there in small cups actually are subpatterns, which still would need to be resolved so.",
            "People who know bit better how RDF encoding of for instance, all QL works is that you have intersections represented by lists.",
            "So you have to navigate the list somehow with path expression.",
            "So that's essentially what you have there when you read things like INT, list member or two Members, or things like that."
        ],
        [
            "OK, but it works an actually we can even go step further because we wanted to do or we want to answer conjunctive queries.",
            "And this is also possible and the nice take home message here is also that the writings are linear as opposed to traditional rewriting, where actually the writing can become rather large.",
            "OK, it's of course a bit more difficult because you we support and undistinguished variables, which means you actually have to go probably in the anonymous part of your model.",
            "And so we had to do a little bit of hacking using some others.",
            "Marker 1 one features like values because you have to do some guessing on the way.",
            "Still complexity wise no no big change and it works in still."
        ],
        [
            "Works.",
            "OK, So what we have done is we have come up with prototypical implementation which and you can even try it online so there's a web demo where you can actually insert or input your conjunctive query as his pocket query and then you would get the written the written query back.",
            "OK."
        ],
        [
            "And we've done some testing, but I mean, that's always a bit of a problem, so we compare it against Requiem on some lemon data set using Jenna.",
            "But it's like comparing apples and oranges, right?",
            "'cause they're paradigms are different.",
            "Scheme agnostic.",
            "Rewriting is not the traditional rewriting.",
            "So well, we found out it works.",
            "Rewriting is faster than Requiem.",
            "The size of the writing.",
            "This user usually smaller, but well, best bet.",
            "Part of it is the query evaluation.",
            "Usually slower than Requiem, which might be attributed to the case that typical Sparkle 11 query engines are not really optimized towards this kind of queries that we come up with.",
            "So hopefully when schema agnostic query writing becomes more popular, the developers of those engines will also take this into account and and optimize towards such structures."
        ],
        [
            "OK, there are some limits that should be discussed about this approach.",
            "So for instance you have some complexity considerations to be taken into account, so if you have a query language that has some data complexity, of course you cannot do reasoning of complexity or whose combined complexity is bigger than that class.",
            "That's sort of clear.",
            "Luckily, in our case Parker 1 one has mlok space data complexity and combined complexity of our QL.",
            "Reasoning also query answering is unlock space, so we're good there, but if we would like to extend this approach to other formalisms, like hourly LRL.",
            "Also, if we wanted to do full res reasoning, so with nonstandard use, this is all complete, and so it's clear right from the beginning that we cannot do this in Sparkle 11.",
            "So unless an lock space turns out to be P time, which would be a big surprise for everybody, I guess.",
            "So."
        ],
        [
            "Oh yeah, there.",
            "There are some limits and we have to think about what what to do there.",
            "There's another thing, even if complexities are alright, sometimes our query language is not as expressive inside its complexity class as we would want it to be, and we have.",
            "I was talking about this nuisance.",
            "We have this out symmetric property in Al QL.",
            "And actually if you use these axioms then you would have to query for structures which are not playing pass but have some.",
            "Have have unboundedly many.",
            "For King points, and that's what we cannot do, and so we silently Wallace silently assume that we only look into our two CLO ontologies where the symmetric property axioms are paraphrased.",
            "You can do this in alcohol, so if you leave away symmetric property, you still have the same express city, so this is a little downside of our approach so."
        ],
        [
            "But as a take home message, every RDF database featuring sparker 11 queries can be essentially used as an out QL reasoner under this mild restricting assumptions.",
            "With full support for conjunctive queries including schema variables, which we think is pretty cool."
        ],
        [
            "So some future work.",
            "Of course we have to do much more evaluation, so this was really very preliminary.",
            "What we did so far, and on the way we can also do quite a lot of optimization.",
            "So actually we found that.",
            "The precise way how we phrase our sparkle in one query affects performance.",
            "So, and we could also exploit algebraic equivalences, so he might really do some query optimization on top of of the this Parker 11 engine.",
            "And it might also turn out to be a good idea to materialize a part of the queries before hand, cause as you saw, we have we have a lot of patterns reoccuring in the queries or possibly reoccuring in the query and it might be good to actually materialize them as of you possibly before hand and then reuse it.",
            "OK, on the on the theoretical side.",
            "Of course the question is what do we do if we leave this complexity class?",
            "If we leave in log space, well we could do some sort of combined approach so touch the data just a little bit.",
            "So of course if we did the full materialization that wouldn't buy us anything.",
            "Or we could just use more powerful queries which would make us leave the standardized sparkle on one.",
            "So we would have to go to possibly to variants of Datalog there, so this can be done.",
            "Be cause for for data look we know well data complexity is P times or we could at least cover those other lightweight fragrance that that I was talking about.",
            "So this is this is it?"
        ],
        [
            "Thanks for your attention and.",
            "I like questions.",
            "Thank you speaker."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "This is joint work with Vienna or between Vienna and racism, so.",
                    "label": 0
                },
                {
                    "sent": "My colleagues are Stephen Bishop.",
                    "label": 0
                },
                {
                    "sent": "Marco's, Coachella, Polaris.",
                    "label": 0
                },
                {
                    "sent": "And so this is about schema agnostic query rewriting, which is essentially.",
                    "label": 1
                },
                {
                    "sent": "Rewriting without knowing anything without knowing anything about the ontology so you don't know anything about the schema, you don't know anything about the data, so how can that actually work?",
                    "label": 0
                },
                {
                    "sent": "So we will see it in a second so.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Luckily my colleagues already set the stage pretty well in terms of what people are looking into.",
                    "label": 0
                },
                {
                    "sent": "What ontology based query answering is about so, but let me start from the beginning to also maybe emphasize the nuances that we have in our approach.",
                    "label": 0
                },
                {
                    "sent": "So I mean playing query answering has been around since ancient Greek, probably so you have some data.",
                    "label": 0
                },
                {
                    "sent": "You have some query and you want to answer the query over the data typically have some, some, well, some.",
                    "label": 0
                },
                {
                    "sent": "Database and your query would be SQL and then people got interested in ontology based or ontology cool query answering so you have some ontology in between that well helps you.",
                    "label": 0
                },
                {
                    "sent": "Or that provides some glue code in terms of vocabulary that makes your data more complete or things like that.",
                    "label": 0
                },
                {
                    "sent": "And essentially if you look at this from a very abstract viewpoint, there's there's two ways or two perspectives that you can have when you look at this task.",
                    "label": 0
                },
                {
                    "sent": "One of the views which I called.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The knowledge representation view is, you think, well, the ontology is actually part of the data.",
                    "label": 1
                },
                {
                    "sent": "So this is all a big description of how the world is.",
                    "label": 0
                },
                {
                    "sent": "You have some factoids and then you have some some more high level knowledge, and this all describes your world an I have a query about this world, and this essentially suggests one approach to query answering which is known as material.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Station, so essentially you take your high level knowledge, apply it to your data, and complete your factoids so that in the end you get bigger database where against you can answer your query directly.",
                    "label": 0
                },
                {
                    "sent": "The other viewpoint, which I call.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The database view would rather be this.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This way you see well, actually I have my query and I actually use the theory I look used.",
                    "label": 0
                },
                {
                    "sent": "Ontology in order to make my query language more expressive.",
                    "label": 0
                },
                {
                    "sent": "And I actually have something which people call an ontology mediated query which I want to ask oppose against the data as is.",
                    "label": 0
                },
                {
                    "sent": "And if you take this viewpoint, it's actually rather straightforward then.",
                    "label": 0
                },
                {
                    "sent": "Then you want to do something like query rewriting so you want.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "To compile your ontology into the query language so so you want to.",
                    "label": 0
                },
                {
                    "sent": "Transform the ontology made it query into an easier query that can be.",
                    "label": 0
                },
                {
                    "sent": "Asked or post more directly against the data, so these are the two approaches and of course they are there to the combined approach which mixes the two the two views a little bit, but this is essentially what people understand when you say query rewriting.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now our scenario is a bit specific and a bit different, so we're looking into conjunctive queries over our QL ontologies.",
                    "label": 0
                },
                {
                    "sent": "And well again, it's the ontological query answering approach, so you want to answer a query a conjunctive query with non distinguished variables against some data under some ontological knowledge.",
                    "label": 0
                },
                {
                    "sent": "And I mean, yeah, we've heard a lot about alcohol already so.",
                    "label": 0
                },
                {
                    "sent": "I don't need to go into detail about that one.",
                    "label": 0
                },
                {
                    "sent": "QL also captures or covers RDF's reasoning.",
                    "label": 0
                },
                {
                    "sent": "If you restrict to standard you, so no ontology hijacking, so no strange so preferential schematic.",
                    "label": 0
                },
                {
                    "sent": "Yeah, schematic things that you do there.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So now if you look or how does an alcohol ontology look like when you?",
                    "label": 0
                },
                {
                    "sent": "Encounter it in the wild.",
                    "label": 0
                },
                {
                    "sent": "So in the World Wide Web.",
                    "label": 0
                },
                {
                    "sent": "So it looks like data.",
                    "label": 0
                },
                {
                    "sent": "Essentially it looks like a big RDF graph, so you have your data.",
                    "label": 0
                },
                {
                    "sent": "As is and then you have the ontology expressed in terms of RDF triples.",
                    "label": 0
                },
                {
                    "sent": "So using some sort of special vocabulary like RDF, subclass, off and and other things, and now the question that we actually ask ourselves.",
                    "label": 0
                },
                {
                    "sent": "OK, assume we have this representation of anarchy Ontology and we want to ask conjunctive query against it.",
                    "label": 0
                },
                {
                    "sent": "Can we do it in some way?",
                    "label": 0
                },
                {
                    "sent": "Well, by just read.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Writing our original query into a query that we can ask against this.",
                    "label": 0
                },
                {
                    "sent": "Big RDF graph, so that's what we call schema agnostic query writing because we want to do it without knowing anything about this big RDF graph in advance.",
                    "label": 1
                },
                {
                    "sent": "Other than that, it is LQL.",
                    "label": 0
                },
                {
                    "sent": "OK, so can we do this, so let's try.",
                    "label": 0
                },
                {
                    "sent": "Let's look into an example.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So assume we have a query that we want to ask very simple one.",
                    "label": 0
                },
                {
                    "sent": "So give me all the individuals known to be persons OK. Of course you could come up with with this pocket query asking for all things which are of type person.",
                    "label": 1
                },
                {
                    "sent": "OK, works for playing RDF.",
                    "label": 0
                },
                {
                    "sent": "Doesn't work for Audio S more for LCL because of course being a person can be inferred, for instance via subclass relationship which we have here.",
                    "label": 0
                },
                {
                    "sent": "OK, so let's let's make another attempt and say, well.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "It could be in the data itself.",
                    "label": 0
                },
                {
                    "sent": "It could be inferred via one step subclass of expression.",
                    "label": 0
                },
                {
                    "sent": "Well, of course, then we easily come up with another example because we also may have chains of subclass relationships.",
                    "label": 0
                },
                {
                    "sent": "OK, is there a way to actually incorporate all this?",
                    "label": 0
                },
                {
                    "sent": "Type of types of.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Inference as well.",
                    "label": 0
                },
                {
                    "sent": "We would need to express arbitrarily long subclass chains.",
                    "label": 1
                },
                {
                    "sent": "Well Luckily we have Sparkle 11 which allows for such for regular expressions for path expressions and so we could.",
                    "label": 0
                },
                {
                    "sent": "Come up with something like, well, we're interested in all individuals which are of type something which has a subclass of chain to person.",
                    "label": 0
                },
                {
                    "sent": "So that would solve our.",
                    "label": 0
                },
                {
                    "sent": "A problem well.",
                    "label": 0
                },
                {
                    "sent": "Not quite because.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So I mean, we all know that already.",
                    "label": 0
                },
                {
                    "sent": "In Audio S There's many, many different ways of actually inferring typing state.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Something like this?",
                    "label": 0
                },
                {
                    "sent": "I mean, here we have Shakespeare, author of Hamlet.",
                    "label": 0
                },
                {
                    "sent": "And then we know whenever somebody is author of something is also creative, something of the same thing.",
                    "label": 0
                },
                {
                    "sent": "Actually, an creator has a domain which is artist and every artist is a person.",
                    "label": 0
                },
                {
                    "sent": "So you know, I mean you can.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Do this inferencing stuff.",
                    "label": 0
                },
                {
                    "sent": "There's the duction calculus for RDS.",
                    "label": 0
                },
                {
                    "sent": "There's also one for our QL, and so this would allow you to infer that Shakespeare is actually a person, and that therefore a Shakespeare should be delivered as a result of our query.",
                    "label": 0
                },
                {
                    "sent": "Now it's it's a bit tricky, but there are some interesting observations that you can make.",
                    "label": 0
                },
                {
                    "sent": "First of all, the proof tree is essentially linear.",
                    "label": 1
                },
                {
                    "sent": "I mean it has the side branches that that use.",
                    "label": 1
                },
                {
                    "sent": "Leaves or leaf triples which are in your initial data set, but actually there's no no really big forking going on.",
                    "label": 0
                },
                {
                    "sent": "And the other thing is that if you look at the leaf triples or the black ones which have been there right from the beginning, they are actually in some sort of some sort of chain which allow you for essentially expressing some some.",
                    "label": 0
                },
                {
                    "sent": "Chain of properties.",
                    "label": 0
                },
                {
                    "sent": "In order to cover what you want to do.",
                    "label": 0
                },
                {
                    "sent": "So to cut a Long story short.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "It's possible.",
                    "label": 0
                },
                {
                    "sent": "And so for.",
                    "label": 0
                },
                {
                    "sent": "Almost all I I will refer to the almost bit later on, because as one nuisance that we cannot actually overcome, But essentially for our QL there you can express or translate reasoning tasks into sparkle.",
                    "label": 1
                },
                {
                    "sent": "11 query that would answer things like is the ontology consistent?",
                    "label": 1
                },
                {
                    "sent": "Which is interesting gods.",
                    "label": 0
                },
                {
                    "sent": "This is just a query that you can come up with without knowing anything about the ontology before hand, so there's one fixed Sparkle 11 query that you can execute against another QL ontology expressed in RDF and that would solve that question for you.",
                    "label": 1
                },
                {
                    "sent": "You can ask for a consistent class.",
                    "label": 0
                },
                {
                    "sent": "You can essentially ask for schematic information and also of course for.",
                    "label": 1
                },
                {
                    "sent": "Data, information and also here we can have this week and have schema queries, which means we can use meter variables so all these classes and properties that you have there you can actually put a variable for them, so you can actually ask for all the subclasses of a given class.",
                    "label": 0
                },
                {
                    "sent": "Or maybe you can ask for all subclass relationships that are there in the ontology.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, um it's possible doesn't mean mean.",
                    "label": 0
                },
                {
                    "sent": "It looks nice, so I have put here the sparkle on one query that actually would retrieve you all the inconsistent classes in and out QL ontology.",
                    "label": 0
                },
                {
                    "sent": "And actually it's not the full story becausw all the things that are written there in small cups actually are subpatterns, which still would need to be resolved so.",
                    "label": 0
                },
                {
                    "sent": "People who know bit better how RDF encoding of for instance, all QL works is that you have intersections represented by lists.",
                    "label": 0
                },
                {
                    "sent": "So you have to navigate the list somehow with path expression.",
                    "label": 0
                },
                {
                    "sent": "So that's essentially what you have there when you read things like INT, list member or two Members, or things like that.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, but it works an actually we can even go step further because we wanted to do or we want to answer conjunctive queries.",
                    "label": 0
                },
                {
                    "sent": "And this is also possible and the nice take home message here is also that the writings are linear as opposed to traditional rewriting, where actually the writing can become rather large.",
                    "label": 0
                },
                {
                    "sent": "OK, it's of course a bit more difficult because you we support and undistinguished variables, which means you actually have to go probably in the anonymous part of your model.",
                    "label": 0
                },
                {
                    "sent": "And so we had to do a little bit of hacking using some others.",
                    "label": 0
                },
                {
                    "sent": "Marker 1 one features like values because you have to do some guessing on the way.",
                    "label": 0
                },
                {
                    "sent": "Still complexity wise no no big change and it works in still.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Works.",
                    "label": 0
                },
                {
                    "sent": "OK, So what we have done is we have come up with prototypical implementation which and you can even try it online so there's a web demo where you can actually insert or input your conjunctive query as his pocket query and then you would get the written the written query back.",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And we've done some testing, but I mean, that's always a bit of a problem, so we compare it against Requiem on some lemon data set using Jenna.",
                    "label": 0
                },
                {
                    "sent": "But it's like comparing apples and oranges, right?",
                    "label": 0
                },
                {
                    "sent": "'cause they're paradigms are different.",
                    "label": 0
                },
                {
                    "sent": "Scheme agnostic.",
                    "label": 0
                },
                {
                    "sent": "Rewriting is not the traditional rewriting.",
                    "label": 0
                },
                {
                    "sent": "So well, we found out it works.",
                    "label": 0
                },
                {
                    "sent": "Rewriting is faster than Requiem.",
                    "label": 1
                },
                {
                    "sent": "The size of the writing.",
                    "label": 0
                },
                {
                    "sent": "This user usually smaller, but well, best bet.",
                    "label": 0
                },
                {
                    "sent": "Part of it is the query evaluation.",
                    "label": 0
                },
                {
                    "sent": "Usually slower than Requiem, which might be attributed to the case that typical Sparkle 11 query engines are not really optimized towards this kind of queries that we come up with.",
                    "label": 0
                },
                {
                    "sent": "So hopefully when schema agnostic query writing becomes more popular, the developers of those engines will also take this into account and and optimize towards such structures.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, there are some limits that should be discussed about this approach.",
                    "label": 0
                },
                {
                    "sent": "So for instance you have some complexity considerations to be taken into account, so if you have a query language that has some data complexity, of course you cannot do reasoning of complexity or whose combined complexity is bigger than that class.",
                    "label": 1
                },
                {
                    "sent": "That's sort of clear.",
                    "label": 1
                },
                {
                    "sent": "Luckily, in our case Parker 1 one has mlok space data complexity and combined complexity of our QL.",
                    "label": 0
                },
                {
                    "sent": "Reasoning also query answering is unlock space, so we're good there, but if we would like to extend this approach to other formalisms, like hourly LRL.",
                    "label": 0
                },
                {
                    "sent": "Also, if we wanted to do full res reasoning, so with nonstandard use, this is all complete, and so it's clear right from the beginning that we cannot do this in Sparkle 11.",
                    "label": 0
                },
                {
                    "sent": "So unless an lock space turns out to be P time, which would be a big surprise for everybody, I guess.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Oh yeah, there.",
                    "label": 0
                },
                {
                    "sent": "There are some limits and we have to think about what what to do there.",
                    "label": 0
                },
                {
                    "sent": "There's another thing, even if complexities are alright, sometimes our query language is not as expressive inside its complexity class as we would want it to be, and we have.",
                    "label": 0
                },
                {
                    "sent": "I was talking about this nuisance.",
                    "label": 0
                },
                {
                    "sent": "We have this out symmetric property in Al QL.",
                    "label": 0
                },
                {
                    "sent": "And actually if you use these axioms then you would have to query for structures which are not playing pass but have some.",
                    "label": 0
                },
                {
                    "sent": "Have have unboundedly many.",
                    "label": 0
                },
                {
                    "sent": "For King points, and that's what we cannot do, and so we silently Wallace silently assume that we only look into our two CLO ontologies where the symmetric property axioms are paraphrased.",
                    "label": 0
                },
                {
                    "sent": "You can do this in alcohol, so if you leave away symmetric property, you still have the same express city, so this is a little downside of our approach so.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "But as a take home message, every RDF database featuring sparker 11 queries can be essentially used as an out QL reasoner under this mild restricting assumptions.",
                    "label": 0
                },
                {
                    "sent": "With full support for conjunctive queries including schema variables, which we think is pretty cool.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So some future work.",
                    "label": 0
                },
                {
                    "sent": "Of course we have to do much more evaluation, so this was really very preliminary.",
                    "label": 0
                },
                {
                    "sent": "What we did so far, and on the way we can also do quite a lot of optimization.",
                    "label": 0
                },
                {
                    "sent": "So actually we found that.",
                    "label": 0
                },
                {
                    "sent": "The precise way how we phrase our sparkle in one query affects performance.",
                    "label": 0
                },
                {
                    "sent": "So, and we could also exploit algebraic equivalences, so he might really do some query optimization on top of of the this Parker 11 engine.",
                    "label": 0
                },
                {
                    "sent": "And it might also turn out to be a good idea to materialize a part of the queries before hand, cause as you saw, we have we have a lot of patterns reoccuring in the queries or possibly reoccuring in the query and it might be good to actually materialize them as of you possibly before hand and then reuse it.",
                    "label": 0
                },
                {
                    "sent": "OK, on the on the theoretical side.",
                    "label": 0
                },
                {
                    "sent": "Of course the question is what do we do if we leave this complexity class?",
                    "label": 0
                },
                {
                    "sent": "If we leave in log space, well we could do some sort of combined approach so touch the data just a little bit.",
                    "label": 1
                },
                {
                    "sent": "So of course if we did the full materialization that wouldn't buy us anything.",
                    "label": 1
                },
                {
                    "sent": "Or we could just use more powerful queries which would make us leave the standardized sparkle on one.",
                    "label": 0
                },
                {
                    "sent": "So we would have to go to possibly to variants of Datalog there, so this can be done.",
                    "label": 0
                },
                {
                    "sent": "Be cause for for data look we know well data complexity is P times or we could at least cover those other lightweight fragrance that that I was talking about.",
                    "label": 0
                },
                {
                    "sent": "So this is this is it?",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Thanks for your attention and.",
                    "label": 0
                },
                {
                    "sent": "I like questions.",
                    "label": 0
                },
                {
                    "sent": "Thank you speaker.",
                    "label": 0
                }
            ]
        }
    }
}