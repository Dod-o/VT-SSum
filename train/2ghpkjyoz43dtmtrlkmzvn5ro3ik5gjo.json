{
    "id": "2ghpkjyoz43dtmtrlkmzvn5ro3ik5gjo",
    "title": "Gagg: A Graph Aggregation Operator",
    "info": {
        "author": [
            "Fadi Maali, DERI Galway, National University of Ireland, Galway"
        ],
        "published": "July 15, 2015",
        "recorded": "June 2015",
        "category": [
            "Top->Computer Science->Big Data",
            "Top->Computer Science->Semantic Web"
        ]
    },
    "url": "http://videolectures.net/eswc2015_maali_aggregation_operator/",
    "segmentation": [
        [
            "Hello everyone, so let."
        ],
        [
            "We start by the famous image of the load cloud, so that's the load cloud diagram which directs the status of the open data that's published as linked data.",
            "We probably all know it, so each bubble in the graph is a data set and the size of the bubble is proportional to the number of triples as contained in that in that data set link or an edge or an arrow arrow exists between two bubbles.",
            "If the instances of one data set interlinks contains interlinks two instances in other datasets.",
            "And enter links is that these interlinked?",
            "These links are the interesting part and this is what makes this link data and this is what makes this diagram actually a graph on the raw RDF data or the raw data behind this diagram is available in RDF.",
            "It's it's described using the Void vocabulary.",
            "So if you go to load cloud.net data, that's for the TTL.",
            "You get that row data which contains extra metadata about each of these datasets, and."
        ],
        [
            "Using this metadata, when can have different versions of the diagram.",
            "Something like, we can have a colored version of the load cloud where each bubble is colored based on its subject or its main theme.",
            "So for example, in this in this diagram, the publications are in green geographic data, government data, each one got its own color based on the subject, but that's not the only view over Link data cloud that we might have."
        ],
        [
            "For example, in this diagram I I took this arrow data and instead of having a bubble per data set, I have a purple pair category.",
            "So all the datasets that are that are classified under publications, for example, will contribute to this one bubble and similarly the size of each bubble is proportional to the number of datasets that's under that category in the diagram, and the connections between the datasets also, like the thickness represents the number of links it's between the different categories.",
            "So one important point to note here that this is a graph.",
            "This is.",
            "This is still a graph data and then all the graph measures.",
            "All the graph algorithms can be applied over this data.",
            "I can even query this data using Sparkle or any other graph query language.",
            "But again, this is not the only way I can look or not.",
            "The only perspective I can have over the load the diagram.",
            "So for example, instead of just counting the number of datasets per category."
        ],
        [
            "I can sum the travel in in each of these datasets, so if you just."
        ],
        [
            "Look at them publications and the government.",
            "In this diagram, the green and the red.",
            "So this is counting the data set."
        ],
        [
            "In the next diagram, I'm summing that rebels and the government datasets that in the in the load cloud tends to be big.",
            "And that's why the size of the bubble gets bigger, but."
        ],
        [
            "Similarly, I don't have to only group the datasets based on their category, so that's another example where I grouped the datasets based on the license they are available under, so I can see like things like CC, the UK Crown etc GPL etc and they can only and also analyze the links like how datasets that are licensed under some open license, for example, interlinks with datasets that are.",
            "Published under a closed license, and similarly I can."
        ],
        [
            "Found the datasets or I can have some of the tribbles paired datasets, so all these examples provide an aggregation over the graph data, so the row graph data is the data that provided the original load load cloud and I can have different aggregations over this data as shown in the examples and in general graph aggregation."
        ],
        [
            "Provide structurally similar but smaller graph by collapsing vertices and edges, and it's a common operator, so I showed some some examples, But if you look at literature there is a large number of the usage of such a graph aggregations, so another."
        ],
        [
            "Well, I want to mention is the schema discovery.",
            "So we have data doesn't have a fixed schema and one line of work looks at the data and try to kind of mind the schema based on the data.",
            "So this is a work from Steven Computers, a coauthor of this award where he would give a summary of a big RDF data that says, you know in this data set there was ten instances of type of person, for example, and 25 of type organization.",
            "And between these two sets of instances, there are maybe 55 member relationships ships, an three works for or something like that.",
            "So that's also an example of a graph aggregation and similarly graph graph aggregation is used in social network analysis in people you like for bibliometrics, in bioinformatics, and in many many other domains, an important point to note here that aggregation itself is a graph, so you can whatever applies to the original data, which is.",
            "The graph also applies to the.",
            "Aggregated data, which is which is also a graph, and which schemes the relationship between between the nodes."
        ],
        [
            "So if we want to focus on this operator and try to solicit the requirements for the scenarios that are reported in literature, I'll use the examples of the load cloud here so things do notes that if we consider two entities as related, they don't necessarily have a direct link between each other.",
            "So for example, here DVD and BBC Music they have some interlink.",
            "They have links that connects resources between each other.",
            "And using the description that uses void.",
            "It says that there is a link set that goes from one data set to another.",
            "Similarly when I group the particular set of nodes, I don't necessarily group them by direct properties of them.",
            "So if I want to group all the datasets that are under an open license, I have to navigate a path in the graph.",
            "So I have to see the license, then look whether it is an open license or a closed license.",
            "Another example might be the country where the publisher is, so I have to go to the publishers and see in which country.",
            "That publisher is located."
        ],
        [
            "So I have many options to achieve such an aggregation.",
            "Custom code obviously is 1.",
            "One of these options, but this is also achievable using sparkle.",
            "However, as I'll show in like you need a complicated sparkle query, the straightforward sparkle query aggregation Sparkle query will give you a table, right.",
            "It will give you some data points, but to achieve the keep the graph structure in the summary graph you will typically need three nested sparkle queries.",
            "One that groups the subjects when that's groups objects and one that's groups and kind of aggregate the relation, and then you need.",
            "And construct to surround of all of these, so that's error prone.",
            "That's hard to write, hard to understand, but even more, this is hard for engineers to optimize, and I'll come back to this point during the evaluation.",
            "One can also use graph databases, so graph databases will have some graph databases will have a graph aggregation operators, which does exactly that.",
            "However, the main problem would be the expressivity, because most of all of the work that we came across in literature.",
            "Assumes a direct relation between the two entities and assumes that the dimensions that are used to aggregate nodes are direct reportees of the nodes, so I can't do something like following a path as I showed in that in the example and therefore this paper suggests an U operator.",
            "We called it gag for graph aggregator and we define this operator on top of the Sparkle algebra, which means we can reuse the formal model and the implementation and.",
            "All the hard work that has been done in optimizing the existing existing other graph.",
            "Other sparkle operators and then define a new operator that just reuse as much of that as possible."
        ],
        [
            "So in the rest of the presentation, I'll quickly talk about the operational semantics, so if anyone is interested, the paper contains a formal description of the operator and the formal description of its operational semantics, which means if you want to implement that, you have like a blueprint.",
            "To do that.",
            "I'll also quickly show a particular algorithm which provides an particular evaluation of that of that operator in memory, and then expect an experimental evaluation."
        ],
        [
            "In general, the graph operator as we defined it is a two step process which starts with the role graph.",
            "The whole graph, RDF graph data and then it groups notes and it is based on some criteria to get a group graph.",
            "So that's done in the in the middle and then I reduce function which which takes this group graph and give you the final results.",
            "Group graph would represent won't be in RDF.",
            "Data is just an intermediary step, but it allows.",
            "The operator to be flexible and.",
            "By defining a reduce function, this means that the results can be anything that the user the user chooses and."
        ],
        [
            "This is achieved by using something a template which is very similar to the construct template query.",
            "So for the last step to go from the group graph to the final aggregated graph, it's using a template that's similar to the construct query, which means the shape of the final result is just defined by the user and can be anything that the user defines.",
            "For defining how we group notes together and what measures we keep of each group and what kind of aggregation we apply, things like are we counting the datasets or are we summing the triples of them?",
            "And how are we grouping datasets together?",
            "Is it by subject or is it by license or is by some other things we use?",
            "We use the busy bee so use basic graph patterns as defined in sparkle to define each of the dimensions, the measures and the relation.",
            "How do we decide that two nodes are related?"
        ],
        [
            "So using the examples from the load load cloud, we say that DVD and BBC music are related if there exists link set that goes from the 1st to the 2nd and the measure we are keeping here.",
            "For example, if we want to sum the number of tables is just the value of the trip."
        ],
        [
            "And that can be defined as a busy bee."
        ],
        [
            "Similarly for the dimensions of the subject.",
            "So for example, we can take the DCT subject to Group, Group the resource, and similarly we keep the trip."
        ],
        [
            "So that also can be defined using BGP."
        ],
        [
            "And the same thing goes for the object and this don't."
        ],
        [
            "Have to be the same.",
            "So in the examples I'm grouping the subjects by subject.",
            "So the subjects means that subject in the RDF triple and other subject is the subject is now.",
            "I realize that's not the best example, so I have two subjects, but anyway, and objects are also grouped by subjects, but there is nothing in the definition that requires these two to be the same, so you can group the subject by subject and group the objects by their license."
        ],
        [
            "So the formal definition of the graph operator is a chewable that has six elements.",
            "The last one is the reduction function, and then there's a D and I'm like there's a set of subject dimensions and the measure, so there can be multiple dimensions.",
            "Each of them is just tabbed like a basic graph pattern as defined in sparkle.",
            "Similarly for the object and the last one is the relation which defines.",
            "How do we decide that these two particular instances should be related in the group graph?",
            "And as I said, it's a 2."
        ],
        [
            "Steps operator so it goes from a row graph to the group graph, and then there's a.",
            "There's a like the operational semantics define exactly how the group graph like WhatsApp characteristics of the group graph to map to the original graph based on them dimensions and measures defined by the user.",
            "Um?"
        ],
        [
            "OK, so I'll move on to the actual implementation, so the operational semantic is independent of their implementation.",
            "It just describes what are the characteristics of the results.",
            "Giving the data in this slide I'm describing a particular implementation that we provided, and that's an in memory.",
            "In in memory algorithm to group the graph and it goes in three steps.",
            "The first one is building a binding table which uses all the dimensions, definitions, measures and relations to build like a table.",
            "And because all of these carbs this can be just used using any existing sparkle engine.",
            "So and this is where we can.",
            "This is this is where the benefit of defining this as a operator as part of Sparkle algebra like This is why it's beneficial to define it, because then the operator can just reuse the existing optimization, implementation, etc that exists in already exists for sparkle operator like boobs and filters and then just build on top of that.",
            "So we start with the with the graph we build the binding table and then the paper contains an algorithm that goes from the binding table to the group graph.",
            "So the details in the paper, but it's a linear algorithm in the size of the binding table, so just scans the table ones and build the group graph by by doing 3 aggregation in parallel, aggregating the subjects, aggregating the objects and aggregating the relations and the last step is just applying the reduction function, which just choose a construct template and replaces the variables with their values from the binding table."
        ],
        [
            "So the last section is an experiment, so this particular implementation was an extension to Apache Jena, so we extended the operator model.",
            "The set of operators in general by a new operator, which is gag, and we run the experiments using Berlin Sparkle benchmark data and SP2 bench, and we perform two types of tasks.",
            "That type summary is the schema schema, same as the schema discovery that I described so.",
            "It groups instances by their type and then counts the number of properties that exist between set of instances that are under particular type.",
            "The other set of queries just ressemble metrics scenario so it will it will.",
            "It will aggregate the SP2 benchmark which is bibliographic database on Co authorship and Co citations and then grouping the authors along different dimensions like the Institute they work in or grouping the papers in the conference they are published in.",
            "I'll just show here the results for the type summary using the SPM."
        ],
        [
            "Data, so we convert 4 four approach.",
            "The full sparkle is a big sparkle query which which is typically A3 select queries, select and aggregation so one query will aggregate based on the subject.",
            "One will aggregate based on the object and will aggregate based on the property and then these are three nested queries within one query surrounded with the construct query.",
            "It's a pretty complicated query, it's hard to write and then.",
            "So that's why it didn't contain an example.",
            "It's hard to fit in one slide, but just three select nested queries with the construct and the performance of such a query would be really bad, because the way the way the semantic is defined that each of these in other queries need to be calculated.",
            "Then they'll be joined.",
            "So you'll have this query executed three times, but aggregated three times along different direct different dimensions for the subject object properties.",
            "Then there's a join between them.",
            "Then you build the last, the last result, but this achieves the full result using one sparkle query.",
            "The second approach is using just three sparkle queries, so instead of having these three sparkle queries nested into one query, you can just execute one aggregation over the over the subjects.",
            "One aggregation over the objects and one of aggregation over the property, but that needs some kind of tricks or some proper thinking just to make sure that.",
            "When you put the results together, you get a graph.",
            "Things like what you, you are eyes you used in the contract.",
            "When you start, when you when you aggregate by subjects are the same when you use when you aggregate by relations.",
            "So when you just have the final result which is the Union of the three queries, they just match together and you'll get a graph.",
            "The reduced approach is just the normal sparkle aggregation query, so the result here is not a graph, it's just a table.",
            "So if we ignore grouping the subjects and objects and just interested in counting the properties, that's just a single normal aggregation query in spark it.",
            "So we wanted also to compare with this and this can be treated as a baseline, so this doesn't give the results we want, but gives a result that's slightly list.",
            "So we want just to quantify the additional costs that getting a graph result.",
            "Cost in comparison to just getting a single single aggregation so quick things for this penalty from going from reduced to gag.",
            "Overhead is minimal.",
            "So you can see like the numbers are in second.",
            "And the thing that we are performing through three aggregation and putting the results into graph.",
            "This is the extra overhead.",
            "However, in terms of performance.",
            "Not not a huge overhead in comparison of three sparkles, so executing three sparkle queries we have an like an improvement of between 2.5 and three times, and that's exactly because the query in three sparkles is executed three times.",
            "However, we executed once and then we have a linear algorithm that can groups the results simultaneously in parallel along the three required dimensions.",
            "Full sparkle as I said, showed very like.",
            "The performance was very bad, but that wasn't surprising because just following this the semantics there is a lot of extra work that's needed and such an optimization for engine is really hard to achieve because this is across queries that the three nested queries are just three separate queries that needs to be evaluated, although they are very similar to each other, but it seems that so this is across query optimization.",
            "That's usually not easy for engines to detect and make use of, so the performance tends to be really, really bad."
        ],
        [
            "OK, so in summary, we argue that a graph aggregation can be defined because it's very popular.",
            "It's it's used in literature.",
            "It's kind of deserves being defined as a first class operator within the Sparkle algebra.",
            "This will makes it easier to write queries easier for engineers to support and optimize and easier to do like so we have a formal definition of the operator, which means future work on.",
            "Like formally studying optimization opportunities and how this new operator can interact with existing operator.",
            "Should be easier.",
            "Things that are still open and we didn't address in the paper is like what step?",
            "So we didn't propose a particular syntax for this operator.",
            "Currently we directly plug it in for the implementation in Gina SSE, which is Jane's like behind the scene representation of the graph, so we don't have a particular suggestion on the syntax of the query.",
            "And we'd like to, so that also algorithm we provided is a single machine in memory of a memory algorithm.",
            "We would like to look into distributed implementation of the query, because maybe graph aggregation makes more sense when the graph is really big, and maybe it's distributed over different machines, so that's it from my side, thanks.",
            "So the current evaluation is only for in memory.",
            "Or do you also go beyond in memory?",
            "Like could you tell us what happens if you know if you go beyond the memory it has to go out?",
            "The graph is big, not distributed, but still big enough that it won't fit in in memory like what would happen then.",
            "Yeah, so the evaluation is just in memory, and that's the implementation currently just an extension of Jenna in memory engine.",
            "This distributed yeah is a slightly different story, but it's so the difference between this, this operator and the normal aggregation is that there are three aggregations that are taking place in parallel, so you kind of aggregate the subjects, aggregate the objects, aggregate the relation, and you need to keep track which goes where just to get a graph as a result.",
            "So I assume most of the existing techniques that are used to aggregate data in a distributed scenario applies here with some.",
            "Additional overhead just to keep track of which goes where.",
            "But yeah, so I. I assume it's it can be translated from existing algorithms if the data doesn't fit in memory in a single machine, then because the engine, like most of engine support falling back to the hard disk and like having a persistent data store, then exactly the existing engine can be used just out of the box.",
            "The part that's memory, which means just building the the binding table, which can be an expensive part of the execution.",
            "Then from there going to the group graph, which is like which is just based on our algorithm.",
            "There's the assumption that the whole graph fits in data, but the whole aggregated graph, which means one node pair.",
            "All the nodes that share the subject and the twist, it was decided that they are grouped together.",
            "So it's a reasonable assumptions for a large set of data at some point, yeah.",
            "Till the group graph won't fit in memory and then it's just like falling back to the hard disk would be the option and then the current implementation would probably give bad performance, but I think it's more of an like just.",
            "Having just having that indentation.",
            "You mentioned that you you have this single sparkle query for calculating everything which is not quite good because it cannot be optimized by the engine.",
            "Probably then you have to three different queries.",
            "Did you also investigate it?",
            "How to how it would work if you create temporary graphs?",
            "Sparkle, update and use them.",
            "Am so if like if like the option of using a graph database would also be similar to creating a temporary graph.",
            "The problem here is that yeah, you need to restructure the data into a new graph each time you want to group to do an aggregation over a particular set of dimensions, which means each time you need a new query you will do a.",
            "Build a new graph and then load it and then execute again.",
            "So I didn't like compare that.",
            "I expect it to be costly operator like a costly procedure.",
            "Well, I can't tell numbers, but there's the problem of just you growing the size of the data and for each query you are doing the transformation again and again plus with like for future work we were thinking that sometimes if you group along a set of dimensions.",
            "And then you want to use a super set of that super set or a subset of that you can.",
            "You can use the aggregated results without without going through the intermediary step using the operator, so it can be reasoned and then you go directly from the group graph to another group graph without touching the original data.",
            "If the approach was transforming the road data each time, the query would be executed, then this means you always have to go back to the data.",
            "Thanks.",
            "Hi, so aggregations kind of transformation of the graph.",
            "Could you imagine to extend your operators to do more general graph transformations?",
            "So for example summarization.",
            "Yeah.",
            "So summarization in terms of doing like looking into the data and doing more of clustering techniques would be very different.",
            "So the idea here is that the user defines everything.",
            "So he would say these nodes should be like.",
            "In general these two nodes are considered related if exactly they are connected this way, and these nodes should be aggregated if they share the like a set of values along these tubes or one etc.",
            "So this is a form of summarization, but that's completely user defined.",
            "But I imagine like if you want to go like do kind of smart summarization that can just look at the data without much user input and and do that calculation, that's probably that's very interesting.",
            "Kind of line of work.",
            "But no, I don't think what we did here would be of much help there.",
            "Have you studied or have you given any thought in how this work could be applied on the evolving context of graphs where you know you like?",
            "Do some optimization for for incrementally aggregating graphs and discount?",
            "Because the way I see it like in the example of the load cloud, there's a lot of valuable information in how these aggregations evolve across time.",
            "OK, yeah, I like I didn't.",
            "It's just like one of the things that we discussed during the work.",
            "And so things like.",
            "It's like solving it in general is really hard, but then if you if you limit yourself a bit like if you know that aggregation function is an associative associative function and you have the same set of dimensions, then you can always go from an aggregated graph and just get the new data there.",
            "So we kind of try to to investigate that direction.",
            "That quick conclusion was it's really hard to have a generic recommendation or generic algorithm to do all that.",
            "Things, but if you restrict the dimensions or the aggregation functions then you might be able to provide optimized solution for like evolving contexts.",
            "But in general so we didn't.",
            "OK, just for me, your last quick questions, easier implementations available, not yet it's planned to, it's yeah, so it's a good quality code which we're happy to share it on Git lab, which is the inside.",
            "So there's just the final step which is getting the Institute approval that.",
            "But it's kind of ready to be shared.",
            "So thanks again, and let's say Thanks buddy."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Hello everyone, so let.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We start by the famous image of the load cloud, so that's the load cloud diagram which directs the status of the open data that's published as linked data.",
                    "label": 1
                },
                {
                    "sent": "We probably all know it, so each bubble in the graph is a data set and the size of the bubble is proportional to the number of triples as contained in that in that data set link or an edge or an arrow arrow exists between two bubbles.",
                    "label": 0
                },
                {
                    "sent": "If the instances of one data set interlinks contains interlinks two instances in other datasets.",
                    "label": 0
                },
                {
                    "sent": "And enter links is that these interlinked?",
                    "label": 0
                },
                {
                    "sent": "These links are the interesting part and this is what makes this link data and this is what makes this diagram actually a graph on the raw RDF data or the raw data behind this diagram is available in RDF.",
                    "label": 0
                },
                {
                    "sent": "It's it's described using the Void vocabulary.",
                    "label": 0
                },
                {
                    "sent": "So if you go to load cloud.net data, that's for the TTL.",
                    "label": 0
                },
                {
                    "sent": "You get that row data which contains extra metadata about each of these datasets, and.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Using this metadata, when can have different versions of the diagram.",
                    "label": 0
                },
                {
                    "sent": "Something like, we can have a colored version of the load cloud where each bubble is colored based on its subject or its main theme.",
                    "label": 0
                },
                {
                    "sent": "So for example, in this in this diagram, the publications are in green geographic data, government data, each one got its own color based on the subject, but that's not the only view over Link data cloud that we might have.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "For example, in this diagram I I took this arrow data and instead of having a bubble per data set, I have a purple pair category.",
                    "label": 0
                },
                {
                    "sent": "So all the datasets that are that are classified under publications, for example, will contribute to this one bubble and similarly the size of each bubble is proportional to the number of datasets that's under that category in the diagram, and the connections between the datasets also, like the thickness represents the number of links it's between the different categories.",
                    "label": 0
                },
                {
                    "sent": "So one important point to note here that this is a graph.",
                    "label": 0
                },
                {
                    "sent": "This is.",
                    "label": 0
                },
                {
                    "sent": "This is still a graph data and then all the graph measures.",
                    "label": 0
                },
                {
                    "sent": "All the graph algorithms can be applied over this data.",
                    "label": 0
                },
                {
                    "sent": "I can even query this data using Sparkle or any other graph query language.",
                    "label": 0
                },
                {
                    "sent": "But again, this is not the only way I can look or not.",
                    "label": 0
                },
                {
                    "sent": "The only perspective I can have over the load the diagram.",
                    "label": 0
                },
                {
                    "sent": "So for example, instead of just counting the number of datasets per category.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "I can sum the travel in in each of these datasets, so if you just.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Look at them publications and the government.",
                    "label": 0
                },
                {
                    "sent": "In this diagram, the green and the red.",
                    "label": 0
                },
                {
                    "sent": "So this is counting the data set.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In the next diagram, I'm summing that rebels and the government datasets that in the in the load cloud tends to be big.",
                    "label": 0
                },
                {
                    "sent": "And that's why the size of the bubble gets bigger, but.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Similarly, I don't have to only group the datasets based on their category, so that's another example where I grouped the datasets based on the license they are available under, so I can see like things like CC, the UK Crown etc GPL etc and they can only and also analyze the links like how datasets that are licensed under some open license, for example, interlinks with datasets that are.",
                    "label": 0
                },
                {
                    "sent": "Published under a closed license, and similarly I can.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Found the datasets or I can have some of the tribbles paired datasets, so all these examples provide an aggregation over the graph data, so the row graph data is the data that provided the original load load cloud and I can have different aggregations over this data as shown in the examples and in general graph aggregation.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Provide structurally similar but smaller graph by collapsing vertices and edges, and it's a common operator, so I showed some some examples, But if you look at literature there is a large number of the usage of such a graph aggregations, so another.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Well, I want to mention is the schema discovery.",
                    "label": 1
                },
                {
                    "sent": "So we have data doesn't have a fixed schema and one line of work looks at the data and try to kind of mind the schema based on the data.",
                    "label": 0
                },
                {
                    "sent": "So this is a work from Steven Computers, a coauthor of this award where he would give a summary of a big RDF data that says, you know in this data set there was ten instances of type of person, for example, and 25 of type organization.",
                    "label": 0
                },
                {
                    "sent": "And between these two sets of instances, there are maybe 55 member relationships ships, an three works for or something like that.",
                    "label": 0
                },
                {
                    "sent": "So that's also an example of a graph aggregation and similarly graph graph aggregation is used in social network analysis in people you like for bibliometrics, in bioinformatics, and in many many other domains, an important point to note here that aggregation itself is a graph, so you can whatever applies to the original data, which is.",
                    "label": 0
                },
                {
                    "sent": "The graph also applies to the.",
                    "label": 0
                },
                {
                    "sent": "Aggregated data, which is which is also a graph, and which schemes the relationship between between the nodes.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So if we want to focus on this operator and try to solicit the requirements for the scenarios that are reported in literature, I'll use the examples of the load cloud here so things do notes that if we consider two entities as related, they don't necessarily have a direct link between each other.",
                    "label": 0
                },
                {
                    "sent": "So for example, here DVD and BBC Music they have some interlink.",
                    "label": 0
                },
                {
                    "sent": "They have links that connects resources between each other.",
                    "label": 0
                },
                {
                    "sent": "And using the description that uses void.",
                    "label": 0
                },
                {
                    "sent": "It says that there is a link set that goes from one data set to another.",
                    "label": 0
                },
                {
                    "sent": "Similarly when I group the particular set of nodes, I don't necessarily group them by direct properties of them.",
                    "label": 0
                },
                {
                    "sent": "So if I want to group all the datasets that are under an open license, I have to navigate a path in the graph.",
                    "label": 0
                },
                {
                    "sent": "So I have to see the license, then look whether it is an open license or a closed license.",
                    "label": 0
                },
                {
                    "sent": "Another example might be the country where the publisher is, so I have to go to the publishers and see in which country.",
                    "label": 0
                },
                {
                    "sent": "That publisher is located.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So I have many options to achieve such an aggregation.",
                    "label": 0
                },
                {
                    "sent": "Custom code obviously is 1.",
                    "label": 1
                },
                {
                    "sent": "One of these options, but this is also achievable using sparkle.",
                    "label": 0
                },
                {
                    "sent": "However, as I'll show in like you need a complicated sparkle query, the straightforward sparkle query aggregation Sparkle query will give you a table, right.",
                    "label": 0
                },
                {
                    "sent": "It will give you some data points, but to achieve the keep the graph structure in the summary graph you will typically need three nested sparkle queries.",
                    "label": 0
                },
                {
                    "sent": "One that groups the subjects when that's groups objects and one that's groups and kind of aggregate the relation, and then you need.",
                    "label": 0
                },
                {
                    "sent": "And construct to surround of all of these, so that's error prone.",
                    "label": 0
                },
                {
                    "sent": "That's hard to write, hard to understand, but even more, this is hard for engineers to optimize, and I'll come back to this point during the evaluation.",
                    "label": 0
                },
                {
                    "sent": "One can also use graph databases, so graph databases will have some graph databases will have a graph aggregation operators, which does exactly that.",
                    "label": 1
                },
                {
                    "sent": "However, the main problem would be the expressivity, because most of all of the work that we came across in literature.",
                    "label": 0
                },
                {
                    "sent": "Assumes a direct relation between the two entities and assumes that the dimensions that are used to aggregate nodes are direct reportees of the nodes, so I can't do something like following a path as I showed in that in the example and therefore this paper suggests an U operator.",
                    "label": 0
                },
                {
                    "sent": "We called it gag for graph aggregator and we define this operator on top of the Sparkle algebra, which means we can reuse the formal model and the implementation and.",
                    "label": 0
                },
                {
                    "sent": "All the hard work that has been done in optimizing the existing existing other graph.",
                    "label": 0
                },
                {
                    "sent": "Other sparkle operators and then define a new operator that just reuse as much of that as possible.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So in the rest of the presentation, I'll quickly talk about the operational semantics, so if anyone is interested, the paper contains a formal description of the operator and the formal description of its operational semantics, which means if you want to implement that, you have like a blueprint.",
                    "label": 0
                },
                {
                    "sent": "To do that.",
                    "label": 0
                },
                {
                    "sent": "I'll also quickly show a particular algorithm which provides an particular evaluation of that of that operator in memory, and then expect an experimental evaluation.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In general, the graph operator as we defined it is a two step process which starts with the role graph.",
                    "label": 0
                },
                {
                    "sent": "The whole graph, RDF graph data and then it groups notes and it is based on some criteria to get a group graph.",
                    "label": 0
                },
                {
                    "sent": "So that's done in the in the middle and then I reduce function which which takes this group graph and give you the final results.",
                    "label": 0
                },
                {
                    "sent": "Group graph would represent won't be in RDF.",
                    "label": 0
                },
                {
                    "sent": "Data is just an intermediary step, but it allows.",
                    "label": 0
                },
                {
                    "sent": "The operator to be flexible and.",
                    "label": 0
                },
                {
                    "sent": "By defining a reduce function, this means that the results can be anything that the user the user chooses and.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "This is achieved by using something a template which is very similar to the construct template query.",
                    "label": 1
                },
                {
                    "sent": "So for the last step to go from the group graph to the final aggregated graph, it's using a template that's similar to the construct query, which means the shape of the final result is just defined by the user and can be anything that the user defines.",
                    "label": 0
                },
                {
                    "sent": "For defining how we group notes together and what measures we keep of each group and what kind of aggregation we apply, things like are we counting the datasets or are we summing the triples of them?",
                    "label": 0
                },
                {
                    "sent": "And how are we grouping datasets together?",
                    "label": 0
                },
                {
                    "sent": "Is it by subject or is it by license or is by some other things we use?",
                    "label": 0
                },
                {
                    "sent": "We use the busy bee so use basic graph patterns as defined in sparkle to define each of the dimensions, the measures and the relation.",
                    "label": 0
                },
                {
                    "sent": "How do we decide that two nodes are related?",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So using the examples from the load load cloud, we say that DVD and BBC music are related if there exists link set that goes from the 1st to the 2nd and the measure we are keeping here.",
                    "label": 0
                },
                {
                    "sent": "For example, if we want to sum the number of tables is just the value of the trip.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And that can be defined as a busy bee.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Similarly for the dimensions of the subject.",
                    "label": 0
                },
                {
                    "sent": "So for example, we can take the DCT subject to Group, Group the resource, and similarly we keep the trip.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So that also can be defined using BGP.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And the same thing goes for the object and this don't.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Have to be the same.",
                    "label": 0
                },
                {
                    "sent": "So in the examples I'm grouping the subjects by subject.",
                    "label": 0
                },
                {
                    "sent": "So the subjects means that subject in the RDF triple and other subject is the subject is now.",
                    "label": 0
                },
                {
                    "sent": "I realize that's not the best example, so I have two subjects, but anyway, and objects are also grouped by subjects, but there is nothing in the definition that requires these two to be the same, so you can group the subject by subject and group the objects by their license.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the formal definition of the graph operator is a chewable that has six elements.",
                    "label": 0
                },
                {
                    "sent": "The last one is the reduction function, and then there's a D and I'm like there's a set of subject dimensions and the measure, so there can be multiple dimensions.",
                    "label": 0
                },
                {
                    "sent": "Each of them is just tabbed like a basic graph pattern as defined in sparkle.",
                    "label": 0
                },
                {
                    "sent": "Similarly for the object and the last one is the relation which defines.",
                    "label": 0
                },
                {
                    "sent": "How do we decide that these two particular instances should be related in the group graph?",
                    "label": 0
                },
                {
                    "sent": "And as I said, it's a 2.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Steps operator so it goes from a row graph to the group graph, and then there's a.",
                    "label": 0
                },
                {
                    "sent": "There's a like the operational semantics define exactly how the group graph like WhatsApp characteristics of the group graph to map to the original graph based on them dimensions and measures defined by the user.",
                    "label": 0
                },
                {
                    "sent": "Um?",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, so I'll move on to the actual implementation, so the operational semantic is independent of their implementation.",
                    "label": 0
                },
                {
                    "sent": "It just describes what are the characteristics of the results.",
                    "label": 0
                },
                {
                    "sent": "Giving the data in this slide I'm describing a particular implementation that we provided, and that's an in memory.",
                    "label": 0
                },
                {
                    "sent": "In in memory algorithm to group the graph and it goes in three steps.",
                    "label": 0
                },
                {
                    "sent": "The first one is building a binding table which uses all the dimensions, definitions, measures and relations to build like a table.",
                    "label": 0
                },
                {
                    "sent": "And because all of these carbs this can be just used using any existing sparkle engine.",
                    "label": 0
                },
                {
                    "sent": "So and this is where we can.",
                    "label": 0
                },
                {
                    "sent": "This is this is where the benefit of defining this as a operator as part of Sparkle algebra like This is why it's beneficial to define it, because then the operator can just reuse the existing optimization, implementation, etc that exists in already exists for sparkle operator like boobs and filters and then just build on top of that.",
                    "label": 0
                },
                {
                    "sent": "So we start with the with the graph we build the binding table and then the paper contains an algorithm that goes from the binding table to the group graph.",
                    "label": 0
                },
                {
                    "sent": "So the details in the paper, but it's a linear algorithm in the size of the binding table, so just scans the table ones and build the group graph by by doing 3 aggregation in parallel, aggregating the subjects, aggregating the objects and aggregating the relations and the last step is just applying the reduction function, which just choose a construct template and replaces the variables with their values from the binding table.",
                    "label": 1
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So the last section is an experiment, so this particular implementation was an extension to Apache Jena, so we extended the operator model.",
                    "label": 1
                },
                {
                    "sent": "The set of operators in general by a new operator, which is gag, and we run the experiments using Berlin Sparkle benchmark data and SP2 bench, and we perform two types of tasks.",
                    "label": 0
                },
                {
                    "sent": "That type summary is the schema schema, same as the schema discovery that I described so.",
                    "label": 0
                },
                {
                    "sent": "It groups instances by their type and then counts the number of properties that exist between set of instances that are under particular type.",
                    "label": 0
                },
                {
                    "sent": "The other set of queries just ressemble metrics scenario so it will it will.",
                    "label": 0
                },
                {
                    "sent": "It will aggregate the SP2 benchmark which is bibliographic database on Co authorship and Co citations and then grouping the authors along different dimensions like the Institute they work in or grouping the papers in the conference they are published in.",
                    "label": 0
                },
                {
                    "sent": "I'll just show here the results for the type summary using the SPM.",
                    "label": 1
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Data, so we convert 4 four approach.",
                    "label": 0
                },
                {
                    "sent": "The full sparkle is a big sparkle query which which is typically A3 select queries, select and aggregation so one query will aggregate based on the subject.",
                    "label": 0
                },
                {
                    "sent": "One will aggregate based on the object and will aggregate based on the property and then these are three nested queries within one query surrounded with the construct query.",
                    "label": 0
                },
                {
                    "sent": "It's a pretty complicated query, it's hard to write and then.",
                    "label": 0
                },
                {
                    "sent": "So that's why it didn't contain an example.",
                    "label": 0
                },
                {
                    "sent": "It's hard to fit in one slide, but just three select nested queries with the construct and the performance of such a query would be really bad, because the way the way the semantic is defined that each of these in other queries need to be calculated.",
                    "label": 0
                },
                {
                    "sent": "Then they'll be joined.",
                    "label": 0
                },
                {
                    "sent": "So you'll have this query executed three times, but aggregated three times along different direct different dimensions for the subject object properties.",
                    "label": 0
                },
                {
                    "sent": "Then there's a join between them.",
                    "label": 0
                },
                {
                    "sent": "Then you build the last, the last result, but this achieves the full result using one sparkle query.",
                    "label": 0
                },
                {
                    "sent": "The second approach is using just three sparkle queries, so instead of having these three sparkle queries nested into one query, you can just execute one aggregation over the over the subjects.",
                    "label": 0
                },
                {
                    "sent": "One aggregation over the objects and one of aggregation over the property, but that needs some kind of tricks or some proper thinking just to make sure that.",
                    "label": 0
                },
                {
                    "sent": "When you put the results together, you get a graph.",
                    "label": 0
                },
                {
                    "sent": "Things like what you, you are eyes you used in the contract.",
                    "label": 0
                },
                {
                    "sent": "When you start, when you when you aggregate by subjects are the same when you use when you aggregate by relations.",
                    "label": 0
                },
                {
                    "sent": "So when you just have the final result which is the Union of the three queries, they just match together and you'll get a graph.",
                    "label": 0
                },
                {
                    "sent": "The reduced approach is just the normal sparkle aggregation query, so the result here is not a graph, it's just a table.",
                    "label": 0
                },
                {
                    "sent": "So if we ignore grouping the subjects and objects and just interested in counting the properties, that's just a single normal aggregation query in spark it.",
                    "label": 0
                },
                {
                    "sent": "So we wanted also to compare with this and this can be treated as a baseline, so this doesn't give the results we want, but gives a result that's slightly list.",
                    "label": 0
                },
                {
                    "sent": "So we want just to quantify the additional costs that getting a graph result.",
                    "label": 0
                },
                {
                    "sent": "Cost in comparison to just getting a single single aggregation so quick things for this penalty from going from reduced to gag.",
                    "label": 0
                },
                {
                    "sent": "Overhead is minimal.",
                    "label": 0
                },
                {
                    "sent": "So you can see like the numbers are in second.",
                    "label": 0
                },
                {
                    "sent": "And the thing that we are performing through three aggregation and putting the results into graph.",
                    "label": 0
                },
                {
                    "sent": "This is the extra overhead.",
                    "label": 0
                },
                {
                    "sent": "However, in terms of performance.",
                    "label": 0
                },
                {
                    "sent": "Not not a huge overhead in comparison of three sparkles, so executing three sparkle queries we have an like an improvement of between 2.5 and three times, and that's exactly because the query in three sparkles is executed three times.",
                    "label": 0
                },
                {
                    "sent": "However, we executed once and then we have a linear algorithm that can groups the results simultaneously in parallel along the three required dimensions.",
                    "label": 0
                },
                {
                    "sent": "Full sparkle as I said, showed very like.",
                    "label": 0
                },
                {
                    "sent": "The performance was very bad, but that wasn't surprising because just following this the semantics there is a lot of extra work that's needed and such an optimization for engine is really hard to achieve because this is across queries that the three nested queries are just three separate queries that needs to be evaluated, although they are very similar to each other, but it seems that so this is across query optimization.",
                    "label": 0
                },
                {
                    "sent": "That's usually not easy for engines to detect and make use of, so the performance tends to be really, really bad.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, so in summary, we argue that a graph aggregation can be defined because it's very popular.",
                    "label": 1
                },
                {
                    "sent": "It's it's used in literature.",
                    "label": 0
                },
                {
                    "sent": "It's kind of deserves being defined as a first class operator within the Sparkle algebra.",
                    "label": 1
                },
                {
                    "sent": "This will makes it easier to write queries easier for engineers to support and optimize and easier to do like so we have a formal definition of the operator, which means future work on.",
                    "label": 1
                },
                {
                    "sent": "Like formally studying optimization opportunities and how this new operator can interact with existing operator.",
                    "label": 0
                },
                {
                    "sent": "Should be easier.",
                    "label": 0
                },
                {
                    "sent": "Things that are still open and we didn't address in the paper is like what step?",
                    "label": 0
                },
                {
                    "sent": "So we didn't propose a particular syntax for this operator.",
                    "label": 0
                },
                {
                    "sent": "Currently we directly plug it in for the implementation in Gina SSE, which is Jane's like behind the scene representation of the graph, so we don't have a particular suggestion on the syntax of the query.",
                    "label": 0
                },
                {
                    "sent": "And we'd like to, so that also algorithm we provided is a single machine in memory of a memory algorithm.",
                    "label": 0
                },
                {
                    "sent": "We would like to look into distributed implementation of the query, because maybe graph aggregation makes more sense when the graph is really big, and maybe it's distributed over different machines, so that's it from my side, thanks.",
                    "label": 0
                },
                {
                    "sent": "So the current evaluation is only for in memory.",
                    "label": 0
                },
                {
                    "sent": "Or do you also go beyond in memory?",
                    "label": 0
                },
                {
                    "sent": "Like could you tell us what happens if you know if you go beyond the memory it has to go out?",
                    "label": 0
                },
                {
                    "sent": "The graph is big, not distributed, but still big enough that it won't fit in in memory like what would happen then.",
                    "label": 0
                },
                {
                    "sent": "Yeah, so the evaluation is just in memory, and that's the implementation currently just an extension of Jenna in memory engine.",
                    "label": 0
                },
                {
                    "sent": "This distributed yeah is a slightly different story, but it's so the difference between this, this operator and the normal aggregation is that there are three aggregations that are taking place in parallel, so you kind of aggregate the subjects, aggregate the objects, aggregate the relation, and you need to keep track which goes where just to get a graph as a result.",
                    "label": 0
                },
                {
                    "sent": "So I assume most of the existing techniques that are used to aggregate data in a distributed scenario applies here with some.",
                    "label": 0
                },
                {
                    "sent": "Additional overhead just to keep track of which goes where.",
                    "label": 0
                },
                {
                    "sent": "But yeah, so I. I assume it's it can be translated from existing algorithms if the data doesn't fit in memory in a single machine, then because the engine, like most of engine support falling back to the hard disk and like having a persistent data store, then exactly the existing engine can be used just out of the box.",
                    "label": 0
                },
                {
                    "sent": "The part that's memory, which means just building the the binding table, which can be an expensive part of the execution.",
                    "label": 0
                },
                {
                    "sent": "Then from there going to the group graph, which is like which is just based on our algorithm.",
                    "label": 0
                },
                {
                    "sent": "There's the assumption that the whole graph fits in data, but the whole aggregated graph, which means one node pair.",
                    "label": 0
                },
                {
                    "sent": "All the nodes that share the subject and the twist, it was decided that they are grouped together.",
                    "label": 0
                },
                {
                    "sent": "So it's a reasonable assumptions for a large set of data at some point, yeah.",
                    "label": 0
                },
                {
                    "sent": "Till the group graph won't fit in memory and then it's just like falling back to the hard disk would be the option and then the current implementation would probably give bad performance, but I think it's more of an like just.",
                    "label": 0
                },
                {
                    "sent": "Having just having that indentation.",
                    "label": 0
                },
                {
                    "sent": "You mentioned that you you have this single sparkle query for calculating everything which is not quite good because it cannot be optimized by the engine.",
                    "label": 0
                },
                {
                    "sent": "Probably then you have to three different queries.",
                    "label": 0
                },
                {
                    "sent": "Did you also investigate it?",
                    "label": 0
                },
                {
                    "sent": "How to how it would work if you create temporary graphs?",
                    "label": 0
                },
                {
                    "sent": "Sparkle, update and use them.",
                    "label": 0
                },
                {
                    "sent": "Am so if like if like the option of using a graph database would also be similar to creating a temporary graph.",
                    "label": 0
                },
                {
                    "sent": "The problem here is that yeah, you need to restructure the data into a new graph each time you want to group to do an aggregation over a particular set of dimensions, which means each time you need a new query you will do a.",
                    "label": 0
                },
                {
                    "sent": "Build a new graph and then load it and then execute again.",
                    "label": 0
                },
                {
                    "sent": "So I didn't like compare that.",
                    "label": 0
                },
                {
                    "sent": "I expect it to be costly operator like a costly procedure.",
                    "label": 0
                },
                {
                    "sent": "Well, I can't tell numbers, but there's the problem of just you growing the size of the data and for each query you are doing the transformation again and again plus with like for future work we were thinking that sometimes if you group along a set of dimensions.",
                    "label": 0
                },
                {
                    "sent": "And then you want to use a super set of that super set or a subset of that you can.",
                    "label": 0
                },
                {
                    "sent": "You can use the aggregated results without without going through the intermediary step using the operator, so it can be reasoned and then you go directly from the group graph to another group graph without touching the original data.",
                    "label": 0
                },
                {
                    "sent": "If the approach was transforming the road data each time, the query would be executed, then this means you always have to go back to the data.",
                    "label": 0
                },
                {
                    "sent": "Thanks.",
                    "label": 0
                },
                {
                    "sent": "Hi, so aggregations kind of transformation of the graph.",
                    "label": 0
                },
                {
                    "sent": "Could you imagine to extend your operators to do more general graph transformations?",
                    "label": 0
                },
                {
                    "sent": "So for example summarization.",
                    "label": 0
                },
                {
                    "sent": "Yeah.",
                    "label": 0
                },
                {
                    "sent": "So summarization in terms of doing like looking into the data and doing more of clustering techniques would be very different.",
                    "label": 0
                },
                {
                    "sent": "So the idea here is that the user defines everything.",
                    "label": 0
                },
                {
                    "sent": "So he would say these nodes should be like.",
                    "label": 0
                },
                {
                    "sent": "In general these two nodes are considered related if exactly they are connected this way, and these nodes should be aggregated if they share the like a set of values along these tubes or one etc.",
                    "label": 0
                },
                {
                    "sent": "So this is a form of summarization, but that's completely user defined.",
                    "label": 0
                },
                {
                    "sent": "But I imagine like if you want to go like do kind of smart summarization that can just look at the data without much user input and and do that calculation, that's probably that's very interesting.",
                    "label": 0
                },
                {
                    "sent": "Kind of line of work.",
                    "label": 0
                },
                {
                    "sent": "But no, I don't think what we did here would be of much help there.",
                    "label": 0
                },
                {
                    "sent": "Have you studied or have you given any thought in how this work could be applied on the evolving context of graphs where you know you like?",
                    "label": 0
                },
                {
                    "sent": "Do some optimization for for incrementally aggregating graphs and discount?",
                    "label": 0
                },
                {
                    "sent": "Because the way I see it like in the example of the load cloud, there's a lot of valuable information in how these aggregations evolve across time.",
                    "label": 0
                },
                {
                    "sent": "OK, yeah, I like I didn't.",
                    "label": 0
                },
                {
                    "sent": "It's just like one of the things that we discussed during the work.",
                    "label": 0
                },
                {
                    "sent": "And so things like.",
                    "label": 0
                },
                {
                    "sent": "It's like solving it in general is really hard, but then if you if you limit yourself a bit like if you know that aggregation function is an associative associative function and you have the same set of dimensions, then you can always go from an aggregated graph and just get the new data there.",
                    "label": 0
                },
                {
                    "sent": "So we kind of try to to investigate that direction.",
                    "label": 0
                },
                {
                    "sent": "That quick conclusion was it's really hard to have a generic recommendation or generic algorithm to do all that.",
                    "label": 0
                },
                {
                    "sent": "Things, but if you restrict the dimensions or the aggregation functions then you might be able to provide optimized solution for like evolving contexts.",
                    "label": 0
                },
                {
                    "sent": "But in general so we didn't.",
                    "label": 0
                },
                {
                    "sent": "OK, just for me, your last quick questions, easier implementations available, not yet it's planned to, it's yeah, so it's a good quality code which we're happy to share it on Git lab, which is the inside.",
                    "label": 0
                },
                {
                    "sent": "So there's just the final step which is getting the Institute approval that.",
                    "label": 0
                },
                {
                    "sent": "But it's kind of ready to be shared.",
                    "label": 0
                },
                {
                    "sent": "So thanks again, and let's say Thanks buddy.",
                    "label": 0
                }
            ]
        }
    }
}