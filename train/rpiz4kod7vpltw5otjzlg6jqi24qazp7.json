{
    "id": "rpiz4kod7vpltw5otjzlg6jqi24qazp7",
    "title": "Computing Applicability Conditions for Plans with Loops",
    "info": {
        "author": [
            "Siddharth Srivastava, University of Massachusetts Amherst"
        ],
        "published": "Nov. 15, 2010",
        "recorded": "May 2010",
        "category": [
            "Top->Computer Science->Artificial Intelligence"
        ]
    },
    "url": "http://videolectures.net/icaps2010_srivastava_cacpl/",
    "segmentation": [
        [
            "Hey, I'm so tired and I'll be talking about computing applicability conditions for plans with loops."
        ],
        [
            "So let's first look at why we want to find plans with boots.",
            "So here we see a simple example in of a contingent plan where we're going through a set of objects.",
            "We're incrementally sensing the type of each object and so sorting it in its container.",
            "So this plan works well, except that it's going to grow exponentially with the number of objects and doing a lot of reputation without really recognizing this.",
            "So it would be much better if we could find a plan like this which has a cyclic flow of control, and it's essentially repeating the same set of actions over the different objects."
        ],
        [
            "But the problem is in finding such plans we need to determine what these leaps loops are doing in order period to be able to.",
            "And it's clear that we want them because they are much more small.",
            "They're much more general, and they also allow us to work with unknown quantities of object."
        ],
        [
            "In fact, plans with loops provide a great opportunity for planned reuse, so here we are looking at a plan that works in the grid world and it essentially traverses the gridworld, the boundary of the great World by going around it looking for these corners BC&D."
        ],
        [
            "So if we look at action of this plan without caring about these observations, then we can actually utilize this plan to reach any point in the center of the grid that is in the interior of the grid and all we need to do to be able to do this is to study what each loop is doing and figure out the number of iterations required for reaching any point in the interior.",
            "So clearly if we can analyze plans with loops, we can reuse them and we get some benefit."
        ],
        [
            "But if we don't analyze plans with loops, we can end up in serious problems.",
            "So here we have with loops which is traversing the grid world.",
            "It's essentially alternating along the road starting at the bottom left, and the idea is to stop when you reach a certain square which is marked G for the goal.",
            "So this is going to work fine on any such."
        ],
        [
            "Great, but if we're looking to apply it on different problem instances and if we don't carefully understand when this should be applied, we may end up applying it on a grid like this, which is very similar to the previous grid, but in this case the plan will never read G. In fact, reverse the almost the entire state space before you figure out that it's not really reached the goal."
        ],
        [
            "So the conclusion of all this is we need to analyze loops of actions both during the construction of plants to determine if a potential loop of actions is going to be useful, or if it's going to terminate at all.",
            "And even during construction, or sorry, even after construction to figure out if a plan with loops is going to be applicable to a certain problem and how we should install it to solve a certain problem instance.",
            "This brings Up's longstanding issues of plan reuse which have been studied in the context of linear.",
            "Plans and in terms of linear sub sequences of actions.",
            "But when we introduce loops all of these problems become much more complicated."
        ],
        [
            "So the state of the art in finding such plans with loops is to observe working plans and then go ahead and extract some repeating patterns of actions or sub sequences, and then you can put these two where and if you do this, the loop utility is mostly being justified by prior experience.",
            "So we're projecting from what we saw worked earlier when we want to execute plans.",
            "The approach typically is to apply it on any given problem instance or in other words, simulate the plan and if it reaches the goal, that's good.",
            "But if not, we can spawn off a classical planning process or use some other process at that stage.",
            "But as I mentioned before, applying plans in this, we can be very wasteful and you might end up traversing space if you have plans with loops as an exception, I should note that lyrics approach does provide a partial precondition test where you can if you have problem instances, that way over a single planning parimeter you can go ahead and check if your plan is actually going to solve this problem, But in general in both plan generation and plan execution.",
            "The fundamental problems are that we don't know how to figure out if a plan with loops is going to terminate and how to figure out when a certain goal node is going to be reachable through a plan with loops.",
            "So my talk will focus on these problems and we'll try to study when we can identify or solve these problems accurately, and what the boundaries of.",
            "Decidability in."
        ],
        [
            "Ask Acer.",
            "OK, so this is an overview of the talk.",
            "I'll first define Abacus programs, which are simple and elegant framework for computation, and I'll study different classes of Abacus programs based on their graph structure.",
            "Find preconditions or develop algorithms for finding preconditions efficiently in each of these classes.",
            "We'll then see how an approach for finding plans with loops that we've been working on for a few years can be seen as an approach for translating plans into Abacus programs, so we can go ahead and apply these algorithms on these plans even during construction.",
            "And finally, I'll look at some empirical results showing how difficult or easy it is to compute these preconditions."
        ],
        [
            "OK, so Abacus programs of a finite set of registers, finite set of States and specific initial state and a specific whole state.",
            "Their actions are very simple, so you can either have incrementing actions like.",
            "Like R2 plus plus here we just bumps up the register value of register by 1.",
            "You can have conditional decrement actions which look at a register and compare it with zero.",
            "So if the register is greater than zero, we decrement that register by 1 to a different state, or if it's equal to zero, we just moved to a different state without changing any action without changing any register.",
            "So even with this simple formulation, the Abacus Program's former Turing complete framework of computation, so the first bad news is that we cannot in general find preconditions for reaching a desired goal node with the desired set of registers in Abacus programs.",
            "But in the next few slides we will see that this can be done for certain classes of Abacus programs."
        ],
        [
            "So let's say we have a linear sequence of actions, and our objective here is to find a set of conditions for reaching a desired set of register values at S4, and we want these conditions to be in terms of register values at S, one that's the initial state for this segment."
        ],
        [
            "So the first step is to compute the value of register vector at every state, and if we can assume that all the required branches in this path are going to be taken, this is quite easy to do.",
            "So let's say our bar is the vector of register values in an.",
            "Let's say that we are representing changes due to each action as Delta, superscript that action.",
            "So to compute the value of the register vector at S2, we simply add the initial register vector with the change vector.",
            "Due to action one, and so on.",
            "And we can compute.",
            "The final values of register vectors at S4, assuming that all the right branches are going to be taken.",
            "So that's the first part.",
            "Now we need to figure out the conditions on our bar under which will take all the right brand.",
            "So in order to do this, we remember that whenever we have a decrementing action like this, all we need to do is check the value of the register that it's changing before that action is applied."
        ],
        [
            "So here we found that value.",
            "It's our bar and we projected it on the dimension that action even was changing and set it to be greater than 0.",
            "Because that's the condition we need so we can go ahead and do the same thing for this."
        ],
        [
            "And here and if we compose these conditions then we can find necessary and sufficient funds for reaching a desired set of register vectors.",
            "Register values.",
            "At a final note, starting with a given initial value.",
            "So here we have our bar as the initial and Fr is the final.",
            "OK, so we can deal with linear sequences of Abacus actions relatively easy."
        ],
        [
            "So let's look at what happens if we put these actions in a loop.",
            "Now we have a simple loop here, by which I just mean a cycle in a graph, and our objective is to compute necessary and sufficient conditions under which we can.",
            "A certain desired value of register vectors at S1, starting with this one and after doing L iterations of this loop."
        ],
        [
            "So let's say we have loop inequality and in this by the loop inequality I'm just going to refer to the set of inequalities that we developed before, so the overall intuition is to treat each iteration of this loop as a single linear sequence of actions and we just want to repeat that sequence of actions L times.",
            "OK, so loop inequality is basically telling us that for zero starting with our bar zero, we can execute one complete iteration of this loop."
        ],
        [
            "Now let's say our bar X represents the value of these registers after X iterations, which which is easy to compute because we just add up the change due to each iteration."
        ],
        [
            "And then we can write down the inequality is required for L complete iterations.",
            "We basically saying that we want loop inequality to hold at Arbor Zero.",
            "That's the initial value of register vectors.",
            "We wanted to hold again after the first iteration and then so on.",
            "After L minus questions.",
            "So that's the complete set of conditions required to execute L independent iterations of this loop.",
            "Now, because these expressions for Arbor X are linear in terms of X, all of these inequalities are actually subsumed by just the first one and the last one, so that gives us the set of inequalities required to stay in the loop for L."
        ],
        [
            "Iterations.",
            "And then we can go ahead and compute the final values of register vectors equally easily by just adding up the change due to each iteration of the loop."
        ],
        [
            "So this means that in Abacus programs with simple loops or in a simple loop of Abacus actions, we can find necessary and sufficient conditions for executing L complete iterations of the loop and reaching a final desired set of register back vectors values.",
            "OK, so here we are treating F bar as the desired sector of register values and our buyer zero as the initial register vector.",
            "But we can treat Arbor Zero as tired register vector for proceeding segment of an Abacus program.",
            "So in this way we can combine these conditions with conditions for computing.",
            "For reaching this register vector are barred zero itself and in this way we can find the preconditions for any Abacus program that has only simple loops.",
            "We may need to use disjunctions if we have a state that has multiple edges that lead.",
            "It leads to the goal or a desired vectors."
        ],
        [
            "OK, so recall that our approach was going to be to translate plans with loops into Abacus programs or view plans with loops, Abacus programs, while preserving structure.",
            "Because structure is going to be very important in the algorithms that we've developed.",
            "And then we want to find algorithms for computing preconditions of classes of Abacus programs.",
            "Now, in order to do this efficiently, we need to somehow translate sensing actions as Abacus actions."
        ],
        [
            "And to do this we add a non deterministic set action action can either set a register to zero and go to a certain state or set it to one and go to a different state."
        ],
        [
            "We don't need this action to actually increase the power of Abacus programs, because they are already doing complete, but this action is going to help us to translate or view plans as Abacus program.",
            "So in the recycling problem, for instance, we will replace the sense type action with a non deterministic set action.",
            "And we'll replace all of the options with their own counterparts without changing the loop structure.",
            "And when we want to find preconditions will compute these conditions in terms of the number of times each branch is taken.",
            "So in this problem, we'd say something like the number of times you see the paper objects that should be less than or equal to the capacity of the paper container that you have."
        ],
        [
            "OK, so with these nondeterministic actions, we can look at a broader class of loops.",
            "So let's say we have a simple loop again.",
            "Now we have a green node that that's supposed to be a start node, so this is any node you can choose any node in the loop to be a start node, and then all these nondeterministic actions create branches that go ahead and join a later node in the loop.",
            "So by later, I mean later, as in starting from the start now."
        ],
        [
            "So it seems like this is a restricted frame."
        ],
        [
            "But actually, many so-called commonly understood nested loops can be translated into simple loops with shortcuts.",
            "By translating the start node.",
            "So this is a flexible framework as far as the graph topology is concerned."
        ],
        [
            "So let's say we have a simple loop with shortcut.",
            "Now the benefit in viewing it in this way or restricting these are study to these kind of loops is that we can look at every possible iteration around this start node, and in this case what we've done is we've considered all possible ways of completing the loop by taking all possible results of these nondeterministic actions.",
            "So basically, we're seeing what happens if we take a one and this branch of a two, and so on.",
            "So essentially we're decomposing a simple loop with shortcuts into different simple loops."
        ],
        [
            "So before we move on to some algorithms, let's define monotone shortcuts and hear what he is trying to say is that.",
            "Let's say you have a simple loop with shortcuts.",
            "The shortcuts are monotone if the net change on a register due to every simple aided by the shortcuts is in the same direction.",
            "So you have one set of registers are plus which are changed always positively, and one set of registers are minus, which are always changed negatively, so these changes are net negative changes on net positive changes."
        ],
        [
            "OK, so let's say we have a simple loop with shortcuts and we've decomposed it into M simple loops and we somehow for some reason we want to figure out what are the necessary and sufficient conditions for executing K1 through KM of each of these loops.",
            "So again, the final values of register vectors in terms of the initial values is relatively easy to compute.",
            "We just add the change due to each loop.",
            "Now to ensure that Ki iterations of loop I.",
            "Must be executed.",
            "We need to make sure that no register falls below 0 in these K iterations, and for that we need to identify the least intermediate value of every register and then set that to be greater than or equal to zero.",
            "That will give us a set set of sufficient conditions for executing K iterations of loop."
        ],
        [
            "OK, so this can be done in a relatively straightforward manner.",
            "Let's again, so we have two sets of registers, the R Plus registers, an R minus registers, and we're calling J hat to be the index of the loop, which causes the greatest initial negative change on a certain resistor.",
            "So even a positive register might undergo an initial change before it gets incremented again.",
            "So four registers belonging to our plus the least value is just the initial value plus the change due to this loop J hat.",
            "Because after this change the these registers are only going to increase.",
            "So the first part of these inequalities is just setting these registers to be above 0.",
            "OK, and for registers belonging to R minus what we do is take the loop that creates the greatest initial negative change and put its iteration at the end after executing every other loop so that we get the largest decrement in this registers vector value.",
            "So these set of conditions for all the registers give us a set of sufficient conditions, but I haven't talked about what happens if we have equality constraints for staying in the loop, and I haven't said what to do if the loop J hat is not executed at all.",
            "So in the paper we discuss these constraints and we can extend these conditions to deal with those situations.",
            "This is the basic idea and I'll go back to this point after a small example."
        ],
        [
            "So let's say we have this method for computing our constraints on minimum register values.",
            "And let's say we have a simple loop with shortcuts which we've decomposed into two loops.",
            "So Loop 1 first increases register by one, sorry by three and Loop 2 first decreases it by two and then increases it by 5.",
            "So we're still in the monotone shortcut setting, but."
        ],
        [
            "If we go and apply our method then we get the constraint which says that the initial value of register R1 should be at least two and this is a sufficient condition for executing loop one and loop 21 iteration of each loop."
        ],
        [
            "But if we look at the true necessary and sufficient conditions, then they actually depend on the order in which we execute these two loops.",
            "We could execute Loop 1 first and then we won't.",
            "We don't need any such condition, but in an adversarial setting, if you don't control the nondeterministic outcomes which which is going to be the case, in practice, these conditions that we computer actually the true conditions that you need.",
            "But in theory, computing accurate conditions is order dependent, and that itself expressing these constraints itself is a big problem.",
            "So in our results, we're going to restrict ourselves in some sense to order independent."
        ],
        [
            "Suck it so.",
            "Let me now come back to the equality constraints and essentially whenever you have an equality constraint for staying in the loop.",
            "This introduces a very strong kind of order dependence.",
            "In such case, want to be able to say that this particular outcome of a two will occur exactly in the iteration when this equality constraint is going to be satisfied, and again, you don't control when this outcome is going to occur, or in what order.",
            "These nondeterministic shortcuts will be taken."
        ],
        [
            "So.",
            "Our main results then compressed into the single theorem are that if you have an Abacus program, all of whose strongly connected components are either simple loops or simple loops with monotone shortcuts, and if you have a node S that you want to reach in that Abacus program with a certain desired vector of register values, then we can compute a disjunction of linear constraints on the initial register values for reaching these final register values.",
            "OK, so these computed conditions are necessary and sufficient if every simple loop switch shortcuts is order independent.",
            "That is, it doesn't matter in which order you get these nondeterministic outcomes, and otherwise these conditions are only sufficient."
        ],
        [
            "OK, so with this let me describe in brief what we do and how we can use these results.",
            "So here we see a simple loop of actions so this isn't transferred domain.",
            "We first choosing an object that is at location L1.",
            "We then loading it into a truck and moving the truck to L2, unloading the truck and moving the truck back to L1."
        ],
        [
            "So if we look at the set of states possible in situ in reaction here, and if we can express it in an abstract manner, we can see an interesting pattern here with which correlates very closely to what happens in Abacus programs.",
            "So this is what this slide is doing and it has a bunch of information, but all you need to know here is that these things in brackets are unary predicates, so we're saying this is a state, and for this, so you have two kinds of elements, either summary elements, which are collections of.",
            "Or single elements which are just unique elements.",
            "So here we have an object which is at L1 and this is a unique element.",
            "And here we have a set of objects, which is that everyone.",
            "So let's buy a set of objects, I mean.",
            "And which collection which has at least one object.",
            "So if we start with this state where there's a truck at L1.",
            "A certain number of objects at L1 and a certain number of objects at L2, and then we do a choice operation.",
            "We're essentially creating a branching effect to what we did in Abacus programs, except here, the branches being compared with one.",
            "So in this case you had exactly 1 object, so in this case you had exactly 1 object at L1, so you get a Singleton here, and in this case you have an object at L1 that you selected and there's still other objects at L1.",
            "So these things here, the set of properties or unary predicates that element satisfied, is called the role of an element, and if you look at these actions in any unary domain.",
            "Our PDL actions are actually just going to change the number of elements with satisfy a certain role.",
            "So here the load operation is decreasing the number of elements with satisfy the role object at L1 and increasing the set of elements that that with the role object at L1 and in the truck.",
            "So this can be done automatically for all the actions and it turns out that this representation is essentially.",
            "Giving us actions which are changing roll counts in sisters and the branches are with one the constant 1 instead of zero and this can be easily translated into what we saw with Abacus programs.",
            "So this kind of an abstract representation will work for all unary domains and also a class of binary domains, but I don't have time to get into that now."
        ],
        [
            "So here we see certain example in the transport domain.",
            "This is much more complicated example and it's still a simple loop with shortcuts.",
            "So what's happening here is you have a certain number of servers here and a certain number of servers at D2 and you want to move them in pairs and deliver them to D3.",
            "Now the plan that's doing this somehow involves leaving a server at L, and if you do that then the server can get lost.",
            "So instead of going into the details of this plan, the high level picture is that here you have a branch which is taken if the server is lost, and then you have some other branches here.",
            "If the server is heavy and so on, but the net effect is that our preconditions link the number of servers and the number of monitors at D3, and we're getting the fact that they are always going to be equal.",
            "So our plan is going to work in all cases and also we're connecting the number of servers.",
            "Initiative finally at S1 with the number of servers that were initially address one and so here we have S10 minus KISOKI is the set of all loops which delivered the server without the server getting lost and we have here 4 loops which are created by this branch, with the server being lossed.",
            "So the number of servers that are found finally at that are left at S1.",
            "Our initial the servers that we had initially minus those that were delivered and minus those that were lost.",
            "So in this way we can.",
            "We can compactly represent the effect of a complicated loop of actions we can find out its preconditions and we can find out if it's going to terminate or not."
        ],
        [
            "So this is the time taken to compute preconditions in some problem domains and for all of these we generated the plans almost automatically.",
            "By almost I mean we have a method for creating plans, but it's not very good or it's not as good as these methods for finding preconditions.",
            "So it leaves a single iteration of the loop before and after the loop.",
            "So we rolled it back into the loop by hand so that we can compute preconditions for more general classes of plans and computing preconditions is actually very efficient.",
            "So you can use these methods while you're constructing plans to determine if a potential loop of actions is going to be helpful so I can get into these problems more in detail.",
            "If there any questions."
        ],
        [
            "Again.",
            "But with this, I'll conclude what we presented is an approach for computing summarized effects of loops of actions.",
            "And as I mentioned, we can use this during the construction for plans and even during precondition or applicability tests.",
            "And there's lots of scope for future work so.",
            "And all we're doing is treating properties that we're counting as collections of unary predicates.",
            "You can look at more general properties and as long as you can convert an action into something that changes the count of a certain property by a constant, you can start applying these methods.",
            "So we obviously need a further categorization of tractable classes.",
            "Here we know that in General Abacus programs cannot be analyzed, and the problems are decidable, and we know that when we have simple loops, we can do that very efficiently, and even for short cuts, but we don't know where the barrier is.",
            "We don't know beyond what we cannot identify.",
            "Preconditions of plans with loops, as I mentioned, expression of order dependent constraints is another point where we can develop new methods.",
            "And finally we can combine these methods with symbolic precondition evaluation approaches so that even when we have branches that don't correspond with Abacus branches, as in.",
            "Comparing a quantity with a constant, we can use these methods in combination with those methods to fit more general expression framework for preconditions.",
            "So I'll stop here.",
            "Thank you.",
            "Question.",
            "Carmel.",
            "No.",
            "We will.",
            "So.",
            "So it looks like the.",
            "The whole thing can be very useful in.",
            "And systems that use scripts kind of reactive agents that only have is a bunch of scripts.",
            "Now.",
            "What is script?",
            "Script is complex action.",
            "Conditional with loop sometimes depends on the language.",
            "And.",
            "First of all, now you give them verification tool for you know applying or not there.",
            "The question then of course, what happens if two scripts are applicable in the state and so they want to apply?",
            "But it sounds like connecting this.",
            "Technology with the reactive agents.",
            "Yes, promising.",
            "So if I understand you correctly, you're wondering how these different scripts, how we can use these methods to understand what the script is doing in general and compose them or plan using them.",
            "Yeah, you could definitely do something like that.",
            "Right?",
            "Get state license.",
            "Links.",
            "Yeah, yeah, so you can definitely use this to identify what the script would do in general, right?",
            "Any other question?",
            "So I.",
            "Power.",
            "So since you translate I can see.",
            "Since you translate plans to Abacus programs.",
            "I think there are a lot of.",
            "There is a lot of work in code analysis that Princeton for translated into structure programs with wise and so on from good to could this be?",
            "In some sense there is something too specific to branding such that work in code analysis not so actually this can be used and the model that the abstraction framework that I showed here.",
            "This is from technique.",
            "For a static analysis of programs, so it's very relevant there, and although most of the approaches for analyzing programs focus on partial correctness, so they assume that the plan to terminate and if it terminates the proof, certain properties for it.",
            "So this is certainly new even to that framework, but we have a limited class of Abacus program that we analyze, so it remains to be seen how practical these classes are for that setting.",
            "OK, so let's begin with speaker."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Hey, I'm so tired and I'll be talking about computing applicability conditions for plans with loops.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So let's first look at why we want to find plans with boots.",
                    "label": 1
                },
                {
                    "sent": "So here we see a simple example in of a contingent plan where we're going through a set of objects.",
                    "label": 0
                },
                {
                    "sent": "We're incrementally sensing the type of each object and so sorting it in its container.",
                    "label": 0
                },
                {
                    "sent": "So this plan works well, except that it's going to grow exponentially with the number of objects and doing a lot of reputation without really recognizing this.",
                    "label": 0
                },
                {
                    "sent": "So it would be much better if we could find a plan like this which has a cyclic flow of control, and it's essentially repeating the same set of actions over the different objects.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But the problem is in finding such plans we need to determine what these leaps loops are doing in order period to be able to.",
                    "label": 0
                },
                {
                    "sent": "And it's clear that we want them because they are much more small.",
                    "label": 0
                },
                {
                    "sent": "They're much more general, and they also allow us to work with unknown quantities of object.",
                    "label": 1
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In fact, plans with loops provide a great opportunity for planned reuse, so here we are looking at a plan that works in the grid world and it essentially traverses the gridworld, the boundary of the great World by going around it looking for these corners BC&D.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So if we look at action of this plan without caring about these observations, then we can actually utilize this plan to reach any point in the center of the grid that is in the interior of the grid and all we need to do to be able to do this is to study what each loop is doing and figure out the number of iterations required for reaching any point in the interior.",
                    "label": 0
                },
                {
                    "sent": "So clearly if we can analyze plans with loops, we can reuse them and we get some benefit.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But if we don't analyze plans with loops, we can end up in serious problems.",
                    "label": 1
                },
                {
                    "sent": "So here we have with loops which is traversing the grid world.",
                    "label": 0
                },
                {
                    "sent": "It's essentially alternating along the road starting at the bottom left, and the idea is to stop when you reach a certain square which is marked G for the goal.",
                    "label": 0
                },
                {
                    "sent": "So this is going to work fine on any such.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Great, but if we're looking to apply it on different problem instances and if we don't carefully understand when this should be applied, we may end up applying it on a grid like this, which is very similar to the previous grid, but in this case the plan will never read G. In fact, reverse the almost the entire state space before you figure out that it's not really reached the goal.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So the conclusion of all this is we need to analyze loops of actions both during the construction of plants to determine if a potential loop of actions is going to be useful, or if it's going to terminate at all.",
                    "label": 0
                },
                {
                    "sent": "And even during construction, or sorry, even after construction to figure out if a plan with loops is going to be applicable to a certain problem and how we should install it to solve a certain problem instance.",
                    "label": 1
                },
                {
                    "sent": "This brings Up's longstanding issues of plan reuse which have been studied in the context of linear.",
                    "label": 1
                },
                {
                    "sent": "Plans and in terms of linear sub sequences of actions.",
                    "label": 0
                },
                {
                    "sent": "But when we introduce loops all of these problems become much more complicated.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So the state of the art in finding such plans with loops is to observe working plans and then go ahead and extract some repeating patterns of actions or sub sequences, and then you can put these two where and if you do this, the loop utility is mostly being justified by prior experience.",
                    "label": 1
                },
                {
                    "sent": "So we're projecting from what we saw worked earlier when we want to execute plans.",
                    "label": 1
                },
                {
                    "sent": "The approach typically is to apply it on any given problem instance or in other words, simulate the plan and if it reaches the goal, that's good.",
                    "label": 0
                },
                {
                    "sent": "But if not, we can spawn off a classical planning process or use some other process at that stage.",
                    "label": 0
                },
                {
                    "sent": "But as I mentioned before, applying plans in this, we can be very wasteful and you might end up traversing space if you have plans with loops as an exception, I should note that lyrics approach does provide a partial precondition test where you can if you have problem instances, that way over a single planning parimeter you can go ahead and check if your plan is actually going to solve this problem, But in general in both plan generation and plan execution.",
                    "label": 0
                },
                {
                    "sent": "The fundamental problems are that we don't know how to figure out if a plan with loops is going to terminate and how to figure out when a certain goal node is going to be reachable through a plan with loops.",
                    "label": 0
                },
                {
                    "sent": "So my talk will focus on these problems and we'll try to study when we can identify or solve these problems accurately, and what the boundaries of.",
                    "label": 0
                },
                {
                    "sent": "Decidability in.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Ask Acer.",
                    "label": 0
                },
                {
                    "sent": "OK, so this is an overview of the talk.",
                    "label": 0
                },
                {
                    "sent": "I'll first define Abacus programs, which are simple and elegant framework for computation, and I'll study different classes of Abacus programs based on their graph structure.",
                    "label": 0
                },
                {
                    "sent": "Find preconditions or develop algorithms for finding preconditions efficiently in each of these classes.",
                    "label": 0
                },
                {
                    "sent": "We'll then see how an approach for finding plans with loops that we've been working on for a few years can be seen as an approach for translating plans into Abacus programs, so we can go ahead and apply these algorithms on these plans even during construction.",
                    "label": 1
                },
                {
                    "sent": "And finally, I'll look at some empirical results showing how difficult or easy it is to compute these preconditions.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, so Abacus programs of a finite set of registers, finite set of States and specific initial state and a specific whole state.",
                    "label": 1
                },
                {
                    "sent": "Their actions are very simple, so you can either have incrementing actions like.",
                    "label": 0
                },
                {
                    "sent": "Like R2 plus plus here we just bumps up the register value of register by 1.",
                    "label": 0
                },
                {
                    "sent": "You can have conditional decrement actions which look at a register and compare it with zero.",
                    "label": 0
                },
                {
                    "sent": "So if the register is greater than zero, we decrement that register by 1 to a different state, or if it's equal to zero, we just moved to a different state without changing any action without changing any register.",
                    "label": 0
                },
                {
                    "sent": "So even with this simple formulation, the Abacus Program's former Turing complete framework of computation, so the first bad news is that we cannot in general find preconditions for reaching a desired goal node with the desired set of registers in Abacus programs.",
                    "label": 0
                },
                {
                    "sent": "But in the next few slides we will see that this can be done for certain classes of Abacus programs.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So let's say we have a linear sequence of actions, and our objective here is to find a set of conditions for reaching a desired set of register values at S4, and we want these conditions to be in terms of register values at S, one that's the initial state for this segment.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So the first step is to compute the value of register vector at every state, and if we can assume that all the required branches in this path are going to be taken, this is quite easy to do.",
                    "label": 0
                },
                {
                    "sent": "So let's say our bar is the vector of register values in an.",
                    "label": 0
                },
                {
                    "sent": "Let's say that we are representing changes due to each action as Delta, superscript that action.",
                    "label": 0
                },
                {
                    "sent": "So to compute the value of the register vector at S2, we simply add the initial register vector with the change vector.",
                    "label": 0
                },
                {
                    "sent": "Due to action one, and so on.",
                    "label": 0
                },
                {
                    "sent": "And we can compute.",
                    "label": 0
                },
                {
                    "sent": "The final values of register vectors at S4, assuming that all the right branches are going to be taken.",
                    "label": 0
                },
                {
                    "sent": "So that's the first part.",
                    "label": 0
                },
                {
                    "sent": "Now we need to figure out the conditions on our bar under which will take all the right brand.",
                    "label": 0
                },
                {
                    "sent": "So in order to do this, we remember that whenever we have a decrementing action like this, all we need to do is check the value of the register that it's changing before that action is applied.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So here we found that value.",
                    "label": 0
                },
                {
                    "sent": "It's our bar and we projected it on the dimension that action even was changing and set it to be greater than 0.",
                    "label": 0
                },
                {
                    "sent": "Because that's the condition we need so we can go ahead and do the same thing for this.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And here and if we compose these conditions then we can find necessary and sufficient funds for reaching a desired set of register vectors.",
                    "label": 1
                },
                {
                    "sent": "Register values.",
                    "label": 0
                },
                {
                    "sent": "At a final note, starting with a given initial value.",
                    "label": 0
                },
                {
                    "sent": "So here we have our bar as the initial and Fr is the final.",
                    "label": 0
                },
                {
                    "sent": "OK, so we can deal with linear sequences of Abacus actions relatively easy.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So let's look at what happens if we put these actions in a loop.",
                    "label": 0
                },
                {
                    "sent": "Now we have a simple loop here, by which I just mean a cycle in a graph, and our objective is to compute necessary and sufficient conditions under which we can.",
                    "label": 0
                },
                {
                    "sent": "A certain desired value of register vectors at S1, starting with this one and after doing L iterations of this loop.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So let's say we have loop inequality and in this by the loop inequality I'm just going to refer to the set of inequalities that we developed before, so the overall intuition is to treat each iteration of this loop as a single linear sequence of actions and we just want to repeat that sequence of actions L times.",
                    "label": 0
                },
                {
                    "sent": "OK, so loop inequality is basically telling us that for zero starting with our bar zero, we can execute one complete iteration of this loop.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now let's say our bar X represents the value of these registers after X iterations, which which is easy to compute because we just add up the change due to each iteration.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And then we can write down the inequality is required for L complete iterations.",
                    "label": 1
                },
                {
                    "sent": "We basically saying that we want loop inequality to hold at Arbor Zero.",
                    "label": 0
                },
                {
                    "sent": "That's the initial value of register vectors.",
                    "label": 0
                },
                {
                    "sent": "We wanted to hold again after the first iteration and then so on.",
                    "label": 0
                },
                {
                    "sent": "After L minus questions.",
                    "label": 0
                },
                {
                    "sent": "So that's the complete set of conditions required to execute L independent iterations of this loop.",
                    "label": 0
                },
                {
                    "sent": "Now, because these expressions for Arbor X are linear in terms of X, all of these inequalities are actually subsumed by just the first one and the last one, so that gives us the set of inequalities required to stay in the loop for L.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Iterations.",
                    "label": 0
                },
                {
                    "sent": "And then we can go ahead and compute the final values of register vectors equally easily by just adding up the change due to each iteration of the loop.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So this means that in Abacus programs with simple loops or in a simple loop of Abacus actions, we can find necessary and sufficient conditions for executing L complete iterations of the loop and reaching a final desired set of register back vectors values.",
                    "label": 1
                },
                {
                    "sent": "OK, so here we are treating F bar as the desired sector of register values and our buyer zero as the initial register vector.",
                    "label": 0
                },
                {
                    "sent": "But we can treat Arbor Zero as tired register vector for proceeding segment of an Abacus program.",
                    "label": 0
                },
                {
                    "sent": "So in this way we can combine these conditions with conditions for computing.",
                    "label": 0
                },
                {
                    "sent": "For reaching this register vector are barred zero itself and in this way we can find the preconditions for any Abacus program that has only simple loops.",
                    "label": 0
                },
                {
                    "sent": "We may need to use disjunctions if we have a state that has multiple edges that lead.",
                    "label": 0
                },
                {
                    "sent": "It leads to the goal or a desired vectors.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, so recall that our approach was going to be to translate plans with loops into Abacus programs or view plans with loops, Abacus programs, while preserving structure.",
                    "label": 1
                },
                {
                    "sent": "Because structure is going to be very important in the algorithms that we've developed.",
                    "label": 1
                },
                {
                    "sent": "And then we want to find algorithms for computing preconditions of classes of Abacus programs.",
                    "label": 0
                },
                {
                    "sent": "Now, in order to do this efficiently, we need to somehow translate sensing actions as Abacus actions.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And to do this we add a non deterministic set action action can either set a register to zero and go to a certain state or set it to one and go to a different state.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We don't need this action to actually increase the power of Abacus programs, because they are already doing complete, but this action is going to help us to translate or view plans as Abacus program.",
                    "label": 1
                },
                {
                    "sent": "So in the recycling problem, for instance, we will replace the sense type action with a non deterministic set action.",
                    "label": 0
                },
                {
                    "sent": "And we'll replace all of the options with their own counterparts without changing the loop structure.",
                    "label": 0
                },
                {
                    "sent": "And when we want to find preconditions will compute these conditions in terms of the number of times each branch is taken.",
                    "label": 1
                },
                {
                    "sent": "So in this problem, we'd say something like the number of times you see the paper objects that should be less than or equal to the capacity of the paper container that you have.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so with these nondeterministic actions, we can look at a broader class of loops.",
                    "label": 0
                },
                {
                    "sent": "So let's say we have a simple loop again.",
                    "label": 0
                },
                {
                    "sent": "Now we have a green node that that's supposed to be a start node, so this is any node you can choose any node in the loop to be a start node, and then all these nondeterministic actions create branches that go ahead and join a later node in the loop.",
                    "label": 0
                },
                {
                    "sent": "So by later, I mean later, as in starting from the start now.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So it seems like this is a restricted frame.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But actually, many so-called commonly understood nested loops can be translated into simple loops with shortcuts.",
                    "label": 1
                },
                {
                    "sent": "By translating the start node.",
                    "label": 0
                },
                {
                    "sent": "So this is a flexible framework as far as the graph topology is concerned.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So let's say we have a simple loop with shortcut.",
                    "label": 0
                },
                {
                    "sent": "Now the benefit in viewing it in this way or restricting these are study to these kind of loops is that we can look at every possible iteration around this start node, and in this case what we've done is we've considered all possible ways of completing the loop by taking all possible results of these nondeterministic actions.",
                    "label": 0
                },
                {
                    "sent": "So basically, we're seeing what happens if we take a one and this branch of a two, and so on.",
                    "label": 0
                },
                {
                    "sent": "So essentially we're decomposing a simple loop with shortcuts into different simple loops.",
                    "label": 1
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So before we move on to some algorithms, let's define monotone shortcuts and hear what he is trying to say is that.",
                    "label": 0
                },
                {
                    "sent": "Let's say you have a simple loop with shortcuts.",
                    "label": 0
                },
                {
                    "sent": "The shortcuts are monotone if the net change on a register due to every simple aided by the shortcuts is in the same direction.",
                    "label": 1
                },
                {
                    "sent": "So you have one set of registers are plus which are changed always positively, and one set of registers are minus, which are always changed negatively, so these changes are net negative changes on net positive changes.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, so let's say we have a simple loop with shortcuts and we've decomposed it into M simple loops and we somehow for some reason we want to figure out what are the necessary and sufficient conditions for executing K1 through KM of each of these loops.",
                    "label": 1
                },
                {
                    "sent": "So again, the final values of register vectors in terms of the initial values is relatively easy to compute.",
                    "label": 0
                },
                {
                    "sent": "We just add the change due to each loop.",
                    "label": 0
                },
                {
                    "sent": "Now to ensure that Ki iterations of loop I.",
                    "label": 1
                },
                {
                    "sent": "Must be executed.",
                    "label": 1
                },
                {
                    "sent": "We need to make sure that no register falls below 0 in these K iterations, and for that we need to identify the least intermediate value of every register and then set that to be greater than or equal to zero.",
                    "label": 0
                },
                {
                    "sent": "That will give us a set set of sufficient conditions for executing K iterations of loop.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so this can be done in a relatively straightforward manner.",
                    "label": 0
                },
                {
                    "sent": "Let's again, so we have two sets of registers, the R Plus registers, an R minus registers, and we're calling J hat to be the index of the loop, which causes the greatest initial negative change on a certain resistor.",
                    "label": 0
                },
                {
                    "sent": "So even a positive register might undergo an initial change before it gets incremented again.",
                    "label": 0
                },
                {
                    "sent": "So four registers belonging to our plus the least value is just the initial value plus the change due to this loop J hat.",
                    "label": 0
                },
                {
                    "sent": "Because after this change the these registers are only going to increase.",
                    "label": 0
                },
                {
                    "sent": "So the first part of these inequalities is just setting these registers to be above 0.",
                    "label": 0
                },
                {
                    "sent": "OK, and for registers belonging to R minus what we do is take the loop that creates the greatest initial negative change and put its iteration at the end after executing every other loop so that we get the largest decrement in this registers vector value.",
                    "label": 0
                },
                {
                    "sent": "So these set of conditions for all the registers give us a set of sufficient conditions, but I haven't talked about what happens if we have equality constraints for staying in the loop, and I haven't said what to do if the loop J hat is not executed at all.",
                    "label": 0
                },
                {
                    "sent": "So in the paper we discuss these constraints and we can extend these conditions to deal with those situations.",
                    "label": 0
                },
                {
                    "sent": "This is the basic idea and I'll go back to this point after a small example.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So let's say we have this method for computing our constraints on minimum register values.",
                    "label": 1
                },
                {
                    "sent": "And let's say we have a simple loop with shortcuts which we've decomposed into two loops.",
                    "label": 1
                },
                {
                    "sent": "So Loop 1 first increases register by one, sorry by three and Loop 2 first decreases it by two and then increases it by 5.",
                    "label": 0
                },
                {
                    "sent": "So we're still in the monotone shortcut setting, but.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "If we go and apply our method then we get the constraint which says that the initial value of register R1 should be at least two and this is a sufficient condition for executing loop one and loop 21 iteration of each loop.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "But if we look at the true necessary and sufficient conditions, then they actually depend on the order in which we execute these two loops.",
                    "label": 0
                },
                {
                    "sent": "We could execute Loop 1 first and then we won't.",
                    "label": 0
                },
                {
                    "sent": "We don't need any such condition, but in an adversarial setting, if you don't control the nondeterministic outcomes which which is going to be the case, in practice, these conditions that we computer actually the true conditions that you need.",
                    "label": 0
                },
                {
                    "sent": "But in theory, computing accurate conditions is order dependent, and that itself expressing these constraints itself is a big problem.",
                    "label": 0
                },
                {
                    "sent": "So in our results, we're going to restrict ourselves in some sense to order independent.",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Suck it so.",
                    "label": 0
                },
                {
                    "sent": "Let me now come back to the equality constraints and essentially whenever you have an equality constraint for staying in the loop.",
                    "label": 1
                },
                {
                    "sent": "This introduces a very strong kind of order dependence.",
                    "label": 0
                },
                {
                    "sent": "In such case, want to be able to say that this particular outcome of a two will occur exactly in the iteration when this equality constraint is going to be satisfied, and again, you don't control when this outcome is going to occur, or in what order.",
                    "label": 0
                },
                {
                    "sent": "These nondeterministic shortcuts will be taken.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "Our main results then compressed into the single theorem are that if you have an Abacus program, all of whose strongly connected components are either simple loops or simple loops with monotone shortcuts, and if you have a node S that you want to reach in that Abacus program with a certain desired vector of register values, then we can compute a disjunction of linear constraints on the initial register values for reaching these final register values.",
                    "label": 1
                },
                {
                    "sent": "OK, so these computed conditions are necessary and sufficient if every simple loop switch shortcuts is order independent.",
                    "label": 0
                },
                {
                    "sent": "That is, it doesn't matter in which order you get these nondeterministic outcomes, and otherwise these conditions are only sufficient.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so with this let me describe in brief what we do and how we can use these results.",
                    "label": 0
                },
                {
                    "sent": "So here we see a simple loop of actions so this isn't transferred domain.",
                    "label": 0
                },
                {
                    "sent": "We first choosing an object that is at location L1.",
                    "label": 0
                },
                {
                    "sent": "We then loading it into a truck and moving the truck to L2, unloading the truck and moving the truck back to L1.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So if we look at the set of states possible in situ in reaction here, and if we can express it in an abstract manner, we can see an interesting pattern here with which correlates very closely to what happens in Abacus programs.",
                    "label": 0
                },
                {
                    "sent": "So this is what this slide is doing and it has a bunch of information, but all you need to know here is that these things in brackets are unary predicates, so we're saying this is a state, and for this, so you have two kinds of elements, either summary elements, which are collections of.",
                    "label": 0
                },
                {
                    "sent": "Or single elements which are just unique elements.",
                    "label": 0
                },
                {
                    "sent": "So here we have an object which is at L1 and this is a unique element.",
                    "label": 0
                },
                {
                    "sent": "And here we have a set of objects, which is that everyone.",
                    "label": 0
                },
                {
                    "sent": "So let's buy a set of objects, I mean.",
                    "label": 0
                },
                {
                    "sent": "And which collection which has at least one object.",
                    "label": 0
                },
                {
                    "sent": "So if we start with this state where there's a truck at L1.",
                    "label": 0
                },
                {
                    "sent": "A certain number of objects at L1 and a certain number of objects at L2, and then we do a choice operation.",
                    "label": 0
                },
                {
                    "sent": "We're essentially creating a branching effect to what we did in Abacus programs, except here, the branches being compared with one.",
                    "label": 1
                },
                {
                    "sent": "So in this case you had exactly 1 object, so in this case you had exactly 1 object at L1, so you get a Singleton here, and in this case you have an object at L1 that you selected and there's still other objects at L1.",
                    "label": 0
                },
                {
                    "sent": "So these things here, the set of properties or unary predicates that element satisfied, is called the role of an element, and if you look at these actions in any unary domain.",
                    "label": 0
                },
                {
                    "sent": "Our PDL actions are actually just going to change the number of elements with satisfy a certain role.",
                    "label": 0
                },
                {
                    "sent": "So here the load operation is decreasing the number of elements with satisfy the role object at L1 and increasing the set of elements that that with the role object at L1 and in the truck.",
                    "label": 0
                },
                {
                    "sent": "So this can be done automatically for all the actions and it turns out that this representation is essentially.",
                    "label": 0
                },
                {
                    "sent": "Giving us actions which are changing roll counts in sisters and the branches are with one the constant 1 instead of zero and this can be easily translated into what we saw with Abacus programs.",
                    "label": 0
                },
                {
                    "sent": "So this kind of an abstract representation will work for all unary domains and also a class of binary domains, but I don't have time to get into that now.",
                    "label": 1
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So here we see certain example in the transport domain.",
                    "label": 0
                },
                {
                    "sent": "This is much more complicated example and it's still a simple loop with shortcuts.",
                    "label": 0
                },
                {
                    "sent": "So what's happening here is you have a certain number of servers here and a certain number of servers at D2 and you want to move them in pairs and deliver them to D3.",
                    "label": 0
                },
                {
                    "sent": "Now the plan that's doing this somehow involves leaving a server at L, and if you do that then the server can get lost.",
                    "label": 0
                },
                {
                    "sent": "So instead of going into the details of this plan, the high level picture is that here you have a branch which is taken if the server is lost, and then you have some other branches here.",
                    "label": 0
                },
                {
                    "sent": "If the server is heavy and so on, but the net effect is that our preconditions link the number of servers and the number of monitors at D3, and we're getting the fact that they are always going to be equal.",
                    "label": 0
                },
                {
                    "sent": "So our plan is going to work in all cases and also we're connecting the number of servers.",
                    "label": 0
                },
                {
                    "sent": "Initiative finally at S1 with the number of servers that were initially address one and so here we have S10 minus KISOKI is the set of all loops which delivered the server without the server getting lost and we have here 4 loops which are created by this branch, with the server being lossed.",
                    "label": 0
                },
                {
                    "sent": "So the number of servers that are found finally at that are left at S1.",
                    "label": 0
                },
                {
                    "sent": "Our initial the servers that we had initially minus those that were delivered and minus those that were lost.",
                    "label": 0
                },
                {
                    "sent": "So in this way we can.",
                    "label": 0
                },
                {
                    "sent": "We can compactly represent the effect of a complicated loop of actions we can find out its preconditions and we can find out if it's going to terminate or not.",
                    "label": 0
                }
            ]
        },
        "clip_39": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So this is the time taken to compute preconditions in some problem domains and for all of these we generated the plans almost automatically.",
                    "label": 1
                },
                {
                    "sent": "By almost I mean we have a method for creating plans, but it's not very good or it's not as good as these methods for finding preconditions.",
                    "label": 0
                },
                {
                    "sent": "So it leaves a single iteration of the loop before and after the loop.",
                    "label": 0
                },
                {
                    "sent": "So we rolled it back into the loop by hand so that we can compute preconditions for more general classes of plans and computing preconditions is actually very efficient.",
                    "label": 0
                },
                {
                    "sent": "So you can use these methods while you're constructing plans to determine if a potential loop of actions is going to be helpful so I can get into these problems more in detail.",
                    "label": 0
                },
                {
                    "sent": "If there any questions.",
                    "label": 0
                }
            ]
        },
        "clip_40": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Again.",
                    "label": 0
                },
                {
                    "sent": "But with this, I'll conclude what we presented is an approach for computing summarized effects of loops of actions.",
                    "label": 1
                },
                {
                    "sent": "And as I mentioned, we can use this during the construction for plans and even during precondition or applicability tests.",
                    "label": 0
                },
                {
                    "sent": "And there's lots of scope for future work so.",
                    "label": 0
                },
                {
                    "sent": "And all we're doing is treating properties that we're counting as collections of unary predicates.",
                    "label": 0
                },
                {
                    "sent": "You can look at more general properties and as long as you can convert an action into something that changes the count of a certain property by a constant, you can start applying these methods.",
                    "label": 1
                },
                {
                    "sent": "So we obviously need a further categorization of tractable classes.",
                    "label": 0
                },
                {
                    "sent": "Here we know that in General Abacus programs cannot be analyzed, and the problems are decidable, and we know that when we have simple loops, we can do that very efficiently, and even for short cuts, but we don't know where the barrier is.",
                    "label": 0
                },
                {
                    "sent": "We don't know beyond what we cannot identify.",
                    "label": 1
                },
                {
                    "sent": "Preconditions of plans with loops, as I mentioned, expression of order dependent constraints is another point where we can develop new methods.",
                    "label": 0
                },
                {
                    "sent": "And finally we can combine these methods with symbolic precondition evaluation approaches so that even when we have branches that don't correspond with Abacus branches, as in.",
                    "label": 0
                },
                {
                    "sent": "Comparing a quantity with a constant, we can use these methods in combination with those methods to fit more general expression framework for preconditions.",
                    "label": 0
                },
                {
                    "sent": "So I'll stop here.",
                    "label": 0
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "Question.",
                    "label": 0
                },
                {
                    "sent": "Carmel.",
                    "label": 0
                },
                {
                    "sent": "No.",
                    "label": 0
                },
                {
                    "sent": "We will.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "So it looks like the.",
                    "label": 0
                },
                {
                    "sent": "The whole thing can be very useful in.",
                    "label": 0
                },
                {
                    "sent": "And systems that use scripts kind of reactive agents that only have is a bunch of scripts.",
                    "label": 0
                },
                {
                    "sent": "Now.",
                    "label": 0
                },
                {
                    "sent": "What is script?",
                    "label": 0
                },
                {
                    "sent": "Script is complex action.",
                    "label": 0
                },
                {
                    "sent": "Conditional with loop sometimes depends on the language.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "First of all, now you give them verification tool for you know applying or not there.",
                    "label": 0
                },
                {
                    "sent": "The question then of course, what happens if two scripts are applicable in the state and so they want to apply?",
                    "label": 0
                },
                {
                    "sent": "But it sounds like connecting this.",
                    "label": 0
                },
                {
                    "sent": "Technology with the reactive agents.",
                    "label": 0
                },
                {
                    "sent": "Yes, promising.",
                    "label": 0
                },
                {
                    "sent": "So if I understand you correctly, you're wondering how these different scripts, how we can use these methods to understand what the script is doing in general and compose them or plan using them.",
                    "label": 0
                },
                {
                    "sent": "Yeah, you could definitely do something like that.",
                    "label": 0
                },
                {
                    "sent": "Right?",
                    "label": 0
                },
                {
                    "sent": "Get state license.",
                    "label": 0
                },
                {
                    "sent": "Links.",
                    "label": 0
                },
                {
                    "sent": "Yeah, yeah, so you can definitely use this to identify what the script would do in general, right?",
                    "label": 0
                },
                {
                    "sent": "Any other question?",
                    "label": 0
                },
                {
                    "sent": "So I.",
                    "label": 1
                },
                {
                    "sent": "Power.",
                    "label": 0
                },
                {
                    "sent": "So since you translate I can see.",
                    "label": 0
                },
                {
                    "sent": "Since you translate plans to Abacus programs.",
                    "label": 0
                },
                {
                    "sent": "I think there are a lot of.",
                    "label": 0
                },
                {
                    "sent": "There is a lot of work in code analysis that Princeton for translated into structure programs with wise and so on from good to could this be?",
                    "label": 0
                },
                {
                    "sent": "In some sense there is something too specific to branding such that work in code analysis not so actually this can be used and the model that the abstraction framework that I showed here.",
                    "label": 0
                },
                {
                    "sent": "This is from technique.",
                    "label": 0
                },
                {
                    "sent": "For a static analysis of programs, so it's very relevant there, and although most of the approaches for analyzing programs focus on partial correctness, so they assume that the plan to terminate and if it terminates the proof, certain properties for it.",
                    "label": 0
                },
                {
                    "sent": "So this is certainly new even to that framework, but we have a limited class of Abacus program that we analyze, so it remains to be seen how practical these classes are for that setting.",
                    "label": 0
                },
                {
                    "sent": "OK, so let's begin with speaker.",
                    "label": 0
                }
            ]
        }
    }
}