{
    "id": "nqncu4arofs64zbmfxakt3zyczqofxez",
    "title": "State-merging DFA induction algorithms with mandatory merge constraints",
    "info": {
        "author": [
            "Pierre Dupont, University of Louvain"
        ],
        "published": "Oct. 9, 2008",
        "recorded": "September 2008",
        "category": [
            "Top->Computer Science->Machine Learning"
        ]
    },
    "url": "http://videolectures.net/icgi08_dupont_smdfa/",
    "segmentation": [
        [
            "Yeah, well presented joint work with both of them are and found out on board on state merchant.",
            "Give a induction algorithms with mandatory merge constraints.",
            "Thank you.",
            "So the initial motivation of this work is more practical and you will see that my talk will have some sort of an algorithmic POV.",
            "But it also some sort of give new insight of existing state merging techniques and maybe some extension we developed and it at the end it also trigger maybe some new theoretical."
        ],
        [
            "Options.",
            "So the practical motivation is.",
            "Either give an application domain that we are interested in.",
            "Actually my two Co authors or specialist of these of these domain which is called requirements engineering and the problem is the following.",
            "It is the problem of the design of a software system before actually building it.",
            "So you want to be able to innocence have a way to formalize what the system should do, and that's considered to be the hardest part in the design.",
            "Once you have that, you can check that your specification is right and then even.",
            "Do some code generation automatically.",
            "Actually one can automate part of this process by learning behave what is called in this domain behavior model from scenarios, and as you will see this is nothing but set of the problem of learning a language from a set of strings, so it's nicely come down to something we know about.",
            "And more of the kind of language they are after are nicely represented by finite state machine, so."
        ],
        [
            "That seems to be an interesting setting.",
            "So what is a scenario?",
            "So we have here or case study example where we have a train system and you have different agent or actors in this train system.",
            "So here the controller, a sensor, Anna passenger and there are events that can happen.",
            "Something like the string start.",
            "I should have another point.",
            "The train start here.",
            "Then some passenger press the alarm and the alarm is propagated from the sensor to the controller and then he has to stop in emergency and then open the doors.",
            "So that's a positive scenario.",
            "Everything this sequence of events correspond to some correct behavior of the system, and here's an incorrect behavior.",
            "If you start to train and suddenly you open the doors, you won't satisfy kind of a safety goal, so it's negative scenario.",
            "The good thing is that these scenarios can actually be provided by some end users.",
            "Somebody asking you to design a system, and so you say, OK, what is your system supposed to do?",
            "And it's very hard for an end user to come up with a formal specification.",
            "Even finite state machine, but she can provide usually some typical sequence of events that corresponds to correct or incorrect behavior."
        ],
        [
            "So it's a win win situation for people.",
            "Interesting grammatical inference, any particular DFA induction, because in this domain regular language are considered to be certainly powerful enough, so we don't have to try to tackle harder class innocence.",
            "And it's more than that.",
            "The DFA is D representation that people use for different reason and the two main one probably is that once you have a description of your system in a finite state model, and.",
            "Especially DFA.",
            "Then you can do model checking in code generation.",
            "The typical size of such machine is.",
            "Between 20 and 100 states, which is which is?",
            "Hard enough to make it kind of impossible to design by hand, but not too big so that or existing algorithm can actually tackle this problem, and the typical state of the art algorithm, RPI and blue fringe, also known as red, blue and tend to use a blue fridge name, but it's the same so and also the typical alphabet size is say an order of magnitude higher than the OR classical two or three letter alphabet, but it's still reasonable so.",
            "And it's even better than that.",
            "Once you when you have an end user, you actually have an Oracle, because you can.",
            "You can ask her additional scenarios, suggested scenarios and see whether it's considered to be positive or negative.",
            "So members."
        ],
        [
            "Degrees in special essentially.",
            "So this is actually a summary of a previous work on this topic, and we designed a so called QSM algorithm which is an extension to the classical RP and I and blue fringe with membership queries an the idea of using queries.",
            "Here we're not to actually be able to learn something different because we have negative and positive scenario, so it should be enough, but to reduce the amount of initial scenario the end user has to provide and two.",
            "Ask her additional data to be provided incrementally so we are in an online online learning setting here and that's that's a screen capture of the actual interface we have, so we provide a new scenario which is not in the initial collection.",
            "Something like starting this train, stopping this train, and then starting again, and there is a question mark here because we know that up to there is still a positive behavior and we want to know if we add an extra event, whether it's still OK.",
            "This case, the answer is yes, and in another case the answer would be no.",
            "Testing thing is that we use the characterizations of the RPI algorithm that is the Arctic set to design these questions to see which one we have to ask.",
            "And also in the interface there is the change button here.",
            "So we have a certain amount of possible correction queries in a sense, and I don't have the time to discuss that here, but it's an interesting setting as well.",
            "So that's actually our previous work on the top."
        ],
        [
            "Anne.",
            "Now we actually have another type of information.",
            "So far we have been trying to say we are asking the end user only scenarios.",
            "You know, that's that's the kind of the language we talked to the end user.",
            "But more realistically they are cases where we have an extra information, and that's formalized here in the middle.",
            "So you find 4 scenarios here.",
            "But here in the middle you have something which is called in their language.",
            "High level message sequence chart, and what that is is just a flowcharting.",
            "Of the different scenarios and in a sense, if you are in a natural state, your training safe and stop and then you have the Start Stop action.",
            "So here the start of scenario then essentially you go back to the initial situation.",
            "It means that globally you are in the same state and that's the kind of information we can also ask an end user.",
            "Same thing if you open the door and then close them back.",
            "Well it's in the same state, so we actually have an additional information that we can make."
        ],
        [
            "Use of and that's what trigger the the idea of having these mandatory merge constraints.",
            "So we will start from the classical PTA and so that's by the way the representation of those four scenarios here in terms of a sequence of events represented by your PTA.",
            "So that's a practical since everybody know here.",
            "But since we have this information of the general flow charting of the scenario, we will be able to add an extra information which is a label on these states saying that.",
            "Actually, the state and the state.",
            "These treaties should be the same one eventually, so they should correspond to the same state in the global system."
        ],
        [
            "OK, so.",
            "That's the very short summary now of existing technique, so essentially DFA elections hardware is the PTA, and then you look for caution automaten, which is nothing but finding a partition of the state set and so for instance in this case the partition the initial partition correspond to the PTA and then you have a block with the state two and four and three and six."
        ],
        [
            "And that's the classical code.",
            "So you start from the PTA.",
            "Sorry, you start from the PTA which is built from the positive sample.",
            "And also we will see why the negative sample we start with the trivial partition and then we choose a state prior to merger two blocks in the partition and the different algorithm RP and I.",
            "An blue fringe differ in the.",
            "Search order here.",
            "Apart from that there is the merge operation and we check whether the resulting automaton is still compatible with the negative sample that it doesn't accept any negative."
        ],
        [
            "The merge operation actually has an additional property, as you know when you start from merging state three and two on the top here.",
            "You can end up with a non deterministic machine and since we are after a DFA there is this recursive process of merging states in order to find a DFA at the end OK."
        ],
        [
            "So.",
            "And know something we discover in this work or we re discover in the sense that in those algorithms RPI on blue fringe you and that's the blue fringe setting here represented, you always have the guarantee that we call the tree invariant property.",
            "In a sense, you always consider the merging between two states such that at least one of them is the root of a tree.",
            "So for instance, we will consider here the possible merge between state three and State 2 Ann.",
            "Actually, state three is by construction.",
            "The root of a tree, which is also the case of State 2, but it wouldn't be the case if you consider three and zero, for instance.",
            "And that actually is true for and that's a consequence of the merge order, and that is used by those algorithm.",
            "And actually it's simplified.",
            "It simplified the actual implementation in particular."
        ],
        [
            "When you have these recursive merging and so the invariant is also true for all these merging, so if I consider 9, seven and two 7 and 2, seven is also the root of the tree of a subtree here, and it means that it looks like the natural stopping criterion of this recursion.",
            "We will see that we can actually have this stopping property without having this tree invariants in a minute, but that's the usual way of looking at these things.",
            "So the fact that we have a tree kind of natural stuff."
        ],
        [
            "Incursion."
        ],
        [
            "OK, and so these are classical incompatibility constraints, so that's not new.",
            "That's one way of encoding the negative information.",
            "So instead of building the prefix tree only with the positive example, you also augment it with a negative example, and then you color your States and the great State correspond to positively accepting Satan.",
            "The black state here to the negative accepting state, and so when you do that, the merge operation not only.",
            "Reduce nondeterminism, but also check weather.",
            "In this process you end up merging.",
            "Agree in a black state which is a sign of incompatibility, so there is no additional check for incompatibilities.",
            "The merge operation, which performance at the mean time.",
            "So these constraints are usually called coloring constraints and the feature is that state having different color colors may not be merged while still having the same color can be merged and the actual.",
            "The actual result depends on the execution of the algorithm.",
            "This is not new, this was mentioned already by custom codes or.",
            "In all four, and even before and we.",
            "We propose some ways of using domain knowledge, not necessarily negative information, but other domain knowledge to color you stays in the particular case of requirements engineering.",
            "In our previous work."
        ],
        [
            "And now I'm coming back to the mandatory merge constraints.",
            "So now I want to not only have these incompatibly constraints, but mandatory merge, and we encode them with labels.",
            "So you have the X label on the three States and so there are.",
            "These are the logical counterpart to the coloring constraint in the sense that the states that have the same label must be merged and sit with different labels can be merged.",
            "So that's exactly opponent opposite situation.",
            "Something which is important to realize is that even a fully labeled if you have full information, that is, you have a fully labeled PTA.",
            "Your problem does not reduce to a trivial problem, and because if you don't have any additional information, say for instance no negative information, what's going to happen with that?",
            "Allstate will eventually be merged together, so it's good to have this additional information, as you will see in the experiment.",
            "But even if you have a full information of labeling, information does not come up too.",
            "Reduced to a travel prop."
        ],
        [
            "OK, so here is the EM algorithm.",
            "So statement state merging with mandatory merge constraint and we play a bit with with how to?",
            "Use this constraint and we can discuss that afterwards if you like.",
            "But actually the simplest and the right way to use these constraints just start merging them from the beginning so it's actually trivial extension to existing algorithms.",
            "You start from your building, your augmented PTA, and then you have an additional block here where you impose that state having the same labels are merged together.",
            "And of course you also propagate this merging.",
            "Using the classical merge function so you reduce the nondeterminism and then you start from there and that's the the classical merge loop.",
            "Now you might end up in cases where you're labeling constraints that your color and constraints are kind of inconsistent.",
            "On one hand, you say you have to merge them, and on the other side you say you cannot merge them and it's going to be discovered by the Merge function, and that's why you have these exception mechanism to raise the problem."
        ],
        [
            "OK, so as I said, when you look at it from an algorithmic point of view, it's really a trivial extension to existing techniques.",
            "Although it was motivated by a real practical setting, however.",
            "The first, I mean, the first time we tried that it didn't work and an becausw or implementation was assuming the tree invariant property."
        ],
        [
            "And actually when we start with these labeling constraints, since you merge state from the very beginning, you destroy it completely.",
            "The graph the tree structure of your initial machine.",
            "So it means that in general you can have.",
            "You can start the actual merging part of your algorithm from a general graph and no longer a subtree.",
            "Anne.",
            "It doesn't matter actually, because we can implement it easily.",
            "You have to probably review your implementation, but it's completely feasible to implement this recursive merge merging on a general graph structure.",
            "So here's an example.",
            "You start from a graph and assume that this is the initial situation where after applying your labeling constraint, you have this graph, and then you decide to merge state three and zero.",
            "And if you do that, you will have a nondeterminism on letter B here, and so by recursion you have to merge the two successor two and four.",
            "And you end up here and actually naturally the recursion stuff and the recursion stuff.",
            "Not because this is a tree, but because there is no additional non determine is created by the successor of the States.",
            "You just merge.",
            "And that's another condition for a natural ending of this process.",
            "So of course if you want to implement that, you have to review your implementation.",
            "But it's you don't actually need the tree invariant property."
        ],
        [
            "No.",
            "Here, here are some experiments, so this is the classical setting like in the Eagle competition.",
            "So we have here the learning sample size for increasing learning sample size an you have the accuracy.",
            "Along the other axis, and here the first curve for two different target size, but the conclusion are the same.",
            "Here the first correspond to the RP and I algorithm.",
            "The second one correspond to the blue fridge.",
            "So you change the search order and you shift a bit the conversions that the improvement provided by the blue fridge.",
            "And here we have all algorithms with different percentage of labeling.",
            "So this means that you have 5% of states having their labeled 10% when he 100%.",
            "You know current implementation, the search order of MSM correspond to RP and eyes, so it means that MSM with zero percent is equivalent to RPI.",
            "So what we see here is that with 5% it's kind of equivalent to the game we can have with blue fringe going from RPI to blue fringe.",
            "And of course if you increase the labeling rate well, you improve the conversions in the sense that you have a better accuracy with fewer.",
            "Example.",
            "But also what I was telling you before, even with 100% labeling, that is the top curve.",
            "It does not reduce to a trivial problem if you have very few sample even with 100 person able you can you end up with not a perfect solution, and that's what that's because you overgeneralized innocence your sample."
        ],
        [
            "OK, so here it is, or classical case to the which is part of the system describing the train controller an it's it's.",
            "It's the same conclusion.",
            "So here we start from.",
            "We compare RPI and blue fridge and the EM algorithm with different labeling, number of states label and as you see the accuracy with 00 state label is the same RPI, the same search order an.",
            "As you increase the number of state labeled well, you improve the accuracy."
        ],
        [
            "OK, no it is.",
            "It is worth looking at.",
            "The actual algorithm can the very same algorithm can be seen a bit differently an."
        ],
        [
            "If I come back here.",
            "If you think about it, so there is this first part down to here.",
            "So you start from a positive sample, but then using these additional constraints you will actually start emerging.",
            "The real classical merging loop with a general graph.",
            "So it means that and it's and by construction it's a DFA.",
            "It means that actually your input of this part of the algorithm can be seen as a DFA or positive DFA augmented with.",
            "Negative sample.",
            "It's there is something else.",
            "You also have the search order here will be related to the definition of the partition, which is which is initially here and then updated here.",
            "So when you see that.",
            "Actually."
        ],
        [
            "You can rephrase the same algorithm.",
            "I think, well, I don't need to start from a positive sample and a set of labeling constraint.",
            "I can start from a positive DFA, so another input of my algorithm is a positive DFA Anna negative sample.",
            "And So what you do is you start by augmenting your positive DFA wizard negative sample in exactly similar fashion as you do with the PTA, and then of course you have to find the order you have to label your state.",
            "But there is a natural order.",
            "You just compute the shortest prefix to each state and you label your states accordingly.",
            "And once you've done well, you start generalizing as usual by merging.",
            "Of course, implicitly, it means that you have.",
            "Extended your merging operation with the ability to deal with general graph structure during the recursion of the merging.",
            "Once you see that.",
            "We say oh, that's kind of cool.",
            "Actually, we haven't seen that at the beginning.",
            "We can.",
            "We can generalize the the.",
            "We can generalize the induction problem and say OK, Now we start from positive DFA and negative sample well."
        ],
        [
            "We can even do better.",
            "We can start from a positive definite negative sample and a negative DFA so you have two DFA's such that their language, their language do not intersect.",
            "And then, instead of augmenting simply, you're sorry instead of augmenting simply.",
            "The positive DFA.",
            "You compute the product automatically.",
            "You can do that explicitly or."
        ],
        [
            "Recently, but the idea is the following.",
            "So on the left you have the positive DFA on the.",
            "In the middle you have the negative DFA and you can check that their language do not intersect and you can prove that because when you compute the product automaton you will color the states accordingly.",
            "So for instance if I go from zero and zero.",
            "The 00 States and since 0 is a negative accepting state, you color it as black.",
            "If you go from zero taking B.",
            "On the left you go to one and all in the middle.",
            "You also go to one, so you reach the 11 state and this is actually positive.",
            "Accepting states you label black, so in some cases you find no no popular covering, if of course during this process you find something which must be labeled both black and grey, well you discover an inconsistency between your two language.",
            "It means that your 2 languages actually intersect and so you start because you know there is no solution.",
            "And that's it.",
            "If you do that."
        ],
        [
            "You can actually learn the FA from a positive and a negative DFA an the merging will give you a generalization while checking all the constraints that you may have.",
            "And of course you can.",
            "You can add additional domain knowledge to label your your original DFAS accordingly."
        ],
        [
            "OK, so that's the takehome message.",
            "Mandatory merge constraints were introduced here to model domain knowledge.",
            "For instance, from a requirement engineering point of view, as I explained in the beginning.",
            "Those constraints from the logical counterpart to the classical incompatibility constraints.",
            "And the MSM algorithm deals with both type of constraints.",
            "It actually from an algorithmic POV, a straightforward extension to RP and blue fringed well known technique but without satisfying the tree invariant properties.",
            "So you might have to review your implementation if you care about that.",
            "It's what it means that you have to do the recursive measuring, but extended to general graph.",
            "And it's another problem to guarantee that your recursion actually ends.",
            "And as a side result, it also gives rise to the SM Star algorithm, which allows you to induce DFA from prior positive and negative DFAS.",
            "So this looks to be an interesting interesting bull from a practical point of view, because you can feed your algorithms with a richer class of input, but in so may require new theoretical framework innocence."
        ],
        [
            "So that's part of our future works.",
            "As I said on current implementation.",
            "Use the RP 9 search order, but there is really no conceptual problem to extend it to the blue fringe, so that looks very easy, something which we are thinking at is also to re include the active learning parties.",
            "The possibility to ask question.",
            "It seems feasible, but somewhat more challenging.",
            "An you might you may have other applicatives context where you could see that this labeling of of the initial PTA makes sense.",
            "The more interesting part I would say for the future is even to consider this this last algorithm.",
            "What is the correct example in this setting?",
            "You know that's why I said, well, we're not really fitting.",
            "For instance identification limit.",
            "We don't have a presentation with text or informant, we have a presentation with positive and a negative machine.",
            "So it might be worth thinking about that and see how we can actually characterize this type of algorithm and also from a practical viewpoint, how are we going to have an experimental?",
            "Article to actually assess the performance of maybe this algorithm or other competitors?",
            "Thank you.",
            "Whatever.",
            "Yes.",
            "Presentation of an application of technique great.",
            "And do you have a do you think that flu shots could be nondeterministic?",
            "Or as there could be deterministic or crazy?",
            "I'm going to ask my Oracle in the in domain.",
            "Do you, do you think the flow chart can be nondeterministic?",
            "Yeah yeah, go back to."
        ],
        [
            "Here.",
            "We we use it to merge.",
            "Using the merge function at the beginning.",
            "So you reduce it with the classical merging by by merging as we do in the induction algorithm.",
            "About?",
            "I have not understood the test is about dingeldein test OK.",
            "Battery constraints we label states randomly.",
            "No no, no no.",
            "In the in the."
        ],
        [
            "So here, so in the sample.",
            "Normally you generate positive and negative examples randomly and then from the positive example you build the PTA.",
            "That's the usual protocol.",
            "But here on top of it we randomly label fraction of states.",
            "According to the target, of course we have the so OK review, the review, the protocol we start from the target OK?",
            "No, no, no we we label the PTA according to the target because we know, we know that that's the example here.",
            "Think about the train example you are in initial setting.",
            "Everything is safe and fine.",
            "And then you have a sequence of start and stop.",
            "And so the knowledge tell you well you should be in the same state and so there is a sequence of events actually corresponding to the same state in the global system.",
            "So we generate as usual.",
            "We generate a target, randomly withdrew.",
            "Example, we label them actually as positive or negative, but on top of it we label a certain fraction of states of the PTA according to the target, and that's kind of mimic the knowledge we might have from an African applicative POV.",
            "Not in practice, actually.",
            "We we we don't do that because we start already from the compact machine, because it's kind of here in the sense instead of, instead of seeing this as a PTA with label states, what we actually do is charge from the general graph when those dates are already merged.",
            "That's that's OK.",
            "But for the simulation we did exactly what I explained.",
            "We generate the PTA and then we label some fraction of these states according to the."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Yeah, well presented joint work with both of them are and found out on board on state merchant.",
                    "label": 0
                },
                {
                    "sent": "Give a induction algorithms with mandatory merge constraints.",
                    "label": 1
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "So the initial motivation of this work is more practical and you will see that my talk will have some sort of an algorithmic POV.",
                    "label": 0
                },
                {
                    "sent": "But it also some sort of give new insight of existing state merging techniques and maybe some extension we developed and it at the end it also trigger maybe some new theoretical.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Options.",
                    "label": 0
                },
                {
                    "sent": "So the practical motivation is.",
                    "label": 0
                },
                {
                    "sent": "Either give an application domain that we are interested in.",
                    "label": 0
                },
                {
                    "sent": "Actually my two Co authors or specialist of these of these domain which is called requirements engineering and the problem is the following.",
                    "label": 0
                },
                {
                    "sent": "It is the problem of the design of a software system before actually building it.",
                    "label": 1
                },
                {
                    "sent": "So you want to be able to innocence have a way to formalize what the system should do, and that's considered to be the hardest part in the design.",
                    "label": 1
                },
                {
                    "sent": "Once you have that, you can check that your specification is right and then even.",
                    "label": 0
                },
                {
                    "sent": "Do some code generation automatically.",
                    "label": 1
                },
                {
                    "sent": "Actually one can automate part of this process by learning behave what is called in this domain behavior model from scenarios, and as you will see this is nothing but set of the problem of learning a language from a set of strings, so it's nicely come down to something we know about.",
                    "label": 0
                },
                {
                    "sent": "And more of the kind of language they are after are nicely represented by finite state machine, so.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "That seems to be an interesting setting.",
                    "label": 0
                },
                {
                    "sent": "So what is a scenario?",
                    "label": 0
                },
                {
                    "sent": "So we have here or case study example where we have a train system and you have different agent or actors in this train system.",
                    "label": 1
                },
                {
                    "sent": "So here the controller, a sensor, Anna passenger and there are events that can happen.",
                    "label": 0
                },
                {
                    "sent": "Something like the string start.",
                    "label": 0
                },
                {
                    "sent": "I should have another point.",
                    "label": 0
                },
                {
                    "sent": "The train start here.",
                    "label": 0
                },
                {
                    "sent": "Then some passenger press the alarm and the alarm is propagated from the sensor to the controller and then he has to stop in emergency and then open the doors.",
                    "label": 0
                },
                {
                    "sent": "So that's a positive scenario.",
                    "label": 0
                },
                {
                    "sent": "Everything this sequence of events correspond to some correct behavior of the system, and here's an incorrect behavior.",
                    "label": 0
                },
                {
                    "sent": "If you start to train and suddenly you open the doors, you won't satisfy kind of a safety goal, so it's negative scenario.",
                    "label": 1
                },
                {
                    "sent": "The good thing is that these scenarios can actually be provided by some end users.",
                    "label": 1
                },
                {
                    "sent": "Somebody asking you to design a system, and so you say, OK, what is your system supposed to do?",
                    "label": 0
                },
                {
                    "sent": "And it's very hard for an end user to come up with a formal specification.",
                    "label": 0
                },
                {
                    "sent": "Even finite state machine, but she can provide usually some typical sequence of events that corresponds to correct or incorrect behavior.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So it's a win win situation for people.",
                    "label": 0
                },
                {
                    "sent": "Interesting grammatical inference, any particular DFA induction, because in this domain regular language are considered to be certainly powerful enough, so we don't have to try to tackle harder class innocence.",
                    "label": 1
                },
                {
                    "sent": "And it's more than that.",
                    "label": 0
                },
                {
                    "sent": "The DFA is D representation that people use for different reason and the two main one probably is that once you have a description of your system in a finite state model, and.",
                    "label": 0
                },
                {
                    "sent": "Especially DFA.",
                    "label": 1
                },
                {
                    "sent": "Then you can do model checking in code generation.",
                    "label": 0
                },
                {
                    "sent": "The typical size of such machine is.",
                    "label": 1
                },
                {
                    "sent": "Between 20 and 100 states, which is which is?",
                    "label": 0
                },
                {
                    "sent": "Hard enough to make it kind of impossible to design by hand, but not too big so that or existing algorithm can actually tackle this problem, and the typical state of the art algorithm, RPI and blue fringe, also known as red, blue and tend to use a blue fridge name, but it's the same so and also the typical alphabet size is say an order of magnitude higher than the OR classical two or three letter alphabet, but it's still reasonable so.",
                    "label": 0
                },
                {
                    "sent": "And it's even better than that.",
                    "label": 0
                },
                {
                    "sent": "Once you when you have an end user, you actually have an Oracle, because you can.",
                    "label": 0
                },
                {
                    "sent": "You can ask her additional scenarios, suggested scenarios and see whether it's considered to be positive or negative.",
                    "label": 0
                },
                {
                    "sent": "So members.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Degrees in special essentially.",
                    "label": 0
                },
                {
                    "sent": "So this is actually a summary of a previous work on this topic, and we designed a so called QSM algorithm which is an extension to the classical RP and I and blue fringe with membership queries an the idea of using queries.",
                    "label": 1
                },
                {
                    "sent": "Here we're not to actually be able to learn something different because we have negative and positive scenario, so it should be enough, but to reduce the amount of initial scenario the end user has to provide and two.",
                    "label": 0
                },
                {
                    "sent": "Ask her additional data to be provided incrementally so we are in an online online learning setting here and that's that's a screen capture of the actual interface we have, so we provide a new scenario which is not in the initial collection.",
                    "label": 0
                },
                {
                    "sent": "Something like starting this train, stopping this train, and then starting again, and there is a question mark here because we know that up to there is still a positive behavior and we want to know if we add an extra event, whether it's still OK.",
                    "label": 0
                },
                {
                    "sent": "This case, the answer is yes, and in another case the answer would be no.",
                    "label": 0
                },
                {
                    "sent": "Testing thing is that we use the characterizations of the RPI algorithm that is the Arctic set to design these questions to see which one we have to ask.",
                    "label": 0
                },
                {
                    "sent": "And also in the interface there is the change button here.",
                    "label": 0
                },
                {
                    "sent": "So we have a certain amount of possible correction queries in a sense, and I don't have the time to discuss that here, but it's an interesting setting as well.",
                    "label": 0
                },
                {
                    "sent": "So that's actually our previous work on the top.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Anne.",
                    "label": 0
                },
                {
                    "sent": "Now we actually have another type of information.",
                    "label": 0
                },
                {
                    "sent": "So far we have been trying to say we are asking the end user only scenarios.",
                    "label": 0
                },
                {
                    "sent": "You know, that's that's the kind of the language we talked to the end user.",
                    "label": 0
                },
                {
                    "sent": "But more realistically they are cases where we have an extra information, and that's formalized here in the middle.",
                    "label": 0
                },
                {
                    "sent": "So you find 4 scenarios here.",
                    "label": 0
                },
                {
                    "sent": "But here in the middle you have something which is called in their language.",
                    "label": 0
                },
                {
                    "sent": "High level message sequence chart, and what that is is just a flowcharting.",
                    "label": 1
                },
                {
                    "sent": "Of the different scenarios and in a sense, if you are in a natural state, your training safe and stop and then you have the Start Stop action.",
                    "label": 0
                },
                {
                    "sent": "So here the start of scenario then essentially you go back to the initial situation.",
                    "label": 0
                },
                {
                    "sent": "It means that globally you are in the same state and that's the kind of information we can also ask an end user.",
                    "label": 0
                },
                {
                    "sent": "Same thing if you open the door and then close them back.",
                    "label": 0
                },
                {
                    "sent": "Well it's in the same state, so we actually have an additional information that we can make.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Use of and that's what trigger the the idea of having these mandatory merge constraints.",
                    "label": 1
                },
                {
                    "sent": "So we will start from the classical PTA and so that's by the way the representation of those four scenarios here in terms of a sequence of events represented by your PTA.",
                    "label": 0
                },
                {
                    "sent": "So that's a practical since everybody know here.",
                    "label": 1
                },
                {
                    "sent": "But since we have this information of the general flow charting of the scenario, we will be able to add an extra information which is a label on these states saying that.",
                    "label": 0
                },
                {
                    "sent": "Actually, the state and the state.",
                    "label": 0
                },
                {
                    "sent": "These treaties should be the same one eventually, so they should correspond to the same state in the global system.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so.",
                    "label": 0
                },
                {
                    "sent": "That's the very short summary now of existing technique, so essentially DFA elections hardware is the PTA, and then you look for caution automaten, which is nothing but finding a partition of the state set and so for instance in this case the partition the initial partition correspond to the PTA and then you have a block with the state two and four and three and six.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And that's the classical code.",
                    "label": 0
                },
                {
                    "sent": "So you start from the PTA.",
                    "label": 0
                },
                {
                    "sent": "Sorry, you start from the PTA which is built from the positive sample.",
                    "label": 0
                },
                {
                    "sent": "And also we will see why the negative sample we start with the trivial partition and then we choose a state prior to merger two blocks in the partition and the different algorithm RP and I.",
                    "label": 0
                },
                {
                    "sent": "An blue fringe differ in the.",
                    "label": 0
                },
                {
                    "sent": "Search order here.",
                    "label": 0
                },
                {
                    "sent": "Apart from that there is the merge operation and we check whether the resulting automaton is still compatible with the negative sample that it doesn't accept any negative.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The merge operation actually has an additional property, as you know when you start from merging state three and two on the top here.",
                    "label": 0
                },
                {
                    "sent": "You can end up with a non deterministic machine and since we are after a DFA there is this recursive process of merging states in order to find a DFA at the end OK.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "And know something we discover in this work or we re discover in the sense that in those algorithms RPI on blue fringe you and that's the blue fringe setting here represented, you always have the guarantee that we call the tree invariant property.",
                    "label": 0
                },
                {
                    "sent": "In a sense, you always consider the merging between two states such that at least one of them is the root of a tree.",
                    "label": 1
                },
                {
                    "sent": "So for instance, we will consider here the possible merge between state three and State 2 Ann.",
                    "label": 0
                },
                {
                    "sent": "Actually, state three is by construction.",
                    "label": 0
                },
                {
                    "sent": "The root of a tree, which is also the case of State 2, but it wouldn't be the case if you consider three and zero, for instance.",
                    "label": 1
                },
                {
                    "sent": "And that actually is true for and that's a consequence of the merge order, and that is used by those algorithm.",
                    "label": 0
                },
                {
                    "sent": "And actually it's simplified.",
                    "label": 1
                },
                {
                    "sent": "It simplified the actual implementation in particular.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "When you have these recursive merging and so the invariant is also true for all these merging, so if I consider 9, seven and two 7 and 2, seven is also the root of the tree of a subtree here, and it means that it looks like the natural stopping criterion of this recursion.",
                    "label": 0
                },
                {
                    "sent": "We will see that we can actually have this stopping property without having this tree invariants in a minute, but that's the usual way of looking at these things.",
                    "label": 0
                },
                {
                    "sent": "So the fact that we have a tree kind of natural stuff.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Incursion.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, and so these are classical incompatibility constraints, so that's not new.",
                    "label": 0
                },
                {
                    "sent": "That's one way of encoding the negative information.",
                    "label": 1
                },
                {
                    "sent": "So instead of building the prefix tree only with the positive example, you also augment it with a negative example, and then you color your States and the great State correspond to positively accepting Satan.",
                    "label": 0
                },
                {
                    "sent": "The black state here to the negative accepting state, and so when you do that, the merge operation not only.",
                    "label": 0
                },
                {
                    "sent": "Reduce nondeterminism, but also check weather.",
                    "label": 0
                },
                {
                    "sent": "In this process you end up merging.",
                    "label": 0
                },
                {
                    "sent": "Agree in a black state which is a sign of incompatibility, so there is no additional check for incompatibilities.",
                    "label": 1
                },
                {
                    "sent": "The merge operation, which performance at the mean time.",
                    "label": 0
                },
                {
                    "sent": "So these constraints are usually called coloring constraints and the feature is that state having different color colors may not be merged while still having the same color can be merged and the actual.",
                    "label": 1
                },
                {
                    "sent": "The actual result depends on the execution of the algorithm.",
                    "label": 0
                },
                {
                    "sent": "This is not new, this was mentioned already by custom codes or.",
                    "label": 0
                },
                {
                    "sent": "In all four, and even before and we.",
                    "label": 0
                },
                {
                    "sent": "We propose some ways of using domain knowledge, not necessarily negative information, but other domain knowledge to color you stays in the particular case of requirements engineering.",
                    "label": 0
                },
                {
                    "sent": "In our previous work.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And now I'm coming back to the mandatory merge constraints.",
                    "label": 1
                },
                {
                    "sent": "So now I want to not only have these incompatibly constraints, but mandatory merge, and we encode them with labels.",
                    "label": 0
                },
                {
                    "sent": "So you have the X label on the three States and so there are.",
                    "label": 0
                },
                {
                    "sent": "These are the logical counterpart to the coloring constraint in the sense that the states that have the same label must be merged and sit with different labels can be merged.",
                    "label": 1
                },
                {
                    "sent": "So that's exactly opponent opposite situation.",
                    "label": 0
                },
                {
                    "sent": "Something which is important to realize is that even a fully labeled if you have full information, that is, you have a fully labeled PTA.",
                    "label": 0
                },
                {
                    "sent": "Your problem does not reduce to a trivial problem, and because if you don't have any additional information, say for instance no negative information, what's going to happen with that?",
                    "label": 0
                },
                {
                    "sent": "Allstate will eventually be merged together, so it's good to have this additional information, as you will see in the experiment.",
                    "label": 0
                },
                {
                    "sent": "But even if you have a full information of labeling, information does not come up too.",
                    "label": 0
                },
                {
                    "sent": "Reduced to a travel prop.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so here is the EM algorithm.",
                    "label": 0
                },
                {
                    "sent": "So statement state merging with mandatory merge constraint and we play a bit with with how to?",
                    "label": 0
                },
                {
                    "sent": "Use this constraint and we can discuss that afterwards if you like.",
                    "label": 0
                },
                {
                    "sent": "But actually the simplest and the right way to use these constraints just start merging them from the beginning so it's actually trivial extension to existing algorithms.",
                    "label": 0
                },
                {
                    "sent": "You start from your building, your augmented PTA, and then you have an additional block here where you impose that state having the same labels are merged together.",
                    "label": 0
                },
                {
                    "sent": "And of course you also propagate this merging.",
                    "label": 0
                },
                {
                    "sent": "Using the classical merge function so you reduce the nondeterminism and then you start from there and that's the the classical merge loop.",
                    "label": 0
                },
                {
                    "sent": "Now you might end up in cases where you're labeling constraints that your color and constraints are kind of inconsistent.",
                    "label": 0
                },
                {
                    "sent": "On one hand, you say you have to merge them, and on the other side you say you cannot merge them and it's going to be discovered by the Merge function, and that's why you have these exception mechanism to raise the problem.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, so as I said, when you look at it from an algorithmic point of view, it's really a trivial extension to existing techniques.",
                    "label": 0
                },
                {
                    "sent": "Although it was motivated by a real practical setting, however.",
                    "label": 0
                },
                {
                    "sent": "The first, I mean, the first time we tried that it didn't work and an becausw or implementation was assuming the tree invariant property.",
                    "label": 1
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And actually when we start with these labeling constraints, since you merge state from the very beginning, you destroy it completely.",
                    "label": 0
                },
                {
                    "sent": "The graph the tree structure of your initial machine.",
                    "label": 1
                },
                {
                    "sent": "So it means that in general you can have.",
                    "label": 0
                },
                {
                    "sent": "You can start the actual merging part of your algorithm from a general graph and no longer a subtree.",
                    "label": 1
                },
                {
                    "sent": "Anne.",
                    "label": 0
                },
                {
                    "sent": "It doesn't matter actually, because we can implement it easily.",
                    "label": 0
                },
                {
                    "sent": "You have to probably review your implementation, but it's completely feasible to implement this recursive merge merging on a general graph structure.",
                    "label": 0
                },
                {
                    "sent": "So here's an example.",
                    "label": 0
                },
                {
                    "sent": "You start from a graph and assume that this is the initial situation where after applying your labeling constraint, you have this graph, and then you decide to merge state three and zero.",
                    "label": 0
                },
                {
                    "sent": "And if you do that, you will have a nondeterminism on letter B here, and so by recursion you have to merge the two successor two and four.",
                    "label": 0
                },
                {
                    "sent": "And you end up here and actually naturally the recursion stuff and the recursion stuff.",
                    "label": 1
                },
                {
                    "sent": "Not because this is a tree, but because there is no additional non determine is created by the successor of the States.",
                    "label": 0
                },
                {
                    "sent": "You just merge.",
                    "label": 0
                },
                {
                    "sent": "And that's another condition for a natural ending of this process.",
                    "label": 0
                },
                {
                    "sent": "So of course if you want to implement that, you have to review your implementation.",
                    "label": 0
                },
                {
                    "sent": "But it's you don't actually need the tree invariant property.",
                    "label": 1
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "No.",
                    "label": 0
                },
                {
                    "sent": "Here, here are some experiments, so this is the classical setting like in the Eagle competition.",
                    "label": 0
                },
                {
                    "sent": "So we have here the learning sample size for increasing learning sample size an you have the accuracy.",
                    "label": 0
                },
                {
                    "sent": "Along the other axis, and here the first curve for two different target size, but the conclusion are the same.",
                    "label": 0
                },
                {
                    "sent": "Here the first correspond to the RP and I algorithm.",
                    "label": 0
                },
                {
                    "sent": "The second one correspond to the blue fridge.",
                    "label": 0
                },
                {
                    "sent": "So you change the search order and you shift a bit the conversions that the improvement provided by the blue fridge.",
                    "label": 0
                },
                {
                    "sent": "And here we have all algorithms with different percentage of labeling.",
                    "label": 0
                },
                {
                    "sent": "So this means that you have 5% of states having their labeled 10% when he 100%.",
                    "label": 0
                },
                {
                    "sent": "You know current implementation, the search order of MSM correspond to RP and eyes, so it means that MSM with zero percent is equivalent to RPI.",
                    "label": 0
                },
                {
                    "sent": "So what we see here is that with 5% it's kind of equivalent to the game we can have with blue fringe going from RPI to blue fringe.",
                    "label": 0
                },
                {
                    "sent": "And of course if you increase the labeling rate well, you improve the conversions in the sense that you have a better accuracy with fewer.",
                    "label": 0
                },
                {
                    "sent": "Example.",
                    "label": 0
                },
                {
                    "sent": "But also what I was telling you before, even with 100% labeling, that is the top curve.",
                    "label": 0
                },
                {
                    "sent": "It does not reduce to a trivial problem if you have very few sample even with 100 person able you can you end up with not a perfect solution, and that's what that's because you overgeneralized innocence your sample.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so here it is, or classical case to the which is part of the system describing the train controller an it's it's.",
                    "label": 0
                },
                {
                    "sent": "It's the same conclusion.",
                    "label": 0
                },
                {
                    "sent": "So here we start from.",
                    "label": 0
                },
                {
                    "sent": "We compare RPI and blue fridge and the EM algorithm with different labeling, number of states label and as you see the accuracy with 00 state label is the same RPI, the same search order an.",
                    "label": 0
                },
                {
                    "sent": "As you increase the number of state labeled well, you improve the accuracy.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, no it is.",
                    "label": 0
                },
                {
                    "sent": "It is worth looking at.",
                    "label": 0
                },
                {
                    "sent": "The actual algorithm can the very same algorithm can be seen a bit differently an.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "If I come back here.",
                    "label": 0
                },
                {
                    "sent": "If you think about it, so there is this first part down to here.",
                    "label": 0
                },
                {
                    "sent": "So you start from a positive sample, but then using these additional constraints you will actually start emerging.",
                    "label": 0
                },
                {
                    "sent": "The real classical merging loop with a general graph.",
                    "label": 0
                },
                {
                    "sent": "So it means that and it's and by construction it's a DFA.",
                    "label": 0
                },
                {
                    "sent": "It means that actually your input of this part of the algorithm can be seen as a DFA or positive DFA augmented with.",
                    "label": 0
                },
                {
                    "sent": "Negative sample.",
                    "label": 0
                },
                {
                    "sent": "It's there is something else.",
                    "label": 0
                },
                {
                    "sent": "You also have the search order here will be related to the definition of the partition, which is which is initially here and then updated here.",
                    "label": 0
                },
                {
                    "sent": "So when you see that.",
                    "label": 0
                },
                {
                    "sent": "Actually.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "You can rephrase the same algorithm.",
                    "label": 0
                },
                {
                    "sent": "I think, well, I don't need to start from a positive sample and a set of labeling constraint.",
                    "label": 0
                },
                {
                    "sent": "I can start from a positive DFA, so another input of my algorithm is a positive DFA Anna negative sample.",
                    "label": 1
                },
                {
                    "sent": "And So what you do is you start by augmenting your positive DFA wizard negative sample in exactly similar fashion as you do with the PTA, and then of course you have to find the order you have to label your state.",
                    "label": 0
                },
                {
                    "sent": "But there is a natural order.",
                    "label": 0
                },
                {
                    "sent": "You just compute the shortest prefix to each state and you label your states accordingly.",
                    "label": 0
                },
                {
                    "sent": "And once you've done well, you start generalizing as usual by merging.",
                    "label": 0
                },
                {
                    "sent": "Of course, implicitly, it means that you have.",
                    "label": 0
                },
                {
                    "sent": "Extended your merging operation with the ability to deal with general graph structure during the recursion of the merging.",
                    "label": 0
                },
                {
                    "sent": "Once you see that.",
                    "label": 0
                },
                {
                    "sent": "We say oh, that's kind of cool.",
                    "label": 0
                },
                {
                    "sent": "Actually, we haven't seen that at the beginning.",
                    "label": 0
                },
                {
                    "sent": "We can.",
                    "label": 0
                },
                {
                    "sent": "We can generalize the the.",
                    "label": 0
                },
                {
                    "sent": "We can generalize the induction problem and say OK, Now we start from positive DFA and negative sample well.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "We can even do better.",
                    "label": 0
                },
                {
                    "sent": "We can start from a positive definite negative sample and a negative DFA so you have two DFA's such that their language, their language do not intersect.",
                    "label": 1
                },
                {
                    "sent": "And then, instead of augmenting simply, you're sorry instead of augmenting simply.",
                    "label": 0
                },
                {
                    "sent": "The positive DFA.",
                    "label": 0
                },
                {
                    "sent": "You compute the product automatically.",
                    "label": 0
                },
                {
                    "sent": "You can do that explicitly or.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Recently, but the idea is the following.",
                    "label": 0
                },
                {
                    "sent": "So on the left you have the positive DFA on the.",
                    "label": 0
                },
                {
                    "sent": "In the middle you have the negative DFA and you can check that their language do not intersect and you can prove that because when you compute the product automaton you will color the states accordingly.",
                    "label": 0
                },
                {
                    "sent": "So for instance if I go from zero and zero.",
                    "label": 0
                },
                {
                    "sent": "The 00 States and since 0 is a negative accepting state, you color it as black.",
                    "label": 0
                },
                {
                    "sent": "If you go from zero taking B.",
                    "label": 0
                },
                {
                    "sent": "On the left you go to one and all in the middle.",
                    "label": 0
                },
                {
                    "sent": "You also go to one, so you reach the 11 state and this is actually positive.",
                    "label": 0
                },
                {
                    "sent": "Accepting states you label black, so in some cases you find no no popular covering, if of course during this process you find something which must be labeled both black and grey, well you discover an inconsistency between your two language.",
                    "label": 0
                },
                {
                    "sent": "It means that your 2 languages actually intersect and so you start because you know there is no solution.",
                    "label": 0
                },
                {
                    "sent": "And that's it.",
                    "label": 0
                },
                {
                    "sent": "If you do that.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "You can actually learn the FA from a positive and a negative DFA an the merging will give you a generalization while checking all the constraints that you may have.",
                    "label": 1
                },
                {
                    "sent": "And of course you can.",
                    "label": 0
                },
                {
                    "sent": "You can add additional domain knowledge to label your your original DFAS accordingly.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, so that's the takehome message.",
                    "label": 0
                },
                {
                    "sent": "Mandatory merge constraints were introduced here to model domain knowledge.",
                    "label": 1
                },
                {
                    "sent": "For instance, from a requirement engineering point of view, as I explained in the beginning.",
                    "label": 1
                },
                {
                    "sent": "Those constraints from the logical counterpart to the classical incompatibility constraints.",
                    "label": 1
                },
                {
                    "sent": "And the MSM algorithm deals with both type of constraints.",
                    "label": 1
                },
                {
                    "sent": "It actually from an algorithmic POV, a straightforward extension to RP and blue fringed well known technique but without satisfying the tree invariant properties.",
                    "label": 0
                },
                {
                    "sent": "So you might have to review your implementation if you care about that.",
                    "label": 0
                },
                {
                    "sent": "It's what it means that you have to do the recursive measuring, but extended to general graph.",
                    "label": 0
                },
                {
                    "sent": "And it's another problem to guarantee that your recursion actually ends.",
                    "label": 0
                },
                {
                    "sent": "And as a side result, it also gives rise to the SM Star algorithm, which allows you to induce DFA from prior positive and negative DFAS.",
                    "label": 1
                },
                {
                    "sent": "So this looks to be an interesting interesting bull from a practical point of view, because you can feed your algorithms with a richer class of input, but in so may require new theoretical framework innocence.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So that's part of our future works.",
                    "label": 0
                },
                {
                    "sent": "As I said on current implementation.",
                    "label": 0
                },
                {
                    "sent": "Use the RP 9 search order, but there is really no conceptual problem to extend it to the blue fringe, so that looks very easy, something which we are thinking at is also to re include the active learning parties.",
                    "label": 1
                },
                {
                    "sent": "The possibility to ask question.",
                    "label": 0
                },
                {
                    "sent": "It seems feasible, but somewhat more challenging.",
                    "label": 1
                },
                {
                    "sent": "An you might you may have other applicatives context where you could see that this labeling of of the initial PTA makes sense.",
                    "label": 0
                },
                {
                    "sent": "The more interesting part I would say for the future is even to consider this this last algorithm.",
                    "label": 0
                },
                {
                    "sent": "What is the correct example in this setting?",
                    "label": 0
                },
                {
                    "sent": "You know that's why I said, well, we're not really fitting.",
                    "label": 0
                },
                {
                    "sent": "For instance identification limit.",
                    "label": 0
                },
                {
                    "sent": "We don't have a presentation with text or informant, we have a presentation with positive and a negative machine.",
                    "label": 0
                },
                {
                    "sent": "So it might be worth thinking about that and see how we can actually characterize this type of algorithm and also from a practical viewpoint, how are we going to have an experimental?",
                    "label": 0
                },
                {
                    "sent": "Article to actually assess the performance of maybe this algorithm or other competitors?",
                    "label": 0
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "Whatever.",
                    "label": 0
                },
                {
                    "sent": "Yes.",
                    "label": 0
                },
                {
                    "sent": "Presentation of an application of technique great.",
                    "label": 0
                },
                {
                    "sent": "And do you have a do you think that flu shots could be nondeterministic?",
                    "label": 0
                },
                {
                    "sent": "Or as there could be deterministic or crazy?",
                    "label": 0
                },
                {
                    "sent": "I'm going to ask my Oracle in the in domain.",
                    "label": 0
                },
                {
                    "sent": "Do you, do you think the flow chart can be nondeterministic?",
                    "label": 0
                },
                {
                    "sent": "Yeah yeah, go back to.",
                    "label": 0
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here.",
                    "label": 0
                },
                {
                    "sent": "We we use it to merge.",
                    "label": 0
                },
                {
                    "sent": "Using the merge function at the beginning.",
                    "label": 0
                },
                {
                    "sent": "So you reduce it with the classical merging by by merging as we do in the induction algorithm.",
                    "label": 0
                },
                {
                    "sent": "About?",
                    "label": 0
                },
                {
                    "sent": "I have not understood the test is about dingeldein test OK.",
                    "label": 0
                },
                {
                    "sent": "Battery constraints we label states randomly.",
                    "label": 0
                },
                {
                    "sent": "No no, no no.",
                    "label": 0
                },
                {
                    "sent": "In the in the.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So here, so in the sample.",
                    "label": 0
                },
                {
                    "sent": "Normally you generate positive and negative examples randomly and then from the positive example you build the PTA.",
                    "label": 0
                },
                {
                    "sent": "That's the usual protocol.",
                    "label": 0
                },
                {
                    "sent": "But here on top of it we randomly label fraction of states.",
                    "label": 0
                },
                {
                    "sent": "According to the target, of course we have the so OK review, the review, the protocol we start from the target OK?",
                    "label": 0
                },
                {
                    "sent": "No, no, no we we label the PTA according to the target because we know, we know that that's the example here.",
                    "label": 0
                },
                {
                    "sent": "Think about the train example you are in initial setting.",
                    "label": 0
                },
                {
                    "sent": "Everything is safe and fine.",
                    "label": 0
                },
                {
                    "sent": "And then you have a sequence of start and stop.",
                    "label": 0
                },
                {
                    "sent": "And so the knowledge tell you well you should be in the same state and so there is a sequence of events actually corresponding to the same state in the global system.",
                    "label": 0
                },
                {
                    "sent": "So we generate as usual.",
                    "label": 0
                },
                {
                    "sent": "We generate a target, randomly withdrew.",
                    "label": 0
                },
                {
                    "sent": "Example, we label them actually as positive or negative, but on top of it we label a certain fraction of states of the PTA according to the target, and that's kind of mimic the knowledge we might have from an African applicative POV.",
                    "label": 0
                },
                {
                    "sent": "Not in practice, actually.",
                    "label": 0
                },
                {
                    "sent": "We we we don't do that because we start already from the compact machine, because it's kind of here in the sense instead of, instead of seeing this as a PTA with label states, what we actually do is charge from the general graph when those dates are already merged.",
                    "label": 0
                },
                {
                    "sent": "That's that's OK.",
                    "label": 0
                },
                {
                    "sent": "But for the simulation we did exactly what I explained.",
                    "label": 0
                },
                {
                    "sent": "We generate the PTA and then we label some fraction of these states according to the.",
                    "label": 0
                }
            ]
        }
    }
}