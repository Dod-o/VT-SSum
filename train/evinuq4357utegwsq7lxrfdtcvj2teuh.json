{
    "id": "evinuq4357utegwsq7lxrfdtcvj2teuh",
    "title": "Constant-Working-Space Algorithms for Image Processing",
    "info": {
        "author": [
            "Tetsuo Asano, School of Information Science, Japan Advanced Institute of Science and Technology (JAIST)"
        ],
        "published": "Dec. 5, 2008",
        "recorded": "November 2008",
        "category": [
            "Top->Computer Science->Computer Vision"
        ]
    },
    "url": "http://videolectures.net/etvc08_asano_cwsaf/",
    "segmentation": [
        [
            "OK, so my name is Alton Mason airline Flare Searcher from and start Paris and well let me introduce the first talk of this of this session.",
            "That would be done by a tattoo as I know the name of the speech is constant working space algorithm for image processing.",
            "Thank you.",
            "Does he use the microphone?",
            "I want to thank organize out this conference to invited me to this wonderful workshop.",
            "Today I'm going to talk about the constant walking space algorithm for image processing, and this is a joint work with Lydia Mzero and Sarah Gable Egg and David Cap Patrick.",
            "OK so."
        ],
        [
            "In this talk, my computation model is somewhat strange becausw, you know input data are given on readonly array, so we can read input data, but we can't write anything on input array.",
            "OK, it is just read only and on and we are allowed to use only constant number of variables or constant number of working storage service and.",
            "And each walking store itself is of Logan bit and N is a number of.",
            "Input.",
            "Input any is an input size OK and and each working storage so.",
            "And have a order of Logan bids.",
            "And so the total loggings storage sizes also order of log N OK, so this is a very restricted model and this kind of program was known.",
            "Under the different name, which is logspace in complexity theory, an but the.",
            "The people in complexity theory or interest is only on you know whether the program is belong to low space or not.",
            "They are not so interested in.",
            "Efficiency of algorithms.",
            "So since I am, I mean I'm working in algorithms, so I'm interested in.",
            "Patient algorithm to develop efficient algorithms.",
            "So."
        ],
        [
            "And the people ask me why you are interested in such a restricted model now.",
            "First of all, I hate.",
            "I forgot my operating system.",
            "The next operating system of XP Vista I. I don't like this to be 'cause it's you know it's required me say 2 gigabytes in main memory, what?",
            "2 gigabytes?",
            "When I was a college student.",
            "Memory was so expensive and so I can't imagine now why they need 2 gigabyte memory in and they they use very.",
            "Space inefficient algorithms are for Vista and I so because of that I don't like Vista and my operating system is 2 XP.",
            "Anyway, so and other than that there are many, you know.",
            "How do words which contains some softwares they are called embedded software nowadays desire.",
            "Camilla has a very sophisticated you know software.",
            "These are camera has very sophisticated programs in it and in those applications.",
            "Maybe The Walking space is very expensive and the rocking storage is should be remitted.",
            "And in some application we want to keep input data as unchanged so that input data should be treated as read only memory read only array and in that respect recursion.",
            "We have to think about recursion.",
            "Becausw working storage is proportional to recursion depth.",
            "So for example if we implement, say, quicksort, we need, say at least Logan recursion depth and so that means we need Logan working space.",
            "So if we are allowed to use Rogan space, then we can implement quicksort recursive quicksort, but otherwise.",
            "We need to have some control on the recursion depth, so sometimes I call it controlled recursion because recursion depth should be controlled."
        ],
        [
            "OK, So what is known today?",
            "Well, the first maybe the first important result is given by Young Monroe and Rama, his student Roman, and the problem is medium finding.",
            "So given readonly array containing elements we want to find the median of that and how far is can we do that can find median using only constant number of variables.",
            "So that is the first one.",
            "And the second one is is a big breakthrough in this in Logspace theory.",
            "Our community, so that is called the St connectivity in graphs, so we are given undirected graph on using readonly array and also we are given two vertices S&T and.",
            "The problem is to determine whether they are connected or not.",
            "They are connected by a path or not and it is easy problem if we can use.",
            "Order in, you know locking storage.",
            "But what happened if we have only constant number of working storage?",
            "And the third one is related to image processing.",
            "And I I don't know how to pronounce his name and so I just avoid to pronounce his name, but so he they consider the similar problem.",
            "It is called St connectivity image or binary image.",
            "OK so in this case we are given a binary image consisting of zero and ones and also we are given 2 pictures OK. Run Barry, Run and then we ask whether there is path connecting them or not.",
            "And all these problems are solved in the positive."
        ],
        [
            "Way and so to have on this.",
            "Rough image image you can emerge in some SD connectivity in the maze in the maze.",
            "OK, so you can go through this white part and the two cells is and T are specified in.",
            "The question is whether you can find path.",
            "Only going through the white part and and maybe you know that we can check it by using so-called right hand rule.",
            "If you keep going by touching the wall by right hand then you can you can reach T. In this case.",
            "Happy."
        ],
        [
            "But if we remove these walls and then we have a hole here.",
            "And the if the target is attached to the whole, then right hand rule doesn't apply.",
            "We can't find the path on the by using the right hand rule.",
            "So we need some other."
        ],
        [
            "Technique.",
            "So in this case.",
            "It cannot be checked by the right hand."
        ],
        [
            "OK, So what about connectivity in in a graph?",
            "So we are given such a undirected graph and S&T are specified and we ask whether there is an pass or not.",
            "And the important thing is graph is given.",
            "Using our reason re RA so we can't put any mark on abatix OK and so it is hard but."
        ],
        [
            "But in 90.",
            "1996 I forgot or not.",
            "2002 Wrangled solve this problem and he gave a polynomial time algorithm for checking whether there is constant.",
            "There is a path or not, using only constant amount of memory.",
            "So."
        ],
        [
            "Oh, and here is a SD connectivity in binary image so that we are given a binary image and and two pixels S&T are given and we are."
        ],
        [
            "Ask whether there is a path like this or not, and.",
            "Very Fortunately there is linear time algorithm for finding this.",
            "This kind of path linear in the number of pixels using only constant number of variables."
        ],
        [
            "Alright, So what about median finding?",
            "This is a very famous album program in Algorithms, so we are given number of data and we want if we sort them then the the element in the middle is called a million and we want to find such an element.",
            "And of course if we we can use working space then.",
            "We can use linear time algorithms based on influence such and it's runs in linear time, is greater result and but how fast can we find the median in in our computation computation model using only constant number of variables and can we still compute the median in dinner time or does it take in Logan time or?",
            "Or maybe fix credited time might be lower bound."
        ],
        [
            "And.",
            "So for this program I will show you how to solve it in subquadratic time.",
            "And so first of all we given readonly array of size NI, partition it into blocks.",
            "Each block has ranks are square root of N OK and for each block I compute block median.",
            "By implementing a brute force algorithms.",
            "OK brute force means I compute the smallest one and the second smallest one, the smallest one and fine until we find a million OK, block, median and so it is a quadratic time algorithm.",
            "But since it contains only square root of an element, so it runs in order and time and we have square root of N blocks so that in total it takes N sqrt N. Time OK, in that time we can compute the block millions square root of benbrook medians OK and then.",
            "The important thing is that whenever we compute the block median, I scan the whole array to count the number of elements, which is smaller than that block median.",
            "OK, so by doing that I can.",
            "I can estimate I can.",
            "I know how many element is smaller than that.",
            "That is the rank of that element and I keep the best one.",
            "And using that, I pruned the the element OK. And so the I I have to iterate it at most Logan time.",
            "So the total running time is N sqrt N times log NK.",
            "So that is subquadratic."
        ],
        [
            "But using that we can design another algorithm called A3 which partition the array into into the 1/3 instead of square root of NK.",
            "And and then we apply the the previous algorithm A2 to find the block medium, and then it's runs in into the 4th OD.",
            "And keep going and I design that is OK, and which part is in the RN to enter the long run over K and it runs in this time bound.",
            "It is almost linear.",
            "It is end to the 1 + 1 / K. OK, so if K is great large then it is almost N. So, so this is a conclusion that if we can use order K working space, then the arrogant rounding into the 1 + 1 / K. Some look block factor or you can forget about log factor.",
            "Alright, so it is we can solve the media problem almost in linear time.",
            "OK that's very good result.",
            "Unfortunately.",
            "I had this algorithms and I wrote up the paper and I look at references and I found young moon Rose and Romans papers and which is exactly the same and.",
            "Very unfortunate, yeah.",
            "It's this kind of thing happens many times in our life."
        ],
        [
            "Anyway.",
            "Alright, so I want to.",
            "In this talk I want to talk about application to image processing.",
            "The first one is the thresholding.",
            "This is my one of my most favorite topics in image processing because it is very simple and so the problem is that given such an intensity image, we want to find an optimal threshold to have a binary image which looks very nice and so in this particular example.",
            "You know people if we have a threshold, say 100, then we have this binary image and maybe this is too low, so maybe we should try our larger value as a threshold and then we have different parts different binary image.",
            "So every time we we set threshold we have a binary image OK and then we evaluate resulting binary image and if it is good then we.",
            "Take that threshold.",
            "OK, so that that is.",
            "Approach.",
            "And in this particular case, the input image.",
            "This interesting image should be treated as a read only array and also to evaluate the binary image.",
            "That binary image also should be treated as a read only array.",
            "We can't write any information to the binary image.",
            "OK, so the problem is how to find such a."
        ],
        [
            "Ice threshold.",
            "And so the if we look at any textbook on image processing, then they say that, OK, you should compute histogram and then if you can find the two mountains and Barretts then you are fine and you just take the Barry Barry as a threshold.",
            "But in some case there is no, you know, Mount two mountains and in that case what can we do?",
            "OK."
        ],
        [
            "And so you know, we can find a good binary image experimentally, but it's not.",
            "There is no good.",
            "It is not a good algorithm."
        ],
        [
            "So, but unfortunately there is very nice algorithms proposed by some Japanese boots.",
            "I've never met him before, but his I know him very well.",
            "Yeah, so the in his algorithms you know he considered the histogram as.",
            "So he want to divide, give an extra sword into two classes at zero, and this one is 0 is is this class and this one is the right class and he want to.",
            "Maximize the intercluster distance and this kind of approach is called discriminant analysis.",
            "Maybe you're very familiar with that."
        ],
        [
            "So.",
            "Roughly speaking, it's we have to compute average intensity level for the whole image and for the Class S0 and for the Class S1.",
            "And we take the differences squared.",
            "This difference is that is that is.",
            "That is an Inter cluster distance, so we want to maximize this disvalue and this Inter cluster distance is defined for each threshold value T. So.",
            "And it is not so difficult to compute such a such.",
            "Operates, but intensity values, so the naive algorithm is that for each intensity image we compute this Inter cluster distance and take the maximum.",
            "That it, and it's it's runs in linear time in the number of brightness levels.",
            "OK, sorry it is very."
        ],
        [
            "Efficient and so.",
            "You know if if we have.",
            "Image containing N pixels and with L different intensity levels, then we can compute the optimal threshold in order of N + L type.",
            "OK, that's very easy and.",
            "Because of time I will skip."
        ],
        [
            "This detail, but.",
            "And what about the case where we only used?",
            "We can only use a constant number of variables.",
            "In that case, we can't compute that distance for each intensity variables.",
            "OK, so instead we use.",
            "We have to use some kind of binary search.",
            "OK, so given some threshold T then I can compare that.",
            "So this is, you know.",
            "Convert the third space is convex so that we can.",
            "We can apply the binary search and so whenever we are given some threshold, we can compare that this is good enough or not in so because of that we can compute the optimal search.",
            "Odin enrolled time.",
            "Using only constant working space.",
            "And.",
            "So the binary search works only when intense levels are given by integers one through NL OK, but sometimes we have a range data.",
            "I mean, I'm not so familiar in such data, but we can use some special camera which measure the distance from that camera to the object.",
            "OK, and in that case the.",
            "Values are not intensity level, but distances, so distances can be arbitrary variables.",
            "And so in that case, the you know the such a value input value are not integers and not be integers.",
            "And in that case, maybe we can use.",
            "Video on finding algorithm instead of also.",
            "Algorithms?",
            "But it's runs in almost."
        ],
        [
            "That time.",
            "So here is some example of the outputs of when we applied auto method.",
            "It still looks quite good."
        ],
        [
            "OK, so the next next one is maybe I will see."
        ],
        [
            "Keep it."
        ],
        [
            "So next program is how how to count the connected component in binary image.",
            "So we are given such a binary image and we can define connected components in the following way to one pixels or white pixels are connected if there is rectilinear sequence of 1 pixel between them and a connected component is a maximal set of 1 pixels.",
            "Any two of which are connected.",
            "So in this particular example, we have the one connected component here and the second connected component here and 3rd one and false one ends.",
            "So the problem is, given such a binary image as as a readonly array.",
            "We are requested to count the number of connected component using only constant number of variables and."
        ],
        [
            "Can we do this?",
            "Yes and.",
            "And."
        ],
        [
            "OK.",
            "So the key for the counting is is to follow the boundary.",
            "But there are there are two different kinds of boundaries.",
            "One is the external boundary of our connected component and the other one is internal boundary of the connected component so.",
            "So you know, in this particular example, this green part is connected component, and so this green roof line indicate external boundary OK, and.",
            "I Orient them so that the inside of the connected components always lied to the left.",
            "OK, so in that orientation the external boundary always oriented in the counterclockwise, say, and the internal one is oriented in Crookwell."
        ],
        [
            "The order OK, and for each such boundaries I defined a Canonical age that is lowest downward edge.",
            "So in this boundary what is lowest downtown?",
            "What age this?",
            "Is it?",
            "And this is the lowest downward edge on this internal boundary."
        ],
        [
            "So for each boundary we have unique such khanolkar edge.",
            "OK, so that is a key observation to count the number of components of.",
            "Using constant number of variables."
        ],
        [
            "So the.",
            "And but to count the number of connected component that we we have to discard internal boundaries OK because each connected component has only one external boundary and so it suffices to count the number of external boundaries.",
            "OK, so but so we have to distinguish internal boundaries and the external boundaries.",
            "And that is very easy because once we find conquer AIDS.",
            "Then the local structure is different in external and internal one because if we look at the lower right pixel then it is external 0 for external boundary and one internal boundary.",
            "So it is quite easy to distinguish them and so the."
        ],
        [
            "Our algorithms runs as follows.",
            "Given such a binary image, we do raster scan and whenever we hit some boundary, some boundary edge, we traverse the boundary.",
            "To confirm that that age is Cannon Carriage, that that means lowest down what age or not.",
            "So if if I start from here then I can easily find a lower edge, so that if I start from here then I can easily.",
            "You know, see that it is not a kernel carriage, and once I find a lower lower edge then I stop the thought.",
            "OK this is not a common carriage and only when we start from the Canonical edge we have to go around the boundary, but that's fine.",
            "That's fine 'cause it takes on the IT is only once.",
            "And so to follow the boundary, we use this procedure.",
            "So you know, we start from some edge ES and then we followed the next edge and next edge, and so until we find lower edge done ES or we find.",
            "It sell itself."
        ],
        [
            "OK, and so if we implement this algorithm naively, then it takes quadratic time.",
            "Unfortunately becausw it every time we do this can and so in this particular example, if I start from this edge, then I have to go around.",
            "Or the boundary.",
            "And if I start from here then I have to go around.",
            "You know this way, so it takes a quarter take time, but."
        ],
        [
            "If I use bidirectional result, so instead of searching in One Direction, but I search in two different directions, then we have a magic that it runs in Logan time.",
            "That's that's very nice."
        ],
        [
            "And so here is a worst case example which takes N squared logon time.",
            "Alright."
        ],
        [
            "So and we can apply this kind of technique to rept the old rip order sizes of all components.",
            "OK, so the given a binary image may contain several different many different connected components.",
            "So we want to compute the area of each connected component on by 1.",
            "Without any duplication, and how fast can we do this?",
            "And so in this particular example output should should look like this component one contains 21 pixels and component two contains 3 three pixels and so on.",
            "OK, how fast can we do this moderately weekend?",
            "We can do this in in logon time, where N is the number of pixels.",
            "So it's quite a."
        ],
        [
            "Efficient.",
            "So also in this particular example we have N by N image so that it takes N squared logon time, but it is almost dead."
        ],
        [
            "Yeah, and the last example is this pattern matching.",
            "We are given two binary images, one indicate patent and the other one is is like a text image and the question is how many copies are included included in text image.",
            "How many times the pattern image occurs in in in the second image OK?",
            "How fast can we do this?",
            "And the binary image consists of N by N or in total N pixels or and surprisingly we can do it in an organ time.",
            "That's.",
            "It is surprising to me at least me and."
        ],
        [
            "So I will skip the detailed."
        ],
        [
            "Of."
        ],
        [
            "It's.",
            "But believe me, it runs in northern time."
        ],
        [
            "And so, here is a conclusion.",
            "And so I want to extend our algorithm for geometric problems such as a planar subdivision or graphs.",
            "Or I want to establish that some nonlinear lower bounds on the time complexity for constant working space algorithms.",
            "So far I haven't succeeded yet.",
            "No, no result at all for lower bounds.",
            "Yeah."
        ],
        [
            "Maybe I will stop here.",
            "Thank you very much.",
            "Do you hear me?",
            "Thank you.",
            "Thank you for your presentation.",
            "Is there any question in the audience?",
            "Thank you, I found very nice your algorithm in your explanation examples and concerning the second example, the one where you compute the connected component of our brand image.",
            "I wonder whether you can apply this approach to compute connected computing graph.",
            "For example, in some special case like paragraph.",
            "Do you think that is?"
        ],
        [
            "As well so.",
            "This case is a special case of burgraff program, because in in a graph program.",
            "No, some brodix has degree more than two.",
            "But in this in this binary image case we can reduce the problem to graph programs in which every product has degree 2.",
            "So it is a degree two graph is that kind of degree two graphs.",
            "That's why everything is so easy.",
            "Anne.",
            "Yeah so.",
            "I think we can extend the algorithm to cleaner case for planar graph.",
            "Because yeah, but under the condition that planar graph is given embedded using, say W connected as wrist so that we can follow the boundary.",
            "In All India time in the length of the process and otherwise, if the input graph is is given in general form, we have nothing to do.",
            "Beautiful constant constant because of the encoding of the graph.",
            "Yeah yeah.",
            "OK, thank you.",
            "Thank you other question in the audience.",
            "No OK, I just have a few comments and questions 'cause you know, minimizing the space complexity.",
            "There's memory complexity is important in embedded processing in general, not only because of the constraint insert, but also because you know the the the time that memory access.",
            "Yeah, is is more important than the the computation itself, so.",
            "We have also other constraints the that make that you don't have.",
            "Not you you.",
            "Sometimes you you need not only to minimize the memory access, but to make such that the computation is meant between 2 two part of memories that are closed.",
            "You know in the in the in the memory itself.",
            "So for example when you when you compute the median when you have, when you compute the sort, when you make the sort in the in every block, sometimes it's better, for example to make a bubble sort.",
            "Haha than than than a brute force sort because the bubble sort is always make always the computation between between 2 two adjacent pixels.",
            "So have you any?",
            "Extension if you work in the in that problem or not yet.",
            "Not yet, yeah, but yeah it is a good point.",
            "I will think about it, yeah.",
            "But I have no no.",
            "I have never considered that kind of direction.",
            "So right now I have no, it's OK, OK, OK?",
            "I meant that I can do in the.",
            "In general is that you know that we can see that you work.",
            "It can be can be seen as somewhat dependent of a hardware constraints.",
            "So the question is and.",
            "What what, what, what?",
            "What becomes the interest of your work if the if the if the hardware constraint does not exist no more.",
            "So I think the the the response to this is that as we can see that using this constraint you you can create some new an interesting algorithms that what we have seen here.",
            "OK, so let's thank you again.",
            "Our thank you."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, so my name is Alton Mason airline Flare Searcher from and start Paris and well let me introduce the first talk of this of this session.",
                    "label": 0
                },
                {
                    "sent": "That would be done by a tattoo as I know the name of the speech is constant working space algorithm for image processing.",
                    "label": 0
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "Does he use the microphone?",
                    "label": 0
                },
                {
                    "sent": "I want to thank organize out this conference to invited me to this wonderful workshop.",
                    "label": 0
                },
                {
                    "sent": "Today I'm going to talk about the constant walking space algorithm for image processing, and this is a joint work with Lydia Mzero and Sarah Gable Egg and David Cap Patrick.",
                    "label": 1
                },
                {
                    "sent": "OK so.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "In this talk, my computation model is somewhat strange becausw, you know input data are given on readonly array, so we can read input data, but we can't write anything on input array.",
                    "label": 1
                },
                {
                    "sent": "OK, it is just read only and on and we are allowed to use only constant number of variables or constant number of working storage service and.",
                    "label": 0
                },
                {
                    "sent": "And each walking store itself is of Logan bit and N is a number of.",
                    "label": 1
                },
                {
                    "sent": "Input.",
                    "label": 0
                },
                {
                    "sent": "Input any is an input size OK and and each working storage so.",
                    "label": 0
                },
                {
                    "sent": "And have a order of Logan bids.",
                    "label": 1
                },
                {
                    "sent": "And so the total loggings storage sizes also order of log N OK, so this is a very restricted model and this kind of program was known.",
                    "label": 0
                },
                {
                    "sent": "Under the different name, which is logspace in complexity theory, an but the.",
                    "label": 0
                },
                {
                    "sent": "The people in complexity theory or interest is only on you know whether the program is belong to low space or not.",
                    "label": 0
                },
                {
                    "sent": "They are not so interested in.",
                    "label": 0
                },
                {
                    "sent": "Efficiency of algorithms.",
                    "label": 1
                },
                {
                    "sent": "So since I am, I mean I'm working in algorithms, so I'm interested in.",
                    "label": 0
                },
                {
                    "sent": "Patient algorithm to develop efficient algorithms.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And the people ask me why you are interested in such a restricted model now.",
                    "label": 0
                },
                {
                    "sent": "First of all, I hate.",
                    "label": 0
                },
                {
                    "sent": "I forgot my operating system.",
                    "label": 0
                },
                {
                    "sent": "The next operating system of XP Vista I. I don't like this to be 'cause it's you know it's required me say 2 gigabytes in main memory, what?",
                    "label": 0
                },
                {
                    "sent": "2 gigabytes?",
                    "label": 0
                },
                {
                    "sent": "When I was a college student.",
                    "label": 0
                },
                {
                    "sent": "Memory was so expensive and so I can't imagine now why they need 2 gigabyte memory in and they they use very.",
                    "label": 0
                },
                {
                    "sent": "Space inefficient algorithms are for Vista and I so because of that I don't like Vista and my operating system is 2 XP.",
                    "label": 0
                },
                {
                    "sent": "Anyway, so and other than that there are many, you know.",
                    "label": 0
                },
                {
                    "sent": "How do words which contains some softwares they are called embedded software nowadays desire.",
                    "label": 0
                },
                {
                    "sent": "Camilla has a very sophisticated you know software.",
                    "label": 0
                },
                {
                    "sent": "These are camera has very sophisticated programs in it and in those applications.",
                    "label": 0
                },
                {
                    "sent": "Maybe The Walking space is very expensive and the rocking storage is should be remitted.",
                    "label": 0
                },
                {
                    "sent": "And in some application we want to keep input data as unchanged so that input data should be treated as read only memory read only array and in that respect recursion.",
                    "label": 1
                },
                {
                    "sent": "We have to think about recursion.",
                    "label": 1
                },
                {
                    "sent": "Becausw working storage is proportional to recursion depth.",
                    "label": 0
                },
                {
                    "sent": "So for example if we implement, say, quicksort, we need, say at least Logan recursion depth and so that means we need Logan working space.",
                    "label": 0
                },
                {
                    "sent": "So if we are allowed to use Rogan space, then we can implement quicksort recursive quicksort, but otherwise.",
                    "label": 0
                },
                {
                    "sent": "We need to have some control on the recursion depth, so sometimes I call it controlled recursion because recursion depth should be controlled.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, So what is known today?",
                    "label": 1
                },
                {
                    "sent": "Well, the first maybe the first important result is given by Young Monroe and Rama, his student Roman, and the problem is medium finding.",
                    "label": 0
                },
                {
                    "sent": "So given readonly array containing elements we want to find the median of that and how far is can we do that can find median using only constant number of variables.",
                    "label": 1
                },
                {
                    "sent": "So that is the first one.",
                    "label": 1
                },
                {
                    "sent": "And the second one is is a big breakthrough in this in Logspace theory.",
                    "label": 1
                },
                {
                    "sent": "Our community, so that is called the St connectivity in graphs, so we are given undirected graph on using readonly array and also we are given two vertices S&T and.",
                    "label": 0
                },
                {
                    "sent": "The problem is to determine whether they are connected or not.",
                    "label": 0
                },
                {
                    "sent": "They are connected by a path or not and it is easy problem if we can use.",
                    "label": 0
                },
                {
                    "sent": "Order in, you know locking storage.",
                    "label": 0
                },
                {
                    "sent": "But what happened if we have only constant number of working storage?",
                    "label": 0
                },
                {
                    "sent": "And the third one is related to image processing.",
                    "label": 0
                },
                {
                    "sent": "And I I don't know how to pronounce his name and so I just avoid to pronounce his name, but so he they consider the similar problem.",
                    "label": 1
                },
                {
                    "sent": "It is called St connectivity image or binary image.",
                    "label": 0
                },
                {
                    "sent": "OK so in this case we are given a binary image consisting of zero and ones and also we are given 2 pictures OK. Run Barry, Run and then we ask whether there is path connecting them or not.",
                    "label": 0
                },
                {
                    "sent": "And all these problems are solved in the positive.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Way and so to have on this.",
                    "label": 0
                },
                {
                    "sent": "Rough image image you can emerge in some SD connectivity in the maze in the maze.",
                    "label": 0
                },
                {
                    "sent": "OK, so you can go through this white part and the two cells is and T are specified in.",
                    "label": 0
                },
                {
                    "sent": "The question is whether you can find path.",
                    "label": 0
                },
                {
                    "sent": "Only going through the white part and and maybe you know that we can check it by using so-called right hand rule.",
                    "label": 0
                },
                {
                    "sent": "If you keep going by touching the wall by right hand then you can you can reach T. In this case.",
                    "label": 0
                },
                {
                    "sent": "Happy.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "But if we remove these walls and then we have a hole here.",
                    "label": 0
                },
                {
                    "sent": "And the if the target is attached to the whole, then right hand rule doesn't apply.",
                    "label": 0
                },
                {
                    "sent": "We can't find the path on the by using the right hand rule.",
                    "label": 0
                },
                {
                    "sent": "So we need some other.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Technique.",
                    "label": 0
                },
                {
                    "sent": "So in this case.",
                    "label": 0
                },
                {
                    "sent": "It cannot be checked by the right hand.",
                    "label": 1
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, So what about connectivity in in a graph?",
                    "label": 1
                },
                {
                    "sent": "So we are given such a undirected graph and S&T are specified and we ask whether there is an pass or not.",
                    "label": 0
                },
                {
                    "sent": "And the important thing is graph is given.",
                    "label": 1
                },
                {
                    "sent": "Using our reason re RA so we can't put any mark on abatix OK and so it is hard but.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "But in 90.",
                    "label": 0
                },
                {
                    "sent": "1996 I forgot or not.",
                    "label": 0
                },
                {
                    "sent": "2002 Wrangled solve this problem and he gave a polynomial time algorithm for checking whether there is constant.",
                    "label": 0
                },
                {
                    "sent": "There is a path or not, using only constant amount of memory.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Oh, and here is a SD connectivity in binary image so that we are given a binary image and and two pixels S&T are given and we are.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Ask whether there is a path like this or not, and.",
                    "label": 0
                },
                {
                    "sent": "Very Fortunately there is linear time algorithm for finding this.",
                    "label": 0
                },
                {
                    "sent": "This kind of path linear in the number of pixels using only constant number of variables.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Alright, So what about median finding?",
                    "label": 0
                },
                {
                    "sent": "This is a very famous album program in Algorithms, so we are given number of data and we want if we sort them then the the element in the middle is called a million and we want to find such an element.",
                    "label": 0
                },
                {
                    "sent": "And of course if we we can use working space then.",
                    "label": 0
                },
                {
                    "sent": "We can use linear time algorithms based on influence such and it's runs in linear time, is greater result and but how fast can we find the median in in our computation computation model using only constant number of variables and can we still compute the median in dinner time or does it take in Logan time or?",
                    "label": 1
                },
                {
                    "sent": "Or maybe fix credited time might be lower bound.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "So for this program I will show you how to solve it in subquadratic time.",
                    "label": 0
                },
                {
                    "sent": "And so first of all we given readonly array of size NI, partition it into blocks.",
                    "label": 0
                },
                {
                    "sent": "Each block has ranks are square root of N OK and for each block I compute block median.",
                    "label": 0
                },
                {
                    "sent": "By implementing a brute force algorithms.",
                    "label": 0
                },
                {
                    "sent": "OK brute force means I compute the smallest one and the second smallest one, the smallest one and fine until we find a million OK, block, median and so it is a quadratic time algorithm.",
                    "label": 0
                },
                {
                    "sent": "But since it contains only square root of an element, so it runs in order and time and we have square root of N blocks so that in total it takes N sqrt N. Time OK, in that time we can compute the block millions square root of benbrook medians OK and then.",
                    "label": 0
                },
                {
                    "sent": "The important thing is that whenever we compute the block median, I scan the whole array to count the number of elements, which is smaller than that block median.",
                    "label": 0
                },
                {
                    "sent": "OK, so by doing that I can.",
                    "label": 0
                },
                {
                    "sent": "I can estimate I can.",
                    "label": 0
                },
                {
                    "sent": "I know how many element is smaller than that.",
                    "label": 0
                },
                {
                    "sent": "That is the rank of that element and I keep the best one.",
                    "label": 0
                },
                {
                    "sent": "And using that, I pruned the the element OK. And so the I I have to iterate it at most Logan time.",
                    "label": 0
                },
                {
                    "sent": "So the total running time is N sqrt N times log NK.",
                    "label": 0
                },
                {
                    "sent": "So that is subquadratic.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But using that we can design another algorithm called A3 which partition the array into into the 1/3 instead of square root of NK.",
                    "label": 1
                },
                {
                    "sent": "And and then we apply the the previous algorithm A2 to find the block medium, and then it's runs in into the 4th OD.",
                    "label": 0
                },
                {
                    "sent": "And keep going and I design that is OK, and which part is in the RN to enter the long run over K and it runs in this time bound.",
                    "label": 0
                },
                {
                    "sent": "It is almost linear.",
                    "label": 0
                },
                {
                    "sent": "It is end to the 1 + 1 / K. OK, so if K is great large then it is almost N. So, so this is a conclusion that if we can use order K working space, then the arrogant rounding into the 1 + 1 / K. Some look block factor or you can forget about log factor.",
                    "label": 0
                },
                {
                    "sent": "Alright, so it is we can solve the media problem almost in linear time.",
                    "label": 0
                },
                {
                    "sent": "OK that's very good result.",
                    "label": 0
                },
                {
                    "sent": "Unfortunately.",
                    "label": 0
                },
                {
                    "sent": "I had this algorithms and I wrote up the paper and I look at references and I found young moon Rose and Romans papers and which is exactly the same and.",
                    "label": 0
                },
                {
                    "sent": "Very unfortunate, yeah.",
                    "label": 0
                },
                {
                    "sent": "It's this kind of thing happens many times in our life.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Anyway.",
                    "label": 0
                },
                {
                    "sent": "Alright, so I want to.",
                    "label": 0
                },
                {
                    "sent": "In this talk I want to talk about application to image processing.",
                    "label": 1
                },
                {
                    "sent": "The first one is the thresholding.",
                    "label": 0
                },
                {
                    "sent": "This is my one of my most favorite topics in image processing because it is very simple and so the problem is that given such an intensity image, we want to find an optimal threshold to have a binary image which looks very nice and so in this particular example.",
                    "label": 0
                },
                {
                    "sent": "You know people if we have a threshold, say 100, then we have this binary image and maybe this is too low, so maybe we should try our larger value as a threshold and then we have different parts different binary image.",
                    "label": 0
                },
                {
                    "sent": "So every time we we set threshold we have a binary image OK and then we evaluate resulting binary image and if it is good then we.",
                    "label": 0
                },
                {
                    "sent": "Take that threshold.",
                    "label": 0
                },
                {
                    "sent": "OK, so that that is.",
                    "label": 0
                },
                {
                    "sent": "Approach.",
                    "label": 0
                },
                {
                    "sent": "And in this particular case, the input image.",
                    "label": 1
                },
                {
                    "sent": "This interesting image should be treated as a read only array and also to evaluate the binary image.",
                    "label": 1
                },
                {
                    "sent": "That binary image also should be treated as a read only array.",
                    "label": 0
                },
                {
                    "sent": "We can't write any information to the binary image.",
                    "label": 0
                },
                {
                    "sent": "OK, so the problem is how to find such a.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Ice threshold.",
                    "label": 0
                },
                {
                    "sent": "And so the if we look at any textbook on image processing, then they say that, OK, you should compute histogram and then if you can find the two mountains and Barretts then you are fine and you just take the Barry Barry as a threshold.",
                    "label": 0
                },
                {
                    "sent": "But in some case there is no, you know, Mount two mountains and in that case what can we do?",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And so you know, we can find a good binary image experimentally, but it's not.",
                    "label": 1
                },
                {
                    "sent": "There is no good.",
                    "label": 0
                },
                {
                    "sent": "It is not a good algorithm.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So, but unfortunately there is very nice algorithms proposed by some Japanese boots.",
                    "label": 0
                },
                {
                    "sent": "I've never met him before, but his I know him very well.",
                    "label": 0
                },
                {
                    "sent": "Yeah, so the in his algorithms you know he considered the histogram as.",
                    "label": 0
                },
                {
                    "sent": "So he want to divide, give an extra sword into two classes at zero, and this one is 0 is is this class and this one is the right class and he want to.",
                    "label": 1
                },
                {
                    "sent": "Maximize the intercluster distance and this kind of approach is called discriminant analysis.",
                    "label": 1
                },
                {
                    "sent": "Maybe you're very familiar with that.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "Roughly speaking, it's we have to compute average intensity level for the whole image and for the Class S0 and for the Class S1.",
                    "label": 1
                },
                {
                    "sent": "And we take the differences squared.",
                    "label": 0
                },
                {
                    "sent": "This difference is that is that is.",
                    "label": 0
                },
                {
                    "sent": "That is an Inter cluster distance, so we want to maximize this disvalue and this Inter cluster distance is defined for each threshold value T. So.",
                    "label": 0
                },
                {
                    "sent": "And it is not so difficult to compute such a such.",
                    "label": 0
                },
                {
                    "sent": "Operates, but intensity values, so the naive algorithm is that for each intensity image we compute this Inter cluster distance and take the maximum.",
                    "label": 0
                },
                {
                    "sent": "That it, and it's it's runs in linear time in the number of brightness levels.",
                    "label": 1
                },
                {
                    "sent": "OK, sorry it is very.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Efficient and so.",
                    "label": 0
                },
                {
                    "sent": "You know if if we have.",
                    "label": 0
                },
                {
                    "sent": "Image containing N pixels and with L different intensity levels, then we can compute the optimal threshold in order of N + L type.",
                    "label": 1
                },
                {
                    "sent": "OK, that's very easy and.",
                    "label": 0
                },
                {
                    "sent": "Because of time I will skip.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "This detail, but.",
                    "label": 0
                },
                {
                    "sent": "And what about the case where we only used?",
                    "label": 0
                },
                {
                    "sent": "We can only use a constant number of variables.",
                    "label": 0
                },
                {
                    "sent": "In that case, we can't compute that distance for each intensity variables.",
                    "label": 0
                },
                {
                    "sent": "OK, so instead we use.",
                    "label": 0
                },
                {
                    "sent": "We have to use some kind of binary search.",
                    "label": 0
                },
                {
                    "sent": "OK, so given some threshold T then I can compare that.",
                    "label": 0
                },
                {
                    "sent": "So this is, you know.",
                    "label": 0
                },
                {
                    "sent": "Convert the third space is convex so that we can.",
                    "label": 0
                },
                {
                    "sent": "We can apply the binary search and so whenever we are given some threshold, we can compare that this is good enough or not in so because of that we can compute the optimal search.",
                    "label": 0
                },
                {
                    "sent": "Odin enrolled time.",
                    "label": 0
                },
                {
                    "sent": "Using only constant working space.",
                    "label": 1
                },
                {
                    "sent": "And.",
                    "label": 0
                },
                {
                    "sent": "So the binary search works only when intense levels are given by integers one through NL OK, but sometimes we have a range data.",
                    "label": 1
                },
                {
                    "sent": "I mean, I'm not so familiar in such data, but we can use some special camera which measure the distance from that camera to the object.",
                    "label": 0
                },
                {
                    "sent": "OK, and in that case the.",
                    "label": 0
                },
                {
                    "sent": "Values are not intensity level, but distances, so distances can be arbitrary variables.",
                    "label": 0
                },
                {
                    "sent": "And so in that case, the you know the such a value input value are not integers and not be integers.",
                    "label": 0
                },
                {
                    "sent": "And in that case, maybe we can use.",
                    "label": 0
                },
                {
                    "sent": "Video on finding algorithm instead of also.",
                    "label": 0
                },
                {
                    "sent": "Algorithms?",
                    "label": 0
                },
                {
                    "sent": "But it's runs in almost.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "That time.",
                    "label": 0
                },
                {
                    "sent": "So here is some example of the outputs of when we applied auto method.",
                    "label": 0
                },
                {
                    "sent": "It still looks quite good.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so the next next one is maybe I will see.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Keep it.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So next program is how how to count the connected component in binary image.",
                    "label": 0
                },
                {
                    "sent": "So we are given such a binary image and we can define connected components in the following way to one pixels or white pixels are connected if there is rectilinear sequence of 1 pixel between them and a connected component is a maximal set of 1 pixels.",
                    "label": 1
                },
                {
                    "sent": "Any two of which are connected.",
                    "label": 0
                },
                {
                    "sent": "So in this particular example, we have the one connected component here and the second connected component here and 3rd one and false one ends.",
                    "label": 0
                },
                {
                    "sent": "So the problem is, given such a binary image as as a readonly array.",
                    "label": 0
                },
                {
                    "sent": "We are requested to count the number of connected component using only constant number of variables and.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Can we do this?",
                    "label": 0
                },
                {
                    "sent": "Yes and.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "So the key for the counting is is to follow the boundary.",
                    "label": 0
                },
                {
                    "sent": "But there are there are two different kinds of boundaries.",
                    "label": 0
                },
                {
                    "sent": "One is the external boundary of our connected component and the other one is internal boundary of the connected component so.",
                    "label": 0
                },
                {
                    "sent": "So you know, in this particular example, this green part is connected component, and so this green roof line indicate external boundary OK, and.",
                    "label": 0
                },
                {
                    "sent": "I Orient them so that the inside of the connected components always lied to the left.",
                    "label": 1
                },
                {
                    "sent": "OK, so in that orientation the external boundary always oriented in the counterclockwise, say, and the internal one is oriented in Crookwell.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The order OK, and for each such boundaries I defined a Canonical age that is lowest downward edge.",
                    "label": 1
                },
                {
                    "sent": "So in this boundary what is lowest downtown?",
                    "label": 0
                },
                {
                    "sent": "What age this?",
                    "label": 0
                },
                {
                    "sent": "Is it?",
                    "label": 0
                },
                {
                    "sent": "And this is the lowest downward edge on this internal boundary.",
                    "label": 1
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So for each boundary we have unique such khanolkar edge.",
                    "label": 1
                },
                {
                    "sent": "OK, so that is a key observation to count the number of components of.",
                    "label": 0
                },
                {
                    "sent": "Using constant number of variables.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So the.",
                    "label": 0
                },
                {
                    "sent": "And but to count the number of connected component that we we have to discard internal boundaries OK because each connected component has only one external boundary and so it suffices to count the number of external boundaries.",
                    "label": 0
                },
                {
                    "sent": "OK, so but so we have to distinguish internal boundaries and the external boundaries.",
                    "label": 0
                },
                {
                    "sent": "And that is very easy because once we find conquer AIDS.",
                    "label": 0
                },
                {
                    "sent": "Then the local structure is different in external and internal one because if we look at the lower right pixel then it is external 0 for external boundary and one internal boundary.",
                    "label": 1
                },
                {
                    "sent": "So it is quite easy to distinguish them and so the.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Our algorithms runs as follows.",
                    "label": 0
                },
                {
                    "sent": "Given such a binary image, we do raster scan and whenever we hit some boundary, some boundary edge, we traverse the boundary.",
                    "label": 1
                },
                {
                    "sent": "To confirm that that age is Cannon Carriage, that that means lowest down what age or not.",
                    "label": 0
                },
                {
                    "sent": "So if if I start from here then I can easily find a lower edge, so that if I start from here then I can easily.",
                    "label": 1
                },
                {
                    "sent": "You know, see that it is not a kernel carriage, and once I find a lower lower edge then I stop the thought.",
                    "label": 0
                },
                {
                    "sent": "OK this is not a common carriage and only when we start from the Canonical edge we have to go around the boundary, but that's fine.",
                    "label": 1
                },
                {
                    "sent": "That's fine 'cause it takes on the IT is only once.",
                    "label": 0
                },
                {
                    "sent": "And so to follow the boundary, we use this procedure.",
                    "label": 1
                },
                {
                    "sent": "So you know, we start from some edge ES and then we followed the next edge and next edge, and so until we find lower edge done ES or we find.",
                    "label": 0
                },
                {
                    "sent": "It sell itself.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, and so if we implement this algorithm naively, then it takes quadratic time.",
                    "label": 0
                },
                {
                    "sent": "Unfortunately becausw it every time we do this can and so in this particular example, if I start from this edge, then I have to go around.",
                    "label": 0
                },
                {
                    "sent": "Or the boundary.",
                    "label": 0
                },
                {
                    "sent": "And if I start from here then I have to go around.",
                    "label": 0
                },
                {
                    "sent": "You know this way, so it takes a quarter take time, but.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "If I use bidirectional result, so instead of searching in One Direction, but I search in two different directions, then we have a magic that it runs in Logan time.",
                    "label": 0
                },
                {
                    "sent": "That's that's very nice.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And so here is a worst case example which takes N squared logon time.",
                    "label": 0
                },
                {
                    "sent": "Alright.",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So and we can apply this kind of technique to rept the old rip order sizes of all components.",
                    "label": 1
                },
                {
                    "sent": "OK, so the given a binary image may contain several different many different connected components.",
                    "label": 1
                },
                {
                    "sent": "So we want to compute the area of each connected component on by 1.",
                    "label": 0
                },
                {
                    "sent": "Without any duplication, and how fast can we do this?",
                    "label": 1
                },
                {
                    "sent": "And so in this particular example output should should look like this component one contains 21 pixels and component two contains 3 three pixels and so on.",
                    "label": 0
                },
                {
                    "sent": "OK, how fast can we do this moderately weekend?",
                    "label": 1
                },
                {
                    "sent": "We can do this in in logon time, where N is the number of pixels.",
                    "label": 0
                },
                {
                    "sent": "So it's quite a.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Efficient.",
                    "label": 0
                },
                {
                    "sent": "So also in this particular example we have N by N image so that it takes N squared logon time, but it is almost dead.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Yeah, and the last example is this pattern matching.",
                    "label": 1
                },
                {
                    "sent": "We are given two binary images, one indicate patent and the other one is is like a text image and the question is how many copies are included included in text image.",
                    "label": 1
                },
                {
                    "sent": "How many times the pattern image occurs in in in the second image OK?",
                    "label": 0
                },
                {
                    "sent": "How fast can we do this?",
                    "label": 0
                },
                {
                    "sent": "And the binary image consists of N by N or in total N pixels or and surprisingly we can do it in an organ time.",
                    "label": 0
                },
                {
                    "sent": "That's.",
                    "label": 0
                },
                {
                    "sent": "It is surprising to me at least me and.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So I will skip the detailed.",
                    "label": 0
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Of.",
                    "label": 0
                }
            ]
        },
        "clip_39": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "It's.",
                    "label": 0
                },
                {
                    "sent": "But believe me, it runs in northern time.",
                    "label": 0
                }
            ]
        },
        "clip_40": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And so, here is a conclusion.",
                    "label": 0
                },
                {
                    "sent": "And so I want to extend our algorithm for geometric problems such as a planar subdivision or graphs.",
                    "label": 1
                },
                {
                    "sent": "Or I want to establish that some nonlinear lower bounds on the time complexity for constant working space algorithms.",
                    "label": 1
                },
                {
                    "sent": "So far I haven't succeeded yet.",
                    "label": 0
                },
                {
                    "sent": "No, no result at all for lower bounds.",
                    "label": 0
                },
                {
                    "sent": "Yeah.",
                    "label": 0
                }
            ]
        },
        "clip_41": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Maybe I will stop here.",
                    "label": 0
                },
                {
                    "sent": "Thank you very much.",
                    "label": 0
                },
                {
                    "sent": "Do you hear me?",
                    "label": 0
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "Thank you for your presentation.",
                    "label": 1
                },
                {
                    "sent": "Is there any question in the audience?",
                    "label": 0
                },
                {
                    "sent": "Thank you, I found very nice your algorithm in your explanation examples and concerning the second example, the one where you compute the connected component of our brand image.",
                    "label": 0
                },
                {
                    "sent": "I wonder whether you can apply this approach to compute connected computing graph.",
                    "label": 0
                },
                {
                    "sent": "For example, in some special case like paragraph.",
                    "label": 0
                },
                {
                    "sent": "Do you think that is?",
                    "label": 0
                }
            ]
        },
        "clip_42": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "As well so.",
                    "label": 0
                },
                {
                    "sent": "This case is a special case of burgraff program, because in in a graph program.",
                    "label": 0
                },
                {
                    "sent": "No, some brodix has degree more than two.",
                    "label": 0
                },
                {
                    "sent": "But in this in this binary image case we can reduce the problem to graph programs in which every product has degree 2.",
                    "label": 0
                },
                {
                    "sent": "So it is a degree two graph is that kind of degree two graphs.",
                    "label": 0
                },
                {
                    "sent": "That's why everything is so easy.",
                    "label": 0
                },
                {
                    "sent": "Anne.",
                    "label": 0
                },
                {
                    "sent": "Yeah so.",
                    "label": 0
                },
                {
                    "sent": "I think we can extend the algorithm to cleaner case for planar graph.",
                    "label": 0
                },
                {
                    "sent": "Because yeah, but under the condition that planar graph is given embedded using, say W connected as wrist so that we can follow the boundary.",
                    "label": 0
                },
                {
                    "sent": "In All India time in the length of the process and otherwise, if the input graph is is given in general form, we have nothing to do.",
                    "label": 0
                },
                {
                    "sent": "Beautiful constant constant because of the encoding of the graph.",
                    "label": 0
                },
                {
                    "sent": "Yeah yeah.",
                    "label": 0
                },
                {
                    "sent": "OK, thank you.",
                    "label": 0
                },
                {
                    "sent": "Thank you other question in the audience.",
                    "label": 0
                },
                {
                    "sent": "No OK, I just have a few comments and questions 'cause you know, minimizing the space complexity.",
                    "label": 0
                },
                {
                    "sent": "There's memory complexity is important in embedded processing in general, not only because of the constraint insert, but also because you know the the the time that memory access.",
                    "label": 0
                },
                {
                    "sent": "Yeah, is is more important than the the computation itself, so.",
                    "label": 0
                },
                {
                    "sent": "We have also other constraints the that make that you don't have.",
                    "label": 0
                },
                {
                    "sent": "Not you you.",
                    "label": 0
                },
                {
                    "sent": "Sometimes you you need not only to minimize the memory access, but to make such that the computation is meant between 2 two part of memories that are closed.",
                    "label": 0
                },
                {
                    "sent": "You know in the in the in the memory itself.",
                    "label": 0
                },
                {
                    "sent": "So for example when you when you compute the median when you have, when you compute the sort, when you make the sort in the in every block, sometimes it's better, for example to make a bubble sort.",
                    "label": 0
                },
                {
                    "sent": "Haha than than than a brute force sort because the bubble sort is always make always the computation between between 2 two adjacent pixels.",
                    "label": 0
                },
                {
                    "sent": "So have you any?",
                    "label": 0
                },
                {
                    "sent": "Extension if you work in the in that problem or not yet.",
                    "label": 0
                },
                {
                    "sent": "Not yet, yeah, but yeah it is a good point.",
                    "label": 0
                },
                {
                    "sent": "I will think about it, yeah.",
                    "label": 0
                },
                {
                    "sent": "But I have no no.",
                    "label": 0
                },
                {
                    "sent": "I have never considered that kind of direction.",
                    "label": 0
                },
                {
                    "sent": "So right now I have no, it's OK, OK, OK?",
                    "label": 0
                },
                {
                    "sent": "I meant that I can do in the.",
                    "label": 0
                },
                {
                    "sent": "In general is that you know that we can see that you work.",
                    "label": 0
                },
                {
                    "sent": "It can be can be seen as somewhat dependent of a hardware constraints.",
                    "label": 0
                },
                {
                    "sent": "So the question is and.",
                    "label": 0
                },
                {
                    "sent": "What what, what, what?",
                    "label": 0
                },
                {
                    "sent": "What becomes the interest of your work if the if the if the hardware constraint does not exist no more.",
                    "label": 0
                },
                {
                    "sent": "So I think the the the response to this is that as we can see that using this constraint you you can create some new an interesting algorithms that what we have seen here.",
                    "label": 0
                },
                {
                    "sent": "OK, so let's thank you again.",
                    "label": 0
                },
                {
                    "sent": "Our thank you.",
                    "label": 0
                }
            ]
        }
    }
}