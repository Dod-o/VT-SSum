{
    "id": "igx2t7uku2gu63jtcqgar475nm7z42tm",
    "title": "Improved Software Fault Detection with Graph Mining",
    "info": {
        "author": [
            "Frank Eichinger, Institute for Program Structures and Data Organization (IPD), University of Karlsruhe"
        ],
        "published": "Aug. 25, 2008",
        "recorded": "July 2008",
        "category": [
            "Top->Computer Science->Network Analysis"
        ]
    },
    "url": "http://videolectures.net/mlg08_eichinger_isfd/",
    "segmentation": [
        [
            "OK, welcome to my talk.",
            "I'm going to talk about improved software fault detection so it's about localising bugs in software.",
            "And of course I'm going to present a graph mining based approach today."
        ],
        [
            "The motivation is pretty simple.",
            "As you probably all know, software is almost never shipped back free, so even if you are testing extensively there usually some bucks remaining in the software business shipped to the customer, and well, obviously such bugs are encouraged huge costs which you would like to try to avoid.",
            "Well, there are two classes of bugs which are particularly challenging which are non crashing box to box which produce faulty results but they don't crash so they don't crash.",
            "You don't have a spec tray so you don't have any hint.",
            "There's a bucket hidden in your software project and there's another challenging class of bugs which are occasional bugs that are bucks which don't occur always, always, but only with certain kinds of.",
            "Input data combinations.",
            "Well and as they are not always occurring there obviously hard to reproduce and so they are also hard to find.",
            "Well, in the software, developing companies are usually some resources available for testing the software, but as software projects are usually large and always getting bigger, you are not having enough development resources for testing or testing your whole project and for doing a complete code review of your project.",
            "So the idea?"
        ],
        [
            "There is and was.",
            "This idea is not you.",
            "The idea is to locate such non crashing occasional box with data mining techniques.",
            "And as we are on the graph mining workshop, I'm obviously going to present you a rough mining based approach well and also graph mining in software engineering is not new.",
            "So what I'm going to present you as a approach which is making use of weighted graphs with a graph mining algorithm."
        ],
        [
            "OK, that's the outline of my talk.",
            "At first I do a short review of data mining and software engineering about techniques which have been used so far.",
            "Well, traditional data mining approaches, and also as a graph based approach.",
            "Before I come to our weighted call graph mining approach.",
            "After that I am going to present you some result and I can't."
        ],
        [
            "Mike talk.",
            "OK, as you all know, traditional data mining techniques like decision trees, neural networks or whatever they're using with a feature.",
            "Vectors of numerical or categorical values and how can you fit data from software engineering into such such a framework.",
            "While it's possible to use like different kind of source code matrix which would be statical analyzers.",
            "Or you can also instrument your software in order to just dump some some data during the program execution.",
            "I been doing dynamic analyzers well and these values like so different kind of code matrix.",
            "Can you put into such a table and was there a number of software artifacts, for example methods or classes of files or whatever in the rows and columns.",
            "Every such method for example is described by a number of metrics.",
            "Well and at the end you're searching for patterns of certain properties in.",
            "In such a table.",
            "And you are searching for patterns which are more likely in buggy software than in correct software."
        ],
        [
            "But unfortunately there are some challenging challenges with such an approach.",
            "Um?",
            "Well the first static analyzers you're having some problems that even if you are having like hundreds of metrics, even if you if you derive every possible metric from a piece of source code, these metrics are usually not enough to describe certain piece of software completely.",
            "So there are still some information lose loss.",
            "Well, and the other thing is, even if you derive some interesting information like, well, software is always buggy.",
            "If some metric value is increased, for example, if there are no comments in this in the source code than the software tends to be buggy or something like that.",
            "Such information doesn't really help you too.",
            "To locate the back to say, well, the back is exactly in this method and that's what we want to do.",
            "OK.",
            "There are also some shortcomings with dynamic analyzers, so if you do instrumentation, there's always a tradeoff between the runtime of the program.",
            "Well, if you want to collect a lot of runtime information needs to a lot of time and also possibly producing huge amounts of data which is quite hard to analyze afterwards."
        ],
        [
            "So what we are proposing or but already has been proposed from the graph mining community somehow is looking at program executions and which are represented as a dynamic call graph, and then if you're considering such call graphs, you can analyze its structure and try to find some interesting patterns within such call graphs.",
            "Well, but I want to mention is that such an approach of.",
            "Analyzing program executions is autogena to other approaches which have been proposed in the software engineering community.",
            "So it can be seen as an additional technique.",
            "OK, what can we do when analyzing call graphs?",
            "You usually try to identify substructures which are typical for faulty executions.",
            "And in order to do such kind of discriminative mining, you usually require a test Oracle.",
            "So you have to decide which program execution was good one, which was a bad one basically.",
            "So which program execution was back free?",
            "Which program execution lead to like faulty results?",
            "OK.",
            "The analyzers of call graphs of data mining case with graph mining techniques is not new, but what is new in my talk is the analyzes of call frequencies and call frequencies can be.",
            "Can be.",
            "Can be displayed in a call graph with different kinds of edge weights, and that's what I'm going to."
        ],
        [
            "Show to you on the next slide.",
            "OK I was talking bout call graphs before.",
            "Just some basic information what what is called graphic Wall graph is Rockwall graph.",
            "As you derive it from the program, execution is a rooted order tree.",
            "So this node a here would be a main method which is first calling method B then is calling method C and within method sees as a possibly a loop and this loop is in this case calling method B three times in a row.",
            "OK, well obviously also methods or functions or whatever that are the nodes of such a graph and the edges symbolize the message call of another method.",
            "OK, now the question is how is it possible to to find the back in such a graph?"
        ],
        [
            "One possibility is that they are structure affecting box.",
            "For example, if we're having in system method A.",
            "If we're having an if condition, is this method which is somehow buggy, so that leads to the fact that this.",
            "Method B might be called or might not be called.",
            "So if there's a back in this if condition, it might happen that there's just no node be called from node A, which leads to a different shape of the structure from such a call graph.",
            "And what I want to mention that this kind of structure affecting back is a kind of bug which can be located with existing approaches already, but."
        ],
        [
            "There's another quite common kind of bug which I call call frequency affecting Buck.",
            "That's a bug, for example, in the loop condition within Method C. So back in the loop condition in method C might lead to like an increased number of executions of methods within this loop.",
            "If there is a bucket, this is this condition.",
            "So for example, in buggy executions you would always have like 300 method calls instead of like 3 method calls in this correct execution here."
        ],
        [
            "OK, in order to in order to do graph mining with call graphs, we are faced with some problems concerning the size of such call graphs.",
            "So here we are having here we're having a tiny little piece of real call graph from a Java program and as you can imagine.",
            "About and modern software, there are many loops used, so let's say it's a loop in this.",
            "In this method here there are other methods and other substructures called repeatedly, and there are very many repetitions.",
            "So and this leads to the fact that millions of methods called within one call graph is quite a common case.",
            "Well, and as you all probably know, it's not a good idea to feed such graphs with millions of nodes to a state of the art.",
            "Frequent subgraph mining algorithm.",
            "So we need to do something with the size of the graph."
        ],
        [
            "Well, and that's what we heard from the.",
            "I think the second talk yesterday.",
            "If we are having large graphs, you have to try to reduce them somehow and you should try to keep the most important properties.",
            "Yesterday the most important property was saying something about the degree distribution of the graphs.",
            "Here in Fort localization it's quite important to.",
            "To keep in mind that the structure of the graph is not changing too much, meaning which method is calling which other method and not just which measures is cording which method.",
            "Also which method is calling which other method in which context.",
            "So it makes a difference if, for example, Note B is called here from C or if node B is called here from A or at some other point inside this graph.",
            "OK, how can we reduce such a call graph?",
            "That's a Rockwall I introduced to you before.",
            "Very common cases to do this kind of reduction, which I call a total reduction.",
            "Here we take every node with the same label and merge to one note here.",
            "So that leads to a cyclic graph.",
            "But well, what you might realize is that the structure of this graph, which I said is important for back localization.",
            "If it's changed pretty much, then going when doing this kind of reduction so so we're losing quite a lot of information about the structure of such a call graph.",
            "Well, there have been some other ways of reducing graphs proposed in the literature.",
            "What all these reductions are pretty much the same.",
            "What we're doing now, which is well.",
            "It's quite surprisingly that nobody else has done it before, but what we're doing is is easy possibility just to introduce edge weights.",
            "So when you look at this graph, method B is called three times in a row.",
            "We just put here, we put here in edge rate while maybe you're asking yourself why nobody has done such an easy kind of reduction.",
            "It keeps the graph pretty small while keeping most of the information.",
            "So in this particular case we can.",
            "It's lossless, so we can go from this graph back to the original graph.",
            "Why has nobody else wondered where the problem is?",
            "Like weighted graph mining has not been investigated a lot, so people prefer to do purely structural graph mining with such kind of graphs without any weights."
        ],
        [
            "OK, before I'm coming to our approach where I'm going to explain you how we make use of such edge weights, I just want to introduce you to.",
            "Somehow, the conventional approach for locating backs with graph mining techniques, which is the approach from default at all.",
            "OK, at 1st at first you need some input data into this input data is as I said before, a collection of call graphs which need to be classified as a correct execution or as a call graph representing a faulty execution.",
            "And well, if you have such a such collection of call graphs, we have to reduce them in order to search for frequent subgraphs, and that can be done with basically every frequent subgraph mining algorithm or.",
            "Depending on the reduction technique, use.",
            "If you are having trees you can also use a tree mining algorithm, but that doesn't really matter.",
            "OK then we are having these frequent patterns.",
            "This frequent subgraphs we can do the following.",
            "We can identify discriminative subgraphs.",
            "From and such discriminator subgraphs are subgraphs which are frequent within faulty, but multiple things are correct executions.",
            "And, well, the intuition of this step is that the methods which are the things Easter, discriminative subgraphs, they display an increased likelihood of being responsible for some buggy execution.",
            "Let's say intuition behind the whole approach.",
            "Well, and as I said before.",
            "This approach from the father is able to discover the kind of back which I called structural structure affecting back.",
            "So if there is a.",
            "Certain pattern in the structure, also called grass and faulty execution.",
            "This approach will discover this kind of structural pattern.",
            "And you can derive your information about which methods are most.",
            "Likely to contain the bar from these discriminative subgraphs."
        ],
        [
            "OK, I will shortly come to our approach before I'm going to explain our approach.",
            "Would like to review the approach from the fact I just explained to you and this approach is this approach which I marked red in this diagram.",
            "So just just again we're starting this call graph which reduced somehow.",
            "Then we do frequent subgraph mining and now we're looking onto this left branch.",
            "So we are considering discriminative subgraphs here.",
            "So subgraphs which are frequent in failing executions but not.",
            "A frequent incorrect executions.",
            "Phantom based on this kind of discriminator subgraphs.",
            "Yeah, the factor is doing something which I call here conventional scoring.",
            "So there's some scoring of the edges based on the frequency of the of the edges and so on.",
            "And this leads to ranking, which I call conventional ranking.",
            "And what this ranking basically says, well is the probability of this method is very high, so a software engineer should have a look onto this method in order to find the back.",
            "So that's that's the way the whole system works.",
            "OK, what we're do."
        ],
        [
            "I said I would like to look at edge weights and not just on the different kind of shapes or structure.",
            "We are not considering the graphs which are discriminate.",
            "If we're considering grass which are non discriminate.",
            "If so, in other words we are considering graphs which are in Kering in bills in failing and incorrect execution, so it's account of subgraphs we're working with.",
            "And this is these.",
            "These subgraphs we're doing some weight based scoring.",
            "That's fantastic.",
            "I'm going to introduce to you on the next slide.",
            "But before I'm going to do that, well, we get some some same kind of ranking from this bait based scoring."
        ],
        [
            "But what we're doing now is we're not using this conventional ranking over not using the intermediate ranking as the left approach.",
            "The conventional approach is able to discover this structure affecting box, and our approach is able to detect this.",
            "This frequency affecting box we're combining these these two kinds of evidence of evidence, and which leads to a combined ranking.",
            "OK, now it's a question.",
            "How do we?",
            "How do we make a ranking based on edge weights?"
        ],
        [
            "As I said, we are considering subgraphs which are frequent or which are occurring in those sets.",
            "So for every for every sub graph we are considering now we're having a passing examples and we're having tailing examples and that allows us to identify edge weights which most differentiate between these two classes.",
            "So that's the basic idea of what we're doing now and in order to do that.",
            "We're mapping we're mapping this graph mining problem to a feature selection problem and.",
            "To do so, we are first assembling such a table, which I'm going to explain to you right now.",
            "So in this table.",
            "Every edge in every frequent subgraph is considered, meaning we're having we're having in the roles were having the grass from our collection of glass, the original graph, and every such graph is assigned with a label with the class label.",
            "If it's a failing execution of, it's a correct execution.",
            "And then we have a huge number of columns and here we are having two columns for the sub graph number one.",
            "So the 1st first factor patrols found in.",
            "This is a frequent subgraph mining algorithm and within every subgraphs or within sub graph one we're having a number of edges.",
            "So here we're having one edge from node A to node B and one edge from node A to node C. And in the next next column we're having subgraph two and the edge from A to B, and then another edge in subgraph two and all the others have graph so that as the columns and in the in the cells of the table, we just put the average weight of the edges.",
            "So for example.",
            "The weight of the edge from A to B within sub graph, one in the first draft of our graph collect call graph collection has the weight 2, so that's a kind of paper reassembling and.",
            "Well, when we are having such kind of table, we can basically apply every kind of feature selection which is known from the literature.",
            "So we used we use standard information gain based or entropy based feature selection algorithm and applied it to this table which is resulting in a ranking of the of the columns.",
            "Or in other words, it's resulting in a ranking of of these edges.",
            "So at the end we know which.",
            "Rate of which edge is most discriminating between the two classes of class of correct in the class of failing program executions?"
        ],
        [
            "So how do our results look like?",
            "So that's just one example.",
            "Our Windows look pretty much like that, so we're having ranking of methods.",
            "We have a number of different method names and every method is assigned with a score and to score tells us the likelihood.",
            "How likely is it that the back or back is contained?",
            "For example, in this method, input scan?",
            "In this case this score is pretty high, so it's a value between zero and one which leads to.",
            "To the fact that this method is ranked top in this ranking.",
            "But not necessarily say that the back is really included in."
        ],
        [
            "This method, so in this case.",
            "The back was, I knew where the bug is in the back was included in this second method, so that's what happens frequently.",
            "But at the end, if you're giving such a list to a software developer as a software developer would start with the first method, he would just do a review of this method.",
            "He would probably not find a bug for then you would switch to the second method and there he would find the back.",
            "So it's a pretty good result of Buck is found in the 2nd row of this result table.",
            "OK, what you what you should remember for the evaluation on the next slide is that lower ninth line numbers are better, so it's best case would be if our method which identifies the correct Buck in line number one but line number two or three.",
            "Isn't that the result?"
        ],
        [
            "OK, no setting of our experiments.",
            "We used some open source Java tool which is containing 25 different methods and I instrumented instrumented these this tool with nine different kinds of bugs.",
            "The methods I instrumented, they are artificial.",
            "So I just changed some variable name names and so on, but I tried to do it realistic so I did some research on how other people did Sir evaluation on such kind of problems and they also from the software engineering community.",
            "There are some streets of Buck collections available, so I reviewed these suites and try to.",
            "Try to instrument the same kind of.",
            "The same kind of backs to this piece of software in order to have.",
            "Somehow realistic evaluation.",
            "OK everybody version, so I'm having nine buggy version was executed exactly 100 times with different kind of input data and at the end I assessed every execution if it was a good execution or bad execution.",
            "So I knew the expected result of every execution and so it was easy to decide if the result was buggy or so result was correct.",
            "OK, we're coming to to this table in this Taylor we're having into columns were having so nine different box I instrumented with the software and in the Rose we're having three different methods.",
            "The efforts of finding box that's the first method, which is this approach from the factor which is just looking at the structural differences, then there's this intermediate method, which is, which is our method which looks only at the edge weights and then.",
            "That's a combined method.",
            "Well, as as an example.",
            "As an example, this back number three was pretty easy to find.",
            "It was ranked top.",
            "The succulent conventional approach.",
            "It both ranked top with our approach, and while also the combination was ranked top.",
            "I would like to introduce it to two pretty interesting kinds of bugs, which is about two and back #9, so this minus here means that back two was not found with the conventional approach, and that's caused by the fact that back and #2 is a bug, which is typical.",
            "Typical frequency affecting back so, so this bug doesn't lead to any different kind of shape of the call graph, but it needs to.",
            "It leads to differences and.",
            "In the number of executions of a certain as a method or certain as a subtree, so it's easily found with with the intermediate approach and the good thing is that if you're combining these two of these two approaches, it's still found in the 2nd and the third line well, and the other way around.",
            "It's a back number 9 #9 is easily found with the structural approach, as it's a structural Buck, but there's no chance for the intermediate approach to.",
            "Find this kind of back as there are no edge weights which are different.",
            "OK altogether, if we look at the numbers.",
            "If you're comparing the conventional approach and the combined approach, leaving aside box 2 and 9 on average, the precision of the back localizations is increased by a factor of 2.4."
        ],
        [
            "OK, I'm coming to the end of my talk.",
            "I'd like to conclude with a short summary of what we've done.",
            "At first we proposed this new called graph reduction variant, and we identified this variant of being crucial to identify this type of quad frequency affecting bugs.",
            "OK then I. I'm.",
            "I presented a technique or combination of techniques for mining weighted graphs in this classification scenario, as a class of every graph, like failing or correct is known.",
            "And this is done by a combination of, like a structural structural technique, graph mining, or frequent subgraph mining, and a numerical technique which is a feature selection.",
            "And what we are claiming is that this kind of approach to analyze weighted graphs can be applied in other domains as well, so.",
            "Well, basically you can apply this kind of approach in every domain where we are having a weighted graph and where we have some information about weights of the edges.",
            "OK, most importantly to say is that in contrast to other approaches, we're not just considering discriminative subgraphs, but we're explicitly considering graphs which are not discriminate.",
            "If so, graph which occur in both classes, correct and failing executions as they would like to find the discriminant if edge weights.",
            "OK, in our field of application and software engineering this approach we are able to detect new important class of graphs.",
            "Which are these quality frequency affecting backs and we're having a double precision of back localizations in our well it's a small data set what?",
            "I showed quite a significant improve of this quality of localizations.",
            "OK, what's my current and future research?",
            "At first, light weight based constraints, so in this work we've done no combination of graph mining and analyzes of dates.",
            "In the future I'm trying to analyze the edge weights during the graph mining.",
            "During the graph mining process.",
            "So I'm trying to find some some useful constraints which are working with edge weights.",
            "OK there still this problem remaining that that call graphs are pretty large and it's quite hard to apply graph mining algorithms to such raw, so I'm also working on different kind of methods for doing more efficient compression or selection of some relevant parts of the graph.",
            "I'm also trying.",
            "I'm working on approximate graph mining algorithms, but that's future work as well as.",
            "The application of this technique and, as a related, techniques to other domains."
        ],
        [
            "That's it, thank you very much for your attention, and if you're having any questions, I'd like to try to answer them.",
            "Thank you.",
            "Can you go back to the slide where you have the feature selection?"
        ],
        [
            "Yes, so your simple example, it looks like you have only edges.",
            "Very simple graph which are reduced to edges.",
            "Are you actually considering larger subgraphs?",
            "Because if you do, how do you define the number for a larger, say, a triangle or whatever?",
            "Well, that's just a pretty small example, so here's a subgraph.",
            "One has two edges, but in general the graphs can have any size and I just make one.",
            "No, but my OK, sorry.",
            "My point is, how do you compute the value?",
            "What's the value inside your colon value inside the column is a average rate of the also edge in the certain sub graph.",
            "So I'm looking at sub graph one.",
            "In which graph subgraph one included?",
            "Then I'm looking at A to be within subgroup one, and then I then I calculate.",
            "Well, it might happen that subgraph oneness included at several places that is embedded several places in the graph #1 to 9.",
            "Calculating is the average of this edge from A to B in sub graph, one within graph one."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, welcome to my talk.",
                    "label": 0
                },
                {
                    "sent": "I'm going to talk about improved software fault detection so it's about localising bugs in software.",
                    "label": 1
                },
                {
                    "sent": "And of course I'm going to present a graph mining based approach today.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "The motivation is pretty simple.",
                    "label": 0
                },
                {
                    "sent": "As you probably all know, software is almost never shipped back free, so even if you are testing extensively there usually some bucks remaining in the software business shipped to the customer, and well, obviously such bugs are encouraged huge costs which you would like to try to avoid.",
                    "label": 1
                },
                {
                    "sent": "Well, there are two classes of bugs which are particularly challenging which are non crashing box to box which produce faulty results but they don't crash so they don't crash.",
                    "label": 0
                },
                {
                    "sent": "You don't have a spec tray so you don't have any hint.",
                    "label": 0
                },
                {
                    "sent": "There's a bucket hidden in your software project and there's another challenging class of bugs which are occasional bugs that are bucks which don't occur always, always, but only with certain kinds of.",
                    "label": 0
                },
                {
                    "sent": "Input data combinations.",
                    "label": 0
                },
                {
                    "sent": "Well and as they are not always occurring there obviously hard to reproduce and so they are also hard to find.",
                    "label": 1
                },
                {
                    "sent": "Well, in the software, developing companies are usually some resources available for testing the software, but as software projects are usually large and always getting bigger, you are not having enough development resources for testing or testing your whole project and for doing a complete code review of your project.",
                    "label": 0
                },
                {
                    "sent": "So the idea?",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "There is and was.",
                    "label": 0
                },
                {
                    "sent": "This idea is not you.",
                    "label": 0
                },
                {
                    "sent": "The idea is to locate such non crashing occasional box with data mining techniques.",
                    "label": 0
                },
                {
                    "sent": "And as we are on the graph mining workshop, I'm obviously going to present you a rough mining based approach well and also graph mining in software engineering is not new.",
                    "label": 1
                },
                {
                    "sent": "So what I'm going to present you as a approach which is making use of weighted graphs with a graph mining algorithm.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, that's the outline of my talk.",
                    "label": 0
                },
                {
                    "sent": "At first I do a short review of data mining and software engineering about techniques which have been used so far.",
                    "label": 1
                },
                {
                    "sent": "Well, traditional data mining approaches, and also as a graph based approach.",
                    "label": 0
                },
                {
                    "sent": "Before I come to our weighted call graph mining approach.",
                    "label": 1
                },
                {
                    "sent": "After that I am going to present you some result and I can't.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Mike talk.",
                    "label": 0
                },
                {
                    "sent": "OK, as you all know, traditional data mining techniques like decision trees, neural networks or whatever they're using with a feature.",
                    "label": 1
                },
                {
                    "sent": "Vectors of numerical or categorical values and how can you fit data from software engineering into such such a framework.",
                    "label": 1
                },
                {
                    "sent": "While it's possible to use like different kind of source code matrix which would be statical analyzers.",
                    "label": 0
                },
                {
                    "sent": "Or you can also instrument your software in order to just dump some some data during the program execution.",
                    "label": 0
                },
                {
                    "sent": "I been doing dynamic analyzers well and these values like so different kind of code matrix.",
                    "label": 0
                },
                {
                    "sent": "Can you put into such a table and was there a number of software artifacts, for example methods or classes of files or whatever in the rows and columns.",
                    "label": 0
                },
                {
                    "sent": "Every such method for example is described by a number of metrics.",
                    "label": 0
                },
                {
                    "sent": "Well and at the end you're searching for patterns of certain properties in.",
                    "label": 0
                },
                {
                    "sent": "In such a table.",
                    "label": 0
                },
                {
                    "sent": "And you are searching for patterns which are more likely in buggy software than in correct software.",
                    "label": 1
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But unfortunately there are some challenging challenges with such an approach.",
                    "label": 1
                },
                {
                    "sent": "Um?",
                    "label": 0
                },
                {
                    "sent": "Well the first static analyzers you're having some problems that even if you are having like hundreds of metrics, even if you if you derive every possible metric from a piece of source code, these metrics are usually not enough to describe certain piece of software completely.",
                    "label": 1
                },
                {
                    "sent": "So there are still some information lose loss.",
                    "label": 0
                },
                {
                    "sent": "Well, and the other thing is, even if you derive some interesting information like, well, software is always buggy.",
                    "label": 0
                },
                {
                    "sent": "If some metric value is increased, for example, if there are no comments in this in the source code than the software tends to be buggy or something like that.",
                    "label": 0
                },
                {
                    "sent": "Such information doesn't really help you too.",
                    "label": 0
                },
                {
                    "sent": "To locate the back to say, well, the back is exactly in this method and that's what we want to do.",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "There are also some shortcomings with dynamic analyzers, so if you do instrumentation, there's always a tradeoff between the runtime of the program.",
                    "label": 0
                },
                {
                    "sent": "Well, if you want to collect a lot of runtime information needs to a lot of time and also possibly producing huge amounts of data which is quite hard to analyze afterwards.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So what we are proposing or but already has been proposed from the graph mining community somehow is looking at program executions and which are represented as a dynamic call graph, and then if you're considering such call graphs, you can analyze its structure and try to find some interesting patterns within such call graphs.",
                    "label": 1
                },
                {
                    "sent": "Well, but I want to mention is that such an approach of.",
                    "label": 0
                },
                {
                    "sent": "Analyzing program executions is autogena to other approaches which have been proposed in the software engineering community.",
                    "label": 0
                },
                {
                    "sent": "So it can be seen as an additional technique.",
                    "label": 0
                },
                {
                    "sent": "OK, what can we do when analyzing call graphs?",
                    "label": 1
                },
                {
                    "sent": "You usually try to identify substructures which are typical for faulty executions.",
                    "label": 0
                },
                {
                    "sent": "And in order to do such kind of discriminative mining, you usually require a test Oracle.",
                    "label": 0
                },
                {
                    "sent": "So you have to decide which program execution was good one, which was a bad one basically.",
                    "label": 0
                },
                {
                    "sent": "So which program execution was back free?",
                    "label": 0
                },
                {
                    "sent": "Which program execution lead to like faulty results?",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "The analyzers of call graphs of data mining case with graph mining techniques is not new, but what is new in my talk is the analyzes of call frequencies and call frequencies can be.",
                    "label": 0
                },
                {
                    "sent": "Can be.",
                    "label": 0
                },
                {
                    "sent": "Can be displayed in a call graph with different kinds of edge weights, and that's what I'm going to.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Show to you on the next slide.",
                    "label": 0
                },
                {
                    "sent": "OK I was talking bout call graphs before.",
                    "label": 0
                },
                {
                    "sent": "Just some basic information what what is called graphic Wall graph is Rockwall graph.",
                    "label": 0
                },
                {
                    "sent": "As you derive it from the program, execution is a rooted order tree.",
                    "label": 0
                },
                {
                    "sent": "So this node a here would be a main method which is first calling method B then is calling method C and within method sees as a possibly a loop and this loop is in this case calling method B three times in a row.",
                    "label": 0
                },
                {
                    "sent": "OK, well obviously also methods or functions or whatever that are the nodes of such a graph and the edges symbolize the message call of another method.",
                    "label": 0
                },
                {
                    "sent": "OK, now the question is how is it possible to to find the back in such a graph?",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "One possibility is that they are structure affecting box.",
                    "label": 0
                },
                {
                    "sent": "For example, if we're having in system method A.",
                    "label": 0
                },
                {
                    "sent": "If we're having an if condition, is this method which is somehow buggy, so that leads to the fact that this.",
                    "label": 0
                },
                {
                    "sent": "Method B might be called or might not be called.",
                    "label": 0
                },
                {
                    "sent": "So if there's a back in this if condition, it might happen that there's just no node be called from node A, which leads to a different shape of the structure from such a call graph.",
                    "label": 0
                },
                {
                    "sent": "And what I want to mention that this kind of structure affecting back is a kind of bug which can be located with existing approaches already, but.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "There's another quite common kind of bug which I call call frequency affecting Buck.",
                    "label": 1
                },
                {
                    "sent": "That's a bug, for example, in the loop condition within Method C. So back in the loop condition in method C might lead to like an increased number of executions of methods within this loop.",
                    "label": 1
                },
                {
                    "sent": "If there is a bucket, this is this condition.",
                    "label": 0
                },
                {
                    "sent": "So for example, in buggy executions you would always have like 300 method calls instead of like 3 method calls in this correct execution here.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, in order to in order to do graph mining with call graphs, we are faced with some problems concerning the size of such call graphs.",
                    "label": 1
                },
                {
                    "sent": "So here we are having here we're having a tiny little piece of real call graph from a Java program and as you can imagine.",
                    "label": 0
                },
                {
                    "sent": "About and modern software, there are many loops used, so let's say it's a loop in this.",
                    "label": 1
                },
                {
                    "sent": "In this method here there are other methods and other substructures called repeatedly, and there are very many repetitions.",
                    "label": 0
                },
                {
                    "sent": "So and this leads to the fact that millions of methods called within one call graph is quite a common case.",
                    "label": 1
                },
                {
                    "sent": "Well, and as you all probably know, it's not a good idea to feed such graphs with millions of nodes to a state of the art.",
                    "label": 0
                },
                {
                    "sent": "Frequent subgraph mining algorithm.",
                    "label": 0
                },
                {
                    "sent": "So we need to do something with the size of the graph.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Well, and that's what we heard from the.",
                    "label": 0
                },
                {
                    "sent": "I think the second talk yesterday.",
                    "label": 0
                },
                {
                    "sent": "If we are having large graphs, you have to try to reduce them somehow and you should try to keep the most important properties.",
                    "label": 0
                },
                {
                    "sent": "Yesterday the most important property was saying something about the degree distribution of the graphs.",
                    "label": 0
                },
                {
                    "sent": "Here in Fort localization it's quite important to.",
                    "label": 0
                },
                {
                    "sent": "To keep in mind that the structure of the graph is not changing too much, meaning which method is calling which other method and not just which measures is cording which method.",
                    "label": 0
                },
                {
                    "sent": "Also which method is calling which other method in which context.",
                    "label": 0
                },
                {
                    "sent": "So it makes a difference if, for example, Note B is called here from C or if node B is called here from A or at some other point inside this graph.",
                    "label": 0
                },
                {
                    "sent": "OK, how can we reduce such a call graph?",
                    "label": 1
                },
                {
                    "sent": "That's a Rockwall I introduced to you before.",
                    "label": 1
                },
                {
                    "sent": "Very common cases to do this kind of reduction, which I call a total reduction.",
                    "label": 0
                },
                {
                    "sent": "Here we take every node with the same label and merge to one note here.",
                    "label": 0
                },
                {
                    "sent": "So that leads to a cyclic graph.",
                    "label": 0
                },
                {
                    "sent": "But well, what you might realize is that the structure of this graph, which I said is important for back localization.",
                    "label": 0
                },
                {
                    "sent": "If it's changed pretty much, then going when doing this kind of reduction so so we're losing quite a lot of information about the structure of such a call graph.",
                    "label": 0
                },
                {
                    "sent": "Well, there have been some other ways of reducing graphs proposed in the literature.",
                    "label": 0
                },
                {
                    "sent": "What all these reductions are pretty much the same.",
                    "label": 0
                },
                {
                    "sent": "What we're doing now, which is well.",
                    "label": 0
                },
                {
                    "sent": "It's quite surprisingly that nobody else has done it before, but what we're doing is is easy possibility just to introduce edge weights.",
                    "label": 0
                },
                {
                    "sent": "So when you look at this graph, method B is called three times in a row.",
                    "label": 0
                },
                {
                    "sent": "We just put here, we put here in edge rate while maybe you're asking yourself why nobody has done such an easy kind of reduction.",
                    "label": 0
                },
                {
                    "sent": "It keeps the graph pretty small while keeping most of the information.",
                    "label": 0
                },
                {
                    "sent": "So in this particular case we can.",
                    "label": 0
                },
                {
                    "sent": "It's lossless, so we can go from this graph back to the original graph.",
                    "label": 0
                },
                {
                    "sent": "Why has nobody else wondered where the problem is?",
                    "label": 0
                },
                {
                    "sent": "Like weighted graph mining has not been investigated a lot, so people prefer to do purely structural graph mining with such kind of graphs without any weights.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, before I'm coming to our approach where I'm going to explain you how we make use of such edge weights, I just want to introduce you to.",
                    "label": 0
                },
                {
                    "sent": "Somehow, the conventional approach for locating backs with graph mining techniques, which is the approach from default at all.",
                    "label": 1
                },
                {
                    "sent": "OK, at 1st at first you need some input data into this input data is as I said before, a collection of call graphs which need to be classified as a correct execution or as a call graph representing a faulty execution.",
                    "label": 0
                },
                {
                    "sent": "And well, if you have such a such collection of call graphs, we have to reduce them in order to search for frequent subgraphs, and that can be done with basically every frequent subgraph mining algorithm or.",
                    "label": 1
                },
                {
                    "sent": "Depending on the reduction technique, use.",
                    "label": 0
                },
                {
                    "sent": "If you are having trees you can also use a tree mining algorithm, but that doesn't really matter.",
                    "label": 0
                },
                {
                    "sent": "OK then we are having these frequent patterns.",
                    "label": 0
                },
                {
                    "sent": "This frequent subgraphs we can do the following.",
                    "label": 1
                },
                {
                    "sent": "We can identify discriminative subgraphs.",
                    "label": 1
                },
                {
                    "sent": "From and such discriminator subgraphs are subgraphs which are frequent within faulty, but multiple things are correct executions.",
                    "label": 0
                },
                {
                    "sent": "And, well, the intuition of this step is that the methods which are the things Easter, discriminative subgraphs, they display an increased likelihood of being responsible for some buggy execution.",
                    "label": 1
                },
                {
                    "sent": "Let's say intuition behind the whole approach.",
                    "label": 0
                },
                {
                    "sent": "Well, and as I said before.",
                    "label": 0
                },
                {
                    "sent": "This approach from the father is able to discover the kind of back which I called structural structure affecting back.",
                    "label": 0
                },
                {
                    "sent": "So if there is a.",
                    "label": 0
                },
                {
                    "sent": "Certain pattern in the structure, also called grass and faulty execution.",
                    "label": 0
                },
                {
                    "sent": "This approach will discover this kind of structural pattern.",
                    "label": 0
                },
                {
                    "sent": "And you can derive your information about which methods are most.",
                    "label": 0
                },
                {
                    "sent": "Likely to contain the bar from these discriminative subgraphs.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, I will shortly come to our approach before I'm going to explain our approach.",
                    "label": 0
                },
                {
                    "sent": "Would like to review the approach from the fact I just explained to you and this approach is this approach which I marked red in this diagram.",
                    "label": 0
                },
                {
                    "sent": "So just just again we're starting this call graph which reduced somehow.",
                    "label": 1
                },
                {
                    "sent": "Then we do frequent subgraph mining and now we're looking onto this left branch.",
                    "label": 1
                },
                {
                    "sent": "So we are considering discriminative subgraphs here.",
                    "label": 0
                },
                {
                    "sent": "So subgraphs which are frequent in failing executions but not.",
                    "label": 1
                },
                {
                    "sent": "A frequent incorrect executions.",
                    "label": 0
                },
                {
                    "sent": "Phantom based on this kind of discriminator subgraphs.",
                    "label": 0
                },
                {
                    "sent": "Yeah, the factor is doing something which I call here conventional scoring.",
                    "label": 1
                },
                {
                    "sent": "So there's some scoring of the edges based on the frequency of the of the edges and so on.",
                    "label": 0
                },
                {
                    "sent": "And this leads to ranking, which I call conventional ranking.",
                    "label": 0
                },
                {
                    "sent": "And what this ranking basically says, well is the probability of this method is very high, so a software engineer should have a look onto this method in order to find the back.",
                    "label": 0
                },
                {
                    "sent": "So that's that's the way the whole system works.",
                    "label": 0
                },
                {
                    "sent": "OK, what we're do.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "I said I would like to look at edge weights and not just on the different kind of shapes or structure.",
                    "label": 0
                },
                {
                    "sent": "We are not considering the graphs which are discriminate.",
                    "label": 0
                },
                {
                    "sent": "If we're considering grass which are non discriminate.",
                    "label": 0
                },
                {
                    "sent": "If so, in other words we are considering graphs which are in Kering in bills in failing and incorrect execution, so it's account of subgraphs we're working with.",
                    "label": 0
                },
                {
                    "sent": "And this is these.",
                    "label": 0
                },
                {
                    "sent": "These subgraphs we're doing some weight based scoring.",
                    "label": 0
                },
                {
                    "sent": "That's fantastic.",
                    "label": 0
                },
                {
                    "sent": "I'm going to introduce to you on the next slide.",
                    "label": 0
                },
                {
                    "sent": "But before I'm going to do that, well, we get some some same kind of ranking from this bait based scoring.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "But what we're doing now is we're not using this conventional ranking over not using the intermediate ranking as the left approach.",
                    "label": 1
                },
                {
                    "sent": "The conventional approach is able to discover this structure affecting box, and our approach is able to detect this.",
                    "label": 0
                },
                {
                    "sent": "This frequency affecting box we're combining these these two kinds of evidence of evidence, and which leads to a combined ranking.",
                    "label": 1
                },
                {
                    "sent": "OK, now it's a question.",
                    "label": 0
                },
                {
                    "sent": "How do we?",
                    "label": 0
                },
                {
                    "sent": "How do we make a ranking based on edge weights?",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "As I said, we are considering subgraphs which are frequent or which are occurring in those sets.",
                    "label": 0
                },
                {
                    "sent": "So for every for every sub graph we are considering now we're having a passing examples and we're having tailing examples and that allows us to identify edge weights which most differentiate between these two classes.",
                    "label": 1
                },
                {
                    "sent": "So that's the basic idea of what we're doing now and in order to do that.",
                    "label": 1
                },
                {
                    "sent": "We're mapping we're mapping this graph mining problem to a feature selection problem and.",
                    "label": 0
                },
                {
                    "sent": "To do so, we are first assembling such a table, which I'm going to explain to you right now.",
                    "label": 0
                },
                {
                    "sent": "So in this table.",
                    "label": 0
                },
                {
                    "sent": "Every edge in every frequent subgraph is considered, meaning we're having we're having in the roles were having the grass from our collection of glass, the original graph, and every such graph is assigned with a label with the class label.",
                    "label": 1
                },
                {
                    "sent": "If it's a failing execution of, it's a correct execution.",
                    "label": 0
                },
                {
                    "sent": "And then we have a huge number of columns and here we are having two columns for the sub graph number one.",
                    "label": 0
                },
                {
                    "sent": "So the 1st first factor patrols found in.",
                    "label": 0
                },
                {
                    "sent": "This is a frequent subgraph mining algorithm and within every subgraphs or within sub graph one we're having a number of edges.",
                    "label": 0
                },
                {
                    "sent": "So here we're having one edge from node A to node B and one edge from node A to node C. And in the next next column we're having subgraph two and the edge from A to B, and then another edge in subgraph two and all the others have graph so that as the columns and in the in the cells of the table, we just put the average weight of the edges.",
                    "label": 0
                },
                {
                    "sent": "So for example.",
                    "label": 0
                },
                {
                    "sent": "The weight of the edge from A to B within sub graph, one in the first draft of our graph collect call graph collection has the weight 2, so that's a kind of paper reassembling and.",
                    "label": 1
                },
                {
                    "sent": "Well, when we are having such kind of table, we can basically apply every kind of feature selection which is known from the literature.",
                    "label": 1
                },
                {
                    "sent": "So we used we use standard information gain based or entropy based feature selection algorithm and applied it to this table which is resulting in a ranking of the of the columns.",
                    "label": 0
                },
                {
                    "sent": "Or in other words, it's resulting in a ranking of of these edges.",
                    "label": 0
                },
                {
                    "sent": "So at the end we know which.",
                    "label": 0
                },
                {
                    "sent": "Rate of which edge is most discriminating between the two classes of class of correct in the class of failing program executions?",
                    "label": 1
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So how do our results look like?",
                    "label": 0
                },
                {
                    "sent": "So that's just one example.",
                    "label": 0
                },
                {
                    "sent": "Our Windows look pretty much like that, so we're having ranking of methods.",
                    "label": 0
                },
                {
                    "sent": "We have a number of different method names and every method is assigned with a score and to score tells us the likelihood.",
                    "label": 0
                },
                {
                    "sent": "How likely is it that the back or back is contained?",
                    "label": 0
                },
                {
                    "sent": "For example, in this method, input scan?",
                    "label": 0
                },
                {
                    "sent": "In this case this score is pretty high, so it's a value between zero and one which leads to.",
                    "label": 0
                },
                {
                    "sent": "To the fact that this method is ranked top in this ranking.",
                    "label": 0
                },
                {
                    "sent": "But not necessarily say that the back is really included in.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "This method, so in this case.",
                    "label": 0
                },
                {
                    "sent": "The back was, I knew where the bug is in the back was included in this second method, so that's what happens frequently.",
                    "label": 1
                },
                {
                    "sent": "But at the end, if you're giving such a list to a software developer as a software developer would start with the first method, he would just do a review of this method.",
                    "label": 1
                },
                {
                    "sent": "He would probably not find a bug for then you would switch to the second method and there he would find the back.",
                    "label": 0
                },
                {
                    "sent": "So it's a pretty good result of Buck is found in the 2nd row of this result table.",
                    "label": 0
                },
                {
                    "sent": "OK, what you what you should remember for the evaluation on the next slide is that lower ninth line numbers are better, so it's best case would be if our method which identifies the correct Buck in line number one but line number two or three.",
                    "label": 1
                },
                {
                    "sent": "Isn't that the result?",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, no setting of our experiments.",
                    "label": 0
                },
                {
                    "sent": "We used some open source Java tool which is containing 25 different methods and I instrumented instrumented these this tool with nine different kinds of bugs.",
                    "label": 0
                },
                {
                    "sent": "The methods I instrumented, they are artificial.",
                    "label": 0
                },
                {
                    "sent": "So I just changed some variable name names and so on, but I tried to do it realistic so I did some research on how other people did Sir evaluation on such kind of problems and they also from the software engineering community.",
                    "label": 0
                },
                {
                    "sent": "There are some streets of Buck collections available, so I reviewed these suites and try to.",
                    "label": 0
                },
                {
                    "sent": "Try to instrument the same kind of.",
                    "label": 0
                },
                {
                    "sent": "The same kind of backs to this piece of software in order to have.",
                    "label": 0
                },
                {
                    "sent": "Somehow realistic evaluation.",
                    "label": 0
                },
                {
                    "sent": "OK everybody version, so I'm having nine buggy version was executed exactly 100 times with different kind of input data and at the end I assessed every execution if it was a good execution or bad execution.",
                    "label": 0
                },
                {
                    "sent": "So I knew the expected result of every execution and so it was easy to decide if the result was buggy or so result was correct.",
                    "label": 0
                },
                {
                    "sent": "OK, we're coming to to this table in this Taylor we're having into columns were having so nine different box I instrumented with the software and in the Rose we're having three different methods.",
                    "label": 0
                },
                {
                    "sent": "The efforts of finding box that's the first method, which is this approach from the factor which is just looking at the structural differences, then there's this intermediate method, which is, which is our method which looks only at the edge weights and then.",
                    "label": 0
                },
                {
                    "sent": "That's a combined method.",
                    "label": 0
                },
                {
                    "sent": "Well, as as an example.",
                    "label": 0
                },
                {
                    "sent": "As an example, this back number three was pretty easy to find.",
                    "label": 0
                },
                {
                    "sent": "It was ranked top.",
                    "label": 0
                },
                {
                    "sent": "The succulent conventional approach.",
                    "label": 0
                },
                {
                    "sent": "It both ranked top with our approach, and while also the combination was ranked top.",
                    "label": 0
                },
                {
                    "sent": "I would like to introduce it to two pretty interesting kinds of bugs, which is about two and back #9, so this minus here means that back two was not found with the conventional approach, and that's caused by the fact that back and #2 is a bug, which is typical.",
                    "label": 0
                },
                {
                    "sent": "Typical frequency affecting back so, so this bug doesn't lead to any different kind of shape of the call graph, but it needs to.",
                    "label": 0
                },
                {
                    "sent": "It leads to differences and.",
                    "label": 0
                },
                {
                    "sent": "In the number of executions of a certain as a method or certain as a subtree, so it's easily found with with the intermediate approach and the good thing is that if you're combining these two of these two approaches, it's still found in the 2nd and the third line well, and the other way around.",
                    "label": 0
                },
                {
                    "sent": "It's a back number 9 #9 is easily found with the structural approach, as it's a structural Buck, but there's no chance for the intermediate approach to.",
                    "label": 0
                },
                {
                    "sent": "Find this kind of back as there are no edge weights which are different.",
                    "label": 0
                },
                {
                    "sent": "OK altogether, if we look at the numbers.",
                    "label": 0
                },
                {
                    "sent": "If you're comparing the conventional approach and the combined approach, leaving aside box 2 and 9 on average, the precision of the back localizations is increased by a factor of 2.4.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "OK, I'm coming to the end of my talk.",
                    "label": 0
                },
                {
                    "sent": "I'd like to conclude with a short summary of what we've done.",
                    "label": 0
                },
                {
                    "sent": "At first we proposed this new called graph reduction variant, and we identified this variant of being crucial to identify this type of quad frequency affecting bugs.",
                    "label": 0
                },
                {
                    "sent": "OK then I. I'm.",
                    "label": 0
                },
                {
                    "sent": "I presented a technique or combination of techniques for mining weighted graphs in this classification scenario, as a class of every graph, like failing or correct is known.",
                    "label": 0
                },
                {
                    "sent": "And this is done by a combination of, like a structural structural technique, graph mining, or frequent subgraph mining, and a numerical technique which is a feature selection.",
                    "label": 0
                },
                {
                    "sent": "And what we are claiming is that this kind of approach to analyze weighted graphs can be applied in other domains as well, so.",
                    "label": 1
                },
                {
                    "sent": "Well, basically you can apply this kind of approach in every domain where we are having a weighted graph and where we have some information about weights of the edges.",
                    "label": 0
                },
                {
                    "sent": "OK, most importantly to say is that in contrast to other approaches, we're not just considering discriminative subgraphs, but we're explicitly considering graphs which are not discriminate.",
                    "label": 0
                },
                {
                    "sent": "If so, graph which occur in both classes, correct and failing executions as they would like to find the discriminant if edge weights.",
                    "label": 0
                },
                {
                    "sent": "OK, in our field of application and software engineering this approach we are able to detect new important class of graphs.",
                    "label": 1
                },
                {
                    "sent": "Which are these quality frequency affecting backs and we're having a double precision of back localizations in our well it's a small data set what?",
                    "label": 0
                },
                {
                    "sent": "I showed quite a significant improve of this quality of localizations.",
                    "label": 1
                },
                {
                    "sent": "OK, what's my current and future research?",
                    "label": 1
                },
                {
                    "sent": "At first, light weight based constraints, so in this work we've done no combination of graph mining and analyzes of dates.",
                    "label": 0
                },
                {
                    "sent": "In the future I'm trying to analyze the edge weights during the graph mining.",
                    "label": 0
                },
                {
                    "sent": "During the graph mining process.",
                    "label": 0
                },
                {
                    "sent": "So I'm trying to find some some useful constraints which are working with edge weights.",
                    "label": 0
                },
                {
                    "sent": "OK there still this problem remaining that that call graphs are pretty large and it's quite hard to apply graph mining algorithms to such raw, so I'm also working on different kind of methods for doing more efficient compression or selection of some relevant parts of the graph.",
                    "label": 0
                },
                {
                    "sent": "I'm also trying.",
                    "label": 0
                },
                {
                    "sent": "I'm working on approximate graph mining algorithms, but that's future work as well as.",
                    "label": 0
                },
                {
                    "sent": "The application of this technique and, as a related, techniques to other domains.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "That's it, thank you very much for your attention, and if you're having any questions, I'd like to try to answer them.",
                    "label": 0
                },
                {
                    "sent": "Thank you.",
                    "label": 0
                },
                {
                    "sent": "Can you go back to the slide where you have the feature selection?",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Yes, so your simple example, it looks like you have only edges.",
                    "label": 0
                },
                {
                    "sent": "Very simple graph which are reduced to edges.",
                    "label": 0
                },
                {
                    "sent": "Are you actually considering larger subgraphs?",
                    "label": 0
                },
                {
                    "sent": "Because if you do, how do you define the number for a larger, say, a triangle or whatever?",
                    "label": 0
                },
                {
                    "sent": "Well, that's just a pretty small example, so here's a subgraph.",
                    "label": 0
                },
                {
                    "sent": "One has two edges, but in general the graphs can have any size and I just make one.",
                    "label": 0
                },
                {
                    "sent": "No, but my OK, sorry.",
                    "label": 0
                },
                {
                    "sent": "My point is, how do you compute the value?",
                    "label": 0
                },
                {
                    "sent": "What's the value inside your colon value inside the column is a average rate of the also edge in the certain sub graph.",
                    "label": 0
                },
                {
                    "sent": "So I'm looking at sub graph one.",
                    "label": 0
                },
                {
                    "sent": "In which graph subgraph one included?",
                    "label": 0
                },
                {
                    "sent": "Then I'm looking at A to be within subgroup one, and then I then I calculate.",
                    "label": 0
                },
                {
                    "sent": "Well, it might happen that subgraph oneness included at several places that is embedded several places in the graph #1 to 9.",
                    "label": 0
                },
                {
                    "sent": "Calculating is the average of this edge from A to B in sub graph, one within graph one.",
                    "label": 0
                }
            ]
        }
    }
}