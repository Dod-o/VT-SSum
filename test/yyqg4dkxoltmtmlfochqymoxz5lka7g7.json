{
    "id": "yyqg4dkxoltmtmlfochqymoxz5lka7g7",
    "title": "A Worst-Case Optimal Join Algorithm for SPARQL",
    "info": {
        "author": [
            "Adri\u00e1n Soto, Pontificia Universidad Cat\u00f3lica de Chile"
        ],
        "published": "Dec. 10, 2019",
        "recorded": "October 2019",
        "category": [
            "Top->Computer Science->Semantic Web"
        ]
    },
    "url": "http://videolectures.net/iswc2019_soto_join_algorithm/",
    "segmentation": [
        [
            "Yeah so hi everyone, I'm going to present our work which is called a worst case optimal join algorithm for spark well, so I'll say."
        ],
        [
            "With an introduction OK."
        ],
        [
            "So we all know RDF graphs and their language."
        ],
        [
            "Sparkle"
        ],
        [
            "So for instance, in this case we have a query where we're asking for all all the friends of someone that has a bad name dinci.",
            "OK, so one would expect that that this."
        ],
        [
            "The query is are later using graph based."
        ],
        [
            "But instead of that, we are still using traditional join."
        ],
        [
            "Algorithm to process a query like this.",
            "So the main issue here is that this particular Lisa language to query graph based storage is but we are still using traditional joint algorithms.",
            "So how about using?"
        ],
        [
            "New techniques then, with this question in mind, I."
        ],
        [
            "Gone I'm going to show a whole.",
            "We implemented our worst case optimal join algorithm in an RDF database.",
            "An also hold this algorithm algorithm perform with respect to the existing approaches, so some pretty."
        ],
        [
            "Various first, I will use the."
        ],
        [
            "A usual syntax and semantics of spark.",
            "Well this is a triple pattern, OK?"
        ],
        [
            "OK, I I will talk about basic craft."
        ],
        [
            "Patterns, which is a set of triple patterns like this an in this style.",
            "I will only consider the default graph."
        ],
        [
            "Also, the result of this particular query is set of mappings.",
            "For instance this could be."
        ],
        [
            "EA."
        ],
        [
            "The result set for this query we have in this case."
        ],
        [
            "Data mappings an maybe we can have more an I will call P / D the set of mappings obtained when the basic pattern P is evaluated over a graph D. OK, Ann."
        ],
        [
            "Also, I have to talk about the Adm bound to understand the worst case optimal algorithms.",
            "Then suppose the following conjunctive query in a relational settings.",
            "This query is a joint query an also we know the cardinality of each one of the relations.",
            "So a valid question is what is the?"
        ],
        [
            "Maximum number of results of Q when we evaluate a query or D then we can."
        ],
        [
            "Calculate an upper bound for the number of results in terms of the cardinality of the relations an this value is called the DM bound, and is a tight bound for the number of results."
        ],
        [
            "Certain query the classic example here is this query which is a triangle.",
            "We are using three relations an all of the relations has cardinality and so the Adm bound say that the number of results of such query is always less than NA by three on three by two.",
            "OK."
        ],
        [
            "So when we use traditional doing algorithms to evaluate this query, if we consider the subquery error join S in that subquery in the worst case, we will have N squared result and that means that with the standard doing algorithm that evaluate a query pairwise in a lefty plan join algorithm will take at least O of N squared.",
            "But we know that the size of the way is at most the Adm bound so.",
            "We would like to have some algorithm that runs below the Adm bound an."
        ],
        [
            "That's what we call a worst case.",
            "Optimal join algorithms are the algorithms that runs below the AGM bound.",
            "So in this case our case optimal algorithm to resolve the query in almost a oh of the aging bound of the triangle query."
        ],
        [
            "And there are a lot of examples of this kind of algorithms, like lip three, you in my sweeper head rezan so one.",
            "So we started this."
        ],
        [
            "Because we firmly believe that the work is optimal, algorithm will be an improvement for RDF database, so for that reason we implemented the."
        ],
        [
            "Leapfrog join a little tree in algorithm on an RDF database.",
            "OK so."
        ],
        [
            "I will start with an example to explain what the algorithm does.",
            "So if we have this graph I which talks about a winners of the normal price."
        ],
        [
            "An I put this query.",
            "This query is asking for every person that wanna price an which also their parents also want the same price.",
            "Then if we consider the 1st three triple patterns it happens that that we are considering the cross product of the winners in our graph."
        ],
        [
            "In this case, we have all these combinations that are a 125 possible mappings.",
            "So the cross product is expensive for the database, but we know that the number of results of this query is less than that because then we are filtering the variable X2 and A2 by the one that has a mother and father.",
            "So we want another technique to relate this."
        ],
        [
            "So we adopted the Leap Rock Trio in for RDF databases."
        ],
        [
            "I will explain what the algorithm does, so consider the same example."
        ],
        [
            "Then we need to fix variable ordering.",
            "In this case, is X one X2X3 and X4 and what we do is the following.",
            "First we start."
        ],
        [
            "The variable X one and we have to find a possible binding for the variable.",
            "We will find that novel is a possible value in the group."
        ],
        [
            "Tough.",
            "So when we fix this variable, we will."
        ],
        [
            "Find for a possible bye bye."
        ],
        [
            "You for the variable X2 and then we have that X2 have to be linked to novel via the property winner.",
            "An extra also has to have a mother and a father, so the possible bindings here are A8 for instance and then we will seek for a variable X3 which is the father."
        ],
        [
            "And then we will, we will.",
            "We will see that we don't have a possible mapping that that."
        ],
        [
            "That can continue this procedure.",
            "So the variables for."
        ],
        [
            "He doesn't have a possible value here, so we have to do a rollback and."
        ],
        [
            "We will start rolling back.",
            "We don't have another father for I for 8."
        ],
        [
            "So we will come to X2 again and we will seek for the next possible mapping so."
        ],
        [
            "That one the normal price in this guy in this case is Irene and."
        ],
        [
            "We and then we will seek another possible bindings, in this case pier and."
        ],
        [
            "And we have here or first table that they are mapping that is the result of the of the basic pattern that we have here."
        ],
        [
            "So intuitively we have two steps.",
            "The first step is the lift lip lock step where when we're computing the intersection of the variable X and then this is similar to take all the triple patterns separately, evaluate them over the graph, and then compute the intersection when we are projecting the variable that we are asking for in such in some iteration an.",
            "Once we have this step, which is the leapfrog."
        ],
        [
            "Also have the variable elimination step.",
            "Then we fix the variable ordering.",
            "In this case we consider X one to XN, an for each value of B found in the Leapfrog step.",
            "We start replacing the values on the basic pattern that we call it variable elimination because we're replacing the variables by concrete values that are present in the in the graph.",
            "So we iterate this process first with X, one X2 and."
        ],
        [
            "So one then we are eliminating the variables, replacing it.",
            "But by the possible constant that that satisfy the basic graph pattern.",
            "OK, so that's the that's the idea of the algorithm.",
            "The algorithm is not ours is proposed sometime ago.",
            "The original algorithm is the lip trio, and this is a version that we implemented in an RDF data."
        ],
        [
            "So what we did is to implem."
        ],
        [
            "And the algorithm in the engine.",
            "About Gina.",
            "We wanted to do this a showing that it's possible to implement the algorithm, but without doing huge modifications to the graph.",
            "And for this we have to work a lot with the indexing of the graph.",
            "So we know that."
        ],
        [
            "In RDF databases, the idea of indexing is to take the possible orders of the tribbles and store them in a separate B + 3.",
            "For instance, if I have the triple SPO, it has to be stored several times like SPOPOS and so on in separate blast.",
            "3 for the values in the graph."
        ],
        [
            "M. And then a idea of this is to compute the Leapfrog step, which is a kind of intersection of values using an adaptive intersection algorithm.",
            "This algorithm, the only the only requirement of the algorithm, is that it assumes that that each each one of the triple patterns.",
            "When we project the variable we're searching can be navigated in an increasing order, so this is not."
        ],
        [
            "Now the basic idea is that we can achieve or or or or or bound a just a creating some more indexing indexes in the database.",
            "The three first index are native of Pasadena and we have the 2nd three indexes and slightly extending the blast 3 of a Gina.",
            "We will will be able to.",
            "Perform a intersection of variables in a logarithmic time with respect to the graph.",
            "Is fact."
        ],
        [
            "It's two or theorem that the implementation of Flip Flop 3 and that we have is in fact worst case optimal, so this is fine.",
            "We have theoretical guarantee, but we need more so."
        ],
        [
            "In summary, the classic approach is to query the indexes and decide the best order of triple patterns and then execute a traditional join algorithm.",
            "But what we're doing now is the result query variable by variable.",
            "Fixing the values that we are finding.",
            "So it's like more dynamic and then perform their work.",
            "This optimal algorithm.",
            "Then we have this theoretical guarantee, but we have."
        ],
        [
            "I need to understand how this algorithm performs in real world so we."
        ],
        [
            "Anne's a bunch of experi."
        ],
        [
            "The first thing we do is to compare our approach with the original one of a Pasadena using Devil in Benchmark.",
            "OK, Ann."
        ],
        [
            "Then we saw that that the running time of our algorithm with respect to, uh Pasadena, is almost the same.",
            "It is competitive, but we have to have in mind that that there are limits is not proposed for testing only BP's but but testing several operators of the Sparkle query language."
        ],
        [
            "So today's specifically the behavior of BBS we used to set of experiment.",
            "The first one is what Dave and the second one is proposed by us, which is we got up benchmark an.",
            "We wanted to compare our approach with a three of the most use RDF database.",
            "The results before we."
        ],
        [
            "These are the following.",
            "There is a lot of information here, but but the important thing is that the dots are the average time of execution of each one of the use cases."
        ],
        [
            "In in what if an?",
            "The idea here is that in fact or."
        ],
        [
            "PRISM performs considerably better in this benchmark, and also tends to be more stable than the minimum time and the maximum time for the queries is is always a kind of bound an and then we wanted to try the key steps of our algorithm against existing solution.",
            "The key steps are the leapfrog step and the variable elimination so."
        ],
        [
            "It's why we created a or own benchmark based on the graph of weed data.",
            "We created a 17 query template sandwich enerate randomly A50 query paper template."
        ],
        [
            "These are the template.",
            "The first row is to test the Leapfrog processor and the 2nd row is to test the variable elimination and then."
        ],
        [
            "We run the experiments for single variables.",
            "These are the results.",
            "A summary of the."
        ],
        [
            "Is that the total time of execution of the benchmark?",
            "Is 4 seconds for our implementation and the most notable speedup happens when when the variable is in the object?",
            "And then."
        ],
        [
            "Again, for multiple variables we have again a nice.",
            "Performance of our algorithm against the existence solution, But here a bit also outperforms our approach in some use cases."
        ],
        [
            "And this is mainly because the variable ordering that we are choosing is not optimal and so is choosing a triplet pattern ordering, which is better.",
            "Anne."
        ],
        [
            "Well, finally a the idea here."
        ],
        [
            "Is that to the best of our knowledge, this is the first work about worst case optimal algorithm in spark well and we showed that in fact is festival solution and this technique in graph based storage works well.",
            "The effort and also a we saw that in practice or approach performs better in running time and also tends to be more stable."
        ],
        [
            "And well, as a future work, the first thing is that we need to understand how to choose the variable ordering, because we're fixing it now and we know that in words this optimal algorithm.",
            "This is the key part of the performance.",
            "And also we would like to try another algorithm that can improve the behavior of RDF."
        ],
        [
            "Databases here are some resources.",
            "The first one is this.",
            "The debate.",
            "The web page of the benchmark.",
            "Here's my contact.",
            "I have the links of the paperin, the source code for implementation and the benchmark that we created."
        ],
        [
            "That's all, thank you for your attention.",
            "Thank you any questions.",
            "Hey.",
            "You, you said as future work, you want to find the good order for the variables.",
            "Did you tell us actually what how you decide on the order?",
            "At the moment?",
            "Yeah, for deciding the variable ordering, what we do is OK. Do you?",
            "Do you have the join algorithm of Pasadena, which decides the doctoring of triple patterns?",
            "So in base to the order of triple patterns in base, kind of the order of appearance of the variables.",
            "In the original agreement of Pasadena, we decide our variable ordering.",
            "A it's like to copy the thing that Apple Tina.",
            "Did before.",
            "Great work so actually one thing that didn't become totally clear to me in how far is the algorithm streaming.",
            "So in this toy example, you only had one binding.",
            "Do you compute compute all the bindings for each variable in each step?",
            "And is it a blocking computation where you need to maintain large set of intermediate results in main memory?",
            "Or could this implemented in a fully streaming way pipelined essentially no no.",
            "What we did is to implement it not in memory.",
            "Actually it performs with the disk.",
            "Pages so.",
            "But one, the way that the algorithm works is that we first fix a single variable.",
            "We find the intersection of variable, but we don't compute the entire interception, just find one possible binding and then we start with the rate.",
            "If one finds a binding there and then, we go for the next variable, finding a possible binding, and that's all you have to keep in memory at the current binding on up.",
            "Pointer to the next one, but you don't need to have everything in memory here.",
            "Yeah, maybe to go in the same direction and.",
            "Did you say that you select one variable before, like doing the bindings and so on, but you select it, taking the first one?",
            "Or are you considering maybe as a future award to have some statistics on the on?",
            "Maybe the predicates to you know.",
            "First select the first one before rolling up as we were doing.",
            "Like is there an idea of using statistics on the data set before hand?",
            "OK.",
            "The what we say to LF before is that we choose the variable ordering that Pasadena used before, and that ordering is, according to the statistics that Apache Nahhas.",
            "So in base of the statistic, Albertina ordered but not for, not for variables but for trivial buttons.",
            "And we do some kind of direction to to have variable ordering, which is kind of.",
            "Quite distinct for the original 1.",
            "But yes, we started the statistic, but in terms of choosing a smart variable ordering, there is a lot of work actually in the field of of the guys that study worst case optimal algorithm is it is not clear how to decide the variable ordering in this kind of algorithms.",
            "Let's stand thank the speaker again."
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Yeah so hi everyone, I'm going to present our work which is called a worst case optimal join algorithm for spark well, so I'll say.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "With an introduction OK.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we all know RDF graphs and their language.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Sparkle",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So for instance, in this case we have a query where we're asking for all all the friends of someone that has a bad name dinci.",
                    "label": 0
                },
                {
                    "sent": "OK, so one would expect that that this.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The query is are later using graph based.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "But instead of that, we are still using traditional join.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Algorithm to process a query like this.",
                    "label": 0
                },
                {
                    "sent": "So the main issue here is that this particular Lisa language to query graph based storage is but we are still using traditional joint algorithms.",
                    "label": 0
                },
                {
                    "sent": "So how about using?",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "New techniques then, with this question in mind, I.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Gone I'm going to show a whole.",
                    "label": 0
                },
                {
                    "sent": "We implemented our worst case optimal join algorithm in an RDF database.",
                    "label": 0
                },
                {
                    "sent": "An also hold this algorithm algorithm perform with respect to the existing approaches, so some pretty.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Various first, I will use the.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "A usual syntax and semantics of spark.",
                    "label": 0
                },
                {
                    "sent": "Well this is a triple pattern, OK?",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, I I will talk about basic craft.",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Patterns, which is a set of triple patterns like this an in this style.",
                    "label": 0
                },
                {
                    "sent": "I will only consider the default graph.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Also, the result of this particular query is set of mappings.",
                    "label": 0
                },
                {
                    "sent": "For instance this could be.",
                    "label": 0
                }
            ]
        },
        "clip_15": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "EA.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The result set for this query we have in this case.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Data mappings an maybe we can have more an I will call P / D the set of mappings obtained when the basic pattern P is evaluated over a graph D. OK, Ann.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Also, I have to talk about the Adm bound to understand the worst case optimal algorithms.",
                    "label": 1
                },
                {
                    "sent": "Then suppose the following conjunctive query in a relational settings.",
                    "label": 0
                },
                {
                    "sent": "This query is a joint query an also we know the cardinality of each one of the relations.",
                    "label": 0
                },
                {
                    "sent": "So a valid question is what is the?",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Maximum number of results of Q when we evaluate a query or D then we can.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Calculate an upper bound for the number of results in terms of the cardinality of the relations an this value is called the DM bound, and is a tight bound for the number of results.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Certain query the classic example here is this query which is a triangle.",
                    "label": 0
                },
                {
                    "sent": "We are using three relations an all of the relations has cardinality and so the Adm bound say that the number of results of such query is always less than NA by three on three by two.",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So when we use traditional doing algorithms to evaluate this query, if we consider the subquery error join S in that subquery in the worst case, we will have N squared result and that means that with the standard doing algorithm that evaluate a query pairwise in a lefty plan join algorithm will take at least O of N squared.",
                    "label": 0
                },
                {
                    "sent": "But we know that the size of the way is at most the Adm bound so.",
                    "label": 0
                },
                {
                    "sent": "We would like to have some algorithm that runs below the Adm bound an.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "That's what we call a worst case.",
                    "label": 0
                },
                {
                    "sent": "Optimal join algorithms are the algorithms that runs below the AGM bound.",
                    "label": 0
                },
                {
                    "sent": "So in this case our case optimal algorithm to resolve the query in almost a oh of the aging bound of the triangle query.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And there are a lot of examples of this kind of algorithms, like lip three, you in my sweeper head rezan so one.",
                    "label": 0
                },
                {
                    "sent": "So we started this.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Because we firmly believe that the work is optimal, algorithm will be an improvement for RDF database, so for that reason we implemented the.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Leapfrog join a little tree in algorithm on an RDF database.",
                    "label": 0
                },
                {
                    "sent": "OK so.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "I will start with an example to explain what the algorithm does.",
                    "label": 0
                },
                {
                    "sent": "So if we have this graph I which talks about a winners of the normal price.",
                    "label": 0
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "An I put this query.",
                    "label": 0
                },
                {
                    "sent": "This query is asking for every person that wanna price an which also their parents also want the same price.",
                    "label": 0
                },
                {
                    "sent": "Then if we consider the 1st three triple patterns it happens that that we are considering the cross product of the winners in our graph.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In this case, we have all these combinations that are a 125 possible mappings.",
                    "label": 0
                },
                {
                    "sent": "So the cross product is expensive for the database, but we know that the number of results of this query is less than that because then we are filtering the variable X2 and A2 by the one that has a mother and father.",
                    "label": 0
                },
                {
                    "sent": "So we want another technique to relate this.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we adopted the Leap Rock Trio in for RDF databases.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "I will explain what the algorithm does, so consider the same example.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Then we need to fix variable ordering.",
                    "label": 0
                },
                {
                    "sent": "In this case, is X one X2X3 and X4 and what we do is the following.",
                    "label": 0
                },
                {
                    "sent": "First we start.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The variable X one and we have to find a possible binding for the variable.",
                    "label": 0
                },
                {
                    "sent": "We will find that novel is a possible value in the group.",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Tough.",
                    "label": 0
                },
                {
                    "sent": "So when we fix this variable, we will.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Find for a possible bye bye.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "You for the variable X2 and then we have that X2 have to be linked to novel via the property winner.",
                    "label": 0
                },
                {
                    "sent": "An extra also has to have a mother and a father, so the possible bindings here are A8 for instance and then we will seek for a variable X3 which is the father.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And then we will, we will.",
                    "label": 0
                },
                {
                    "sent": "We will see that we don't have a possible mapping that that.",
                    "label": 0
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "That can continue this procedure.",
                    "label": 0
                },
                {
                    "sent": "So the variables for.",
                    "label": 0
                }
            ]
        },
        "clip_39": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "He doesn't have a possible value here, so we have to do a rollback and.",
                    "label": 0
                }
            ]
        },
        "clip_40": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We will start rolling back.",
                    "label": 0
                },
                {
                    "sent": "We don't have another father for I for 8.",
                    "label": 0
                }
            ]
        },
        "clip_41": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So we will come to X2 again and we will seek for the next possible mapping so.",
                    "label": 0
                }
            ]
        },
        "clip_42": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "That one the normal price in this guy in this case is Irene and.",
                    "label": 0
                }
            ]
        },
        "clip_43": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We and then we will seek another possible bindings, in this case pier and.",
                    "label": 0
                }
            ]
        },
        "clip_44": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And we have here or first table that they are mapping that is the result of the of the basic pattern that we have here.",
                    "label": 0
                }
            ]
        },
        "clip_45": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So intuitively we have two steps.",
                    "label": 0
                },
                {
                    "sent": "The first step is the lift lip lock step where when we're computing the intersection of the variable X and then this is similar to take all the triple patterns separately, evaluate them over the graph, and then compute the intersection when we are projecting the variable that we are asking for in such in some iteration an.",
                    "label": 0
                },
                {
                    "sent": "Once we have this step, which is the leapfrog.",
                    "label": 0
                }
            ]
        },
        "clip_46": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Also have the variable elimination step.",
                    "label": 0
                },
                {
                    "sent": "Then we fix the variable ordering.",
                    "label": 1
                },
                {
                    "sent": "In this case we consider X one to XN, an for each value of B found in the Leapfrog step.",
                    "label": 0
                },
                {
                    "sent": "We start replacing the values on the basic pattern that we call it variable elimination because we're replacing the variables by concrete values that are present in the in the graph.",
                    "label": 1
                },
                {
                    "sent": "So we iterate this process first with X, one X2 and.",
                    "label": 0
                }
            ]
        },
        "clip_47": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So one then we are eliminating the variables, replacing it.",
                    "label": 1
                },
                {
                    "sent": "But by the possible constant that that satisfy the basic graph pattern.",
                    "label": 0
                },
                {
                    "sent": "OK, so that's the that's the idea of the algorithm.",
                    "label": 0
                },
                {
                    "sent": "The algorithm is not ours is proposed sometime ago.",
                    "label": 0
                },
                {
                    "sent": "The original algorithm is the lip trio, and this is a version that we implemented in an RDF data.",
                    "label": 0
                }
            ]
        },
        "clip_48": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So what we did is to implem.",
                    "label": 0
                }
            ]
        },
        "clip_49": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And the algorithm in the engine.",
                    "label": 0
                },
                {
                    "sent": "About Gina.",
                    "label": 0
                },
                {
                    "sent": "We wanted to do this a showing that it's possible to implement the algorithm, but without doing huge modifications to the graph.",
                    "label": 0
                },
                {
                    "sent": "And for this we have to work a lot with the indexing of the graph.",
                    "label": 0
                },
                {
                    "sent": "So we know that.",
                    "label": 0
                }
            ]
        },
        "clip_50": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In RDF databases, the idea of indexing is to take the possible orders of the tribbles and store them in a separate B + 3.",
                    "label": 0
                },
                {
                    "sent": "For instance, if I have the triple SPO, it has to be stored several times like SPOPOS and so on in separate blast.",
                    "label": 0
                },
                {
                    "sent": "3 for the values in the graph.",
                    "label": 0
                }
            ]
        },
        "clip_51": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "M. And then a idea of this is to compute the Leapfrog step, which is a kind of intersection of values using an adaptive intersection algorithm.",
                    "label": 0
                },
                {
                    "sent": "This algorithm, the only the only requirement of the algorithm, is that it assumes that that each each one of the triple patterns.",
                    "label": 1
                },
                {
                    "sent": "When we project the variable we're searching can be navigated in an increasing order, so this is not.",
                    "label": 0
                }
            ]
        },
        "clip_52": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now the basic idea is that we can achieve or or or or or bound a just a creating some more indexing indexes in the database.",
                    "label": 0
                },
                {
                    "sent": "The three first index are native of Pasadena and we have the 2nd three indexes and slightly extending the blast 3 of a Gina.",
                    "label": 0
                },
                {
                    "sent": "We will will be able to.",
                    "label": 0
                },
                {
                    "sent": "Perform a intersection of variables in a logarithmic time with respect to the graph.",
                    "label": 0
                },
                {
                    "sent": "Is fact.",
                    "label": 0
                }
            ]
        },
        "clip_53": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "It's two or theorem that the implementation of Flip Flop 3 and that we have is in fact worst case optimal, so this is fine.",
                    "label": 0
                },
                {
                    "sent": "We have theoretical guarantee, but we need more so.",
                    "label": 0
                }
            ]
        },
        "clip_54": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In summary, the classic approach is to query the indexes and decide the best order of triple patterns and then execute a traditional join algorithm.",
                    "label": 0
                },
                {
                    "sent": "But what we're doing now is the result query variable by variable.",
                    "label": 0
                },
                {
                    "sent": "Fixing the values that we are finding.",
                    "label": 0
                },
                {
                    "sent": "So it's like more dynamic and then perform their work.",
                    "label": 0
                },
                {
                    "sent": "This optimal algorithm.",
                    "label": 0
                },
                {
                    "sent": "Then we have this theoretical guarantee, but we have.",
                    "label": 0
                }
            ]
        },
        "clip_55": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "I need to understand how this algorithm performs in real world so we.",
                    "label": 0
                }
            ]
        },
        "clip_56": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Anne's a bunch of experi.",
                    "label": 0
                }
            ]
        },
        "clip_57": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The first thing we do is to compare our approach with the original one of a Pasadena using Devil in Benchmark.",
                    "label": 0
                },
                {
                    "sent": "OK, Ann.",
                    "label": 0
                }
            ]
        },
        "clip_58": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Then we saw that that the running time of our algorithm with respect to, uh Pasadena, is almost the same.",
                    "label": 0
                },
                {
                    "sent": "It is competitive, but we have to have in mind that that there are limits is not proposed for testing only BP's but but testing several operators of the Sparkle query language.",
                    "label": 0
                }
            ]
        },
        "clip_59": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So today's specifically the behavior of BBS we used to set of experiment.",
                    "label": 0
                },
                {
                    "sent": "The first one is what Dave and the second one is proposed by us, which is we got up benchmark an.",
                    "label": 0
                },
                {
                    "sent": "We wanted to compare our approach with a three of the most use RDF database.",
                    "label": 0
                },
                {
                    "sent": "The results before we.",
                    "label": 0
                }
            ]
        },
        "clip_60": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "These are the following.",
                    "label": 0
                },
                {
                    "sent": "There is a lot of information here, but but the important thing is that the dots are the average time of execution of each one of the use cases.",
                    "label": 0
                }
            ]
        },
        "clip_61": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In in what if an?",
                    "label": 0
                },
                {
                    "sent": "The idea here is that in fact or.",
                    "label": 0
                }
            ]
        },
        "clip_62": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "PRISM performs considerably better in this benchmark, and also tends to be more stable than the minimum time and the maximum time for the queries is is always a kind of bound an and then we wanted to try the key steps of our algorithm against existing solution.",
                    "label": 0
                },
                {
                    "sent": "The key steps are the leapfrog step and the variable elimination so.",
                    "label": 0
                }
            ]
        },
        "clip_63": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "It's why we created a or own benchmark based on the graph of weed data.",
                    "label": 0
                },
                {
                    "sent": "We created a 17 query template sandwich enerate randomly A50 query paper template.",
                    "label": 0
                }
            ]
        },
        "clip_64": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "These are the template.",
                    "label": 0
                },
                {
                    "sent": "The first row is to test the Leapfrog processor and the 2nd row is to test the variable elimination and then.",
                    "label": 0
                }
            ]
        },
        "clip_65": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We run the experiments for single variables.",
                    "label": 0
                },
                {
                    "sent": "These are the results.",
                    "label": 0
                },
                {
                    "sent": "A summary of the.",
                    "label": 0
                }
            ]
        },
        "clip_66": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Is that the total time of execution of the benchmark?",
                    "label": 1
                },
                {
                    "sent": "Is 4 seconds for our implementation and the most notable speedup happens when when the variable is in the object?",
                    "label": 0
                },
                {
                    "sent": "And then.",
                    "label": 0
                }
            ]
        },
        "clip_67": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Again, for multiple variables we have again a nice.",
                    "label": 0
                },
                {
                    "sent": "Performance of our algorithm against the existence solution, But here a bit also outperforms our approach in some use cases.",
                    "label": 0
                }
            ]
        },
        "clip_68": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And this is mainly because the variable ordering that we are choosing is not optimal and so is choosing a triplet pattern ordering, which is better.",
                    "label": 0
                },
                {
                    "sent": "Anne.",
                    "label": 0
                }
            ]
        },
        "clip_69": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Well, finally a the idea here.",
                    "label": 0
                }
            ]
        },
        "clip_70": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Is that to the best of our knowledge, this is the first work about worst case optimal algorithm in spark well and we showed that in fact is festival solution and this technique in graph based storage works well.",
                    "label": 0
                },
                {
                    "sent": "The effort and also a we saw that in practice or approach performs better in running time and also tends to be more stable.",
                    "label": 0
                }
            ]
        },
        "clip_71": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "And well, as a future work, the first thing is that we need to understand how to choose the variable ordering, because we're fixing it now and we know that in words this optimal algorithm.",
                    "label": 0
                },
                {
                    "sent": "This is the key part of the performance.",
                    "label": 1
                },
                {
                    "sent": "And also we would like to try another algorithm that can improve the behavior of RDF.",
                    "label": 0
                }
            ]
        },
        "clip_72": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Databases here are some resources.",
                    "label": 0
                },
                {
                    "sent": "The first one is this.",
                    "label": 0
                },
                {
                    "sent": "The debate.",
                    "label": 0
                },
                {
                    "sent": "The web page of the benchmark.",
                    "label": 0
                },
                {
                    "sent": "Here's my contact.",
                    "label": 0
                },
                {
                    "sent": "I have the links of the paperin, the source code for implementation and the benchmark that we created.",
                    "label": 0
                }
            ]
        },
        "clip_73": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "That's all, thank you for your attention.",
                    "label": 0
                },
                {
                    "sent": "Thank you any questions.",
                    "label": 0
                },
                {
                    "sent": "Hey.",
                    "label": 0
                },
                {
                    "sent": "You, you said as future work, you want to find the good order for the variables.",
                    "label": 0
                },
                {
                    "sent": "Did you tell us actually what how you decide on the order?",
                    "label": 0
                },
                {
                    "sent": "At the moment?",
                    "label": 0
                },
                {
                    "sent": "Yeah, for deciding the variable ordering, what we do is OK. Do you?",
                    "label": 0
                },
                {
                    "sent": "Do you have the join algorithm of Pasadena, which decides the doctoring of triple patterns?",
                    "label": 0
                },
                {
                    "sent": "So in base to the order of triple patterns in base, kind of the order of appearance of the variables.",
                    "label": 0
                },
                {
                    "sent": "In the original agreement of Pasadena, we decide our variable ordering.",
                    "label": 0
                },
                {
                    "sent": "A it's like to copy the thing that Apple Tina.",
                    "label": 0
                },
                {
                    "sent": "Did before.",
                    "label": 0
                },
                {
                    "sent": "Great work so actually one thing that didn't become totally clear to me in how far is the algorithm streaming.",
                    "label": 0
                },
                {
                    "sent": "So in this toy example, you only had one binding.",
                    "label": 0
                },
                {
                    "sent": "Do you compute compute all the bindings for each variable in each step?",
                    "label": 0
                },
                {
                    "sent": "And is it a blocking computation where you need to maintain large set of intermediate results in main memory?",
                    "label": 0
                },
                {
                    "sent": "Or could this implemented in a fully streaming way pipelined essentially no no.",
                    "label": 0
                },
                {
                    "sent": "What we did is to implement it not in memory.",
                    "label": 0
                },
                {
                    "sent": "Actually it performs with the disk.",
                    "label": 0
                },
                {
                    "sent": "Pages so.",
                    "label": 0
                },
                {
                    "sent": "But one, the way that the algorithm works is that we first fix a single variable.",
                    "label": 0
                },
                {
                    "sent": "We find the intersection of variable, but we don't compute the entire interception, just find one possible binding and then we start with the rate.",
                    "label": 0
                },
                {
                    "sent": "If one finds a binding there and then, we go for the next variable, finding a possible binding, and that's all you have to keep in memory at the current binding on up.",
                    "label": 0
                },
                {
                    "sent": "Pointer to the next one, but you don't need to have everything in memory here.",
                    "label": 0
                },
                {
                    "sent": "Yeah, maybe to go in the same direction and.",
                    "label": 0
                },
                {
                    "sent": "Did you say that you select one variable before, like doing the bindings and so on, but you select it, taking the first one?",
                    "label": 0
                },
                {
                    "sent": "Or are you considering maybe as a future award to have some statistics on the on?",
                    "label": 0
                },
                {
                    "sent": "Maybe the predicates to you know.",
                    "label": 0
                },
                {
                    "sent": "First select the first one before rolling up as we were doing.",
                    "label": 0
                },
                {
                    "sent": "Like is there an idea of using statistics on the data set before hand?",
                    "label": 0
                },
                {
                    "sent": "OK.",
                    "label": 0
                },
                {
                    "sent": "The what we say to LF before is that we choose the variable ordering that Pasadena used before, and that ordering is, according to the statistics that Apache Nahhas.",
                    "label": 0
                },
                {
                    "sent": "So in base of the statistic, Albertina ordered but not for, not for variables but for trivial buttons.",
                    "label": 0
                },
                {
                    "sent": "And we do some kind of direction to to have variable ordering, which is kind of.",
                    "label": 0
                },
                {
                    "sent": "Quite distinct for the original 1.",
                    "label": 0
                },
                {
                    "sent": "But yes, we started the statistic, but in terms of choosing a smart variable ordering, there is a lot of work actually in the field of of the guys that study worst case optimal algorithm is it is not clear how to decide the variable ordering in this kind of algorithms.",
                    "label": 0
                },
                {
                    "sent": "Let's stand thank the speaker again.",
                    "label": 0
                }
            ]
        }
    }
}