{
    "id": "zf5dirhmp52g7x7srrc3ej2n23pnpvv6",
    "title": "Image Retrieval for Image-Based Localization Revisited",
    "info": {
        "author": [
            "Torsten Sattler, RWTH Aachen University"
        ],
        "published": "Oct. 9, 2012",
        "recorded": "September 2012",
        "category": [
            "Top->Computer Science->Computer Vision->Image & Video Retrieval"
        ]
    },
    "url": "http://videolectures.net/bmvc2012_sattler_image_retrieval/",
    "segmentation": [
        [
            "Thank you for the introduction.",
            "This is joint work was to be as violent, passion, live and live coverage.",
            "About image retrieval for image based localization.",
            "So let me first start by defining."
        ],
        [
            "Image based localization is we're given a novel query image and want to know where it was taking an from which direction we were looking."
        ],
        [
            "In our case, we modeled the scene using a 3D point cloud and we're interested in obtaining the camera pose of the imagery."
        ],
        [
            "To that point, cloud.",
            "And to estimate the."
        ],
        [
            "Cause we need correspondences between 2D image points and 3D points in the model.",
            "And."
        ],
        [
            "Actually, the point cloud is obtained from structure for motion, so we can associate every sweetie point with multiple image descriptors.",
            "So we basically have to solve a descriptor matching problem.",
            "There are two popular ways to do so.",
            "First one is to do an intermediate material step which benefits from the scalability."
        ],
        [
            "Retrieval, but it has been shown that not the results that you get are not optimal or not."
        ],
        [
            "If you are an what's currently done in most works, is direct connection like you directly try to match the descriptors from the image against scripters of the three points.",
            "And this does not scale well, but it gives you state of the art performance."
        ],
        [
            "I have this scalable method, so this talk will have a look at the cost for this gap in performance and how to."
        ],
        [
            "So first I will give you a short overview about two image based localization techniques, one image retrieval based on direction based.",
            "Then we will look at the reasons forces captain forms and I will show you simple way how to close it.",
            "In the end I will quickly talk about efficiently establishing correspondences between a query image in a database image."
        ],
        [
            "Now image retrieval for localization.",
            "This is the pipeline proposed Bashar and others at CPR 2009.",
            "Starters query image.",
            "And assign its features to visual words."
        ],
        [
            "For every visual word you have the inverted file entry and he used that inverted file index to add."
        ],
        [
            "Weights or score?"
        ],
        [
            "Stupid databases."
        ],
        [
            "So there's one specialty here, because every inverted file entry corresponds to 3D point and see.",
            "So all the features in the database images that during Reconstruction did not yield a 3D point or ignored.",
            "Now, as soon as you have."
        ],
        [
            "Finish scoring you rank the images based on this course and."
        ],
        [
            "Only the top K rank images are considered for further processing.",
            "And also."
        ],
        [
            "We will see a top ranked image.",
            "You do a feature match."
        ],
        [
            "In between the query image and the database image, and since you know that every feature in database image corresponds."
        ],
        [
            "So sweetie, point, you end up with those 2D to 3D correspondences that you need to run post estimation or just."
        ],
        [
            "Using ransack and an endpoint post output.",
            "And you repeat that."
        ],
        [
            "Same procedure for all toprank images and."
        ],
        [
            "Post of the fairy images and the post was the most in lives.",
            "All."
        ],
        [
            "Or image direct matching approach from CI CD last year is similar in the sense that also used visual vocabulary.",
            "Some offline stage we first assign the descriptors of the 3D points to the visual words and now every inverted file entry also contains a safe trip.",
            "So all the black points inside this visual world are representative descriptors.",
            "If we have another query image, we again assign its feature to visual word."
        ],
        [
            "Then try to do try to find its nearest neighbor."
        ],
        [
            "3D points which you can easily do because you have the."
        ],
        [
            "Descriptors so."
        ],
        [
            "We then spent devilish correspondence between the query feature F and its nearest neighboring through the point P. If the descriptor distance to nearest neighbor is sufficiently smaller than the descriptor distance to 2nd nearest neighbor, which is the well known sift ratio test and again."
        ],
        [
            "The post is estimated using ransack and endpoint post output.",
            "Now."
        ],
        [
            "The drawback."
        ],
        [
            "Of direct matching is that we have to keep those sift descriptors in memory of all times, which in the scalability.",
            "Also we have to do descriptive distance computations for every inverted file entry.",
            "So what we would like to do as a torch in the beginning is we would like to have use image retrieval but to get good performance we have to close this registration form and scan.",
            "The reason for this gap is very simple because he only can estimate a valid camera pose."
        ],
        [
            "Or create image if one of the top ranked images depict."
        ],
        [
            "Same scene.",
            "If image retrieval is not able to rank relevant image high enough, we will miss.",
            "We cannot estimate the pose.",
            "So."
        ],
        [
            "Let's look at our voting stage of image retrieval, because this is responsible for the ranking.",
            "So we have now this."
        ],
        [
            "Red stock very feature and we can basically classify all descriptors on inverted file entries in its original word into two category."
        ],
        [
            "These first one are those descriptors belonging to the same 3 point, so their inverted file entries will yield votes for relevant images.",
            "So votes that we would like to use."
        ],
        [
            "All the other descriptors belong to different 3D points, so if we use those inverted file entries to vote.",
            "We will vote for images that are not relevant to the query, so we would like to get rid of those.",
            "So what we would like to do is some sort of selective voting keep only."
        ],
        [
            "Correct votes discard the incorrect ones.",
            "That's a very simple idea.",
            "So how can we do that in practice?",
            "I will present you two possible approaches to possible implementations of selective voting."
        ],
        [
            "First one is called correspondence voting and inspired by direct matching.",
            "The idea here is that we again use descriptors and we use the idea that every query feature can correspond to at most one 3D point in C, and we try to find that point now it might happen, or in this case it happens that.",
            "Of the.",
            "Multiple descriptors of same 3 point are meant to say magic word.",
            "To simplify things we see."
        ],
        [
            "To replace him by the mean descriptor.",
            "Not you."
        ],
        [
            "Sing all descriptors."
        ],
        [
            "Stored in this special word, we find the two nearest neighbors again apply the SIFT ratio test and."
        ],
        [
            "The situation test is passed.",
            "We will simply vote for those images observing the nearest neighboring 3.0 and we use a very very simple weighting scheme by simply adding a weight of 1 to those database images.",
            "So nothing fancy here.",
            "Um, OK.",
            "This assumes that.",
            "The incorrect votes are really the cause for this performance gap, so let's evaluate that experimentally.",
            "We do that."
        ],
        [
            "Two datasets on Novolog data set which was reconstructed using around 3000 images taking in the historical inner city of often in Germany.",
            "What you can see here, all the red points correspond to camera positions.",
            "And the Vienna data set, which was first introduced by Sharad others and has since then been used in multiple works on image based localization and the data set will be available at our website.",
            "The links on the paper so you don't have to memorize it for the on data set we took around, we took 369 images using a mobile phone and you set up the query."
        ],
        [
            "So let's first compare all the performance of direct matching with image retrieval using TF IDF weighting for A to get the RE ranking can see there is there's significant gap in the number of images that can be reduced it using direct matching and imagery.",
            "So for example for the entire data set, 9% of all the query images can be reduced with using direct matching but not with image retrieval.",
            "Shar at all proposed different scoring scheme, which I'm not going to explain."
        ],
        [
            "Here, which gives you better results, but still are still."
        ],
        [
            "Significant gap even when considering the top 10 ranked images.",
            "Now if we use correspondence voting to get rid of many wrong or incorrect votes, we are not only able to close this gap in performance, actually get better performance in direct match, so this clearly shows that handling incorrect words is crucial together.",
            "Good ranking.",
            "And you what you also see said.",
            "Image retrieval works better with a large vocabulary.",
            "The reason is very simple, because using a large vocabulary you can get rid of many incorrect votes.",
            "That's one thing that's interesting to see here is that.",
            "What that corresponds voting does is it uses those correspondences harmed by direct matching and use them to vote for images.",
            "So it's at first glance surprising that it performs better than direct match.",
            "But the reason I said after the voting stage we map we matched the features in the query image against the features in the relevant database images and the way that we implemented that.",
            "We're able to recover correspondence.",
            "Is that our loss to direct matching due to quantization, so there's reason why it performs better.",
            "So.",
            "Everything is fine.",
            "We're showing you I've shown you how to get better rankings.",
            "We're done here."
        ],
        [
            "Unfortunately, it's not that easy.",
            "'cause corresponds.",
            "Voting is in terms of scalability.",
            "In in no way better than direct matching because we basically do the same thing we do.",
            "We have to keep the sifter scripter."
        ],
        [
            "In memory we have to do distance computations, so we do not gain scalability.",
            "And as I said in the beginning, very interested in scalable method and it turns out solution to get scalable selective folding scheme has."
        ],
        [
            "It's already been presented in 2008.",
            "She grew it all an the buzzword here is having better idea said.",
            "Instead of using SIFT descriptors, use small binary strings which you obtain by projecting sift descriptors to a smaller dimensional space using a random projection function and then thresholding them for every visual works.",
            "In this case all descriptors below."
        ],
        [
            "This threshold have their first bit set to 0, all the features to the right of that which threshold has the second bit set to 0.",
            "Now to restrict the votes, we simply compare the binary strings using Hamming distances so.",
            "This example setting in Hamming distance threshold of zero, we would only vote for images observing those having those four inverted file entries so."
        ],
        [
            "Simply add a way to form to those four images.",
            "Notice here that we actually also do an incorrect vote because we cannot distinguish that anymore, so."
        ],
        [
            "Let's look at the performance of Hemming voting compared to correspondence voting to hear, see see here is if you do not use enough dimensions, get much worse."
        ],
        [
            "Thoughts, but finally?"
        ],
        [
            "When you use."
        ],
        [
            "64 dimensions or 64 bits.",
            "You get results that are nearly the same as correspondence vote, and there is 1 interesting thing to see here based, and this is that for 32 bits and 64 bits you get better performance if you use 100,000 bushel words then when you use the final vocabulary.",
            "The reason here said having embedding or having votings able to get rid of most incorrect vote so you benefit from the fewer quantization errors that are introduced by the course of vocabulary."
        ],
        [
            "Now if you compare Hemming voting in correspondence voting when we use 64 bits, we need 16 times less memory.",
            "So this method will scale to larger datasets more easy.",
            "Now we still have to do a distance computation, But the nice thing is that modern CPUs can do Hemming distance computations really fast, so we can do about a million distance computations into milliseconds.",
            "So we do not really use lose time."
        ],
        [
            "Um?",
            "There is a small additional cost for Hemming voting because we have to project and threshold the features found in our test cases.",
            "Those were on average 23 milliseconds so we can still live with that.",
            "There is a small drop in performance.",
            "But if, since we're interested in scalability, we're glad to praise the price."
        ],
        [
            "OK, so so far we have looked at the voting part of retrieval of showing you how to get better rankings using selective folding, but the overall performance and runtime costs also depends on the feature missing and post estimation stage.",
            "So far we've done a very costly feature matching which builds a KD tree."
        ],
        [
            "Other features in the query image and use that KD tree to establish the matches which.",
            "Introduce additional times when we are interested in fast execution times.",
            "Would like to get something faster and more simple.",
            "And I do."
        ],
        [
            "We would reuse matches that we found in the voting stage, but the problem here said for many database images that are relevant, we do not find enough chorus."
        ],
        [
            "The reason is that we do this quantized matching only search for the query feature.",
            "We only search its visual word for corresponding points."
        ],
        [
            "And if the same 3D point is mapped to a different word for database image, we will lose that correspondence.",
            "But still we would like to reuse this data structure of Qantas matching 'cause very simple.",
            "You don't have to build special tree or anything so."
        ],
        [
            "There's a simple solution to that.",
            "Simply use the cause of Cavaleri and if you build that on top of the final one, you have no additional assignment costs because you know that that very feature here belongs to the smaller visual word.",
            "On the final level, thus automatically belongs to the larger which word on the corsola.",
            "So let's compare the performance, but."
        ],
        [
            "Queen's analysis matching and quantized matching using SIFT descriptors and binary strings.",
            "Here we use 100 words."
        ],
        [
            "And what you can see is that there's nearly no difference between the number of images can be registered using regular sift matching Qantas if matching my quantized Hamming matching is 3 to 4% worse."
        ],
        [
            "At the same time, Qantas matching is much faster, so especially if you use binary strings, nearly three orders of magnitude faster, but unfortunately."
        ],
        [
            "The speedup comes at the price of finding more incorrect votes which drive up your answer times.",
            "In case that post can be estimated or cannot be estimated but still quantized.",
            "Sift matching is in most cases faster than regular suspension.",
            "So before I conclude the talk I want to show you an observation that we had when comparing quanta sifting."
        ],
        [
            "Test having match 'cause what you?"
        ],
        [
            "It's used if you use cost vocabulary.",
            "Get about Qantas if matching is much better than contest image.",
            "If you use 1000 words they performed about."
        ],
        [
            "Same."
        ],
        [
            "And if you use 10,000 visual words and Qantas Heming matching suddenly much better than Qantas if match.",
            "The reason for that is."
        ],
        [
            "At Qantas, if matching tends to find more incorrect course correspondence is when you use the final vocabulary when she can see when looking at the in liar ratios.",
            "In case it post could be estimated.",
            "While you get the opposite behavior for."
        ],
        [
            "Quantized Hemming matching 'cause here you get?",
            "More incorrect matches when you use the final vocabulary.",
            "So."
        ],
        [
            "So to conclude the talk, but I've shown you said the major reason for the gap in performance between direct matching and image retrieval based say handling of incorrect bolts.",
            "If you try to avoid them, you get much better performance for image retrieval and having voting or hamming embedding is a very simple way to do so.",
            "It's very fast, you have little additional computational overhead, little memory overhead, so can only advise you to use that if you do image retrieval.",
            "So you end up with a scalable image based localization method.",
            "Also talked a little bit about.",
            "Making the correspondence selection more efficient, but clearly we need some of future research on that to get better matches to speed up transactions.",
            "Yeah, thank you for your attention.",
            "Do you have any questions?"
        ]
    ],
    "summarization": {
        "clip_0": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Thank you for the introduction.",
                    "label": 0
                },
                {
                    "sent": "This is joint work was to be as violent, passion, live and live coverage.",
                    "label": 0
                },
                {
                    "sent": "About image retrieval for image based localization.",
                    "label": 1
                },
                {
                    "sent": "So let me first start by defining.",
                    "label": 0
                }
            ]
        },
        "clip_1": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Image based localization is we're given a novel query image and want to know where it was taking an from which direction we were looking.",
                    "label": 0
                }
            ]
        },
        "clip_2": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In our case, we modeled the scene using a 3D point cloud and we're interested in obtaining the camera pose of the imagery.",
                    "label": 0
                }
            ]
        },
        "clip_3": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "To that point, cloud.",
                    "label": 0
                },
                {
                    "sent": "And to estimate the.",
                    "label": 0
                }
            ]
        },
        "clip_4": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Cause we need correspondences between 2D image points and 3D points in the model.",
                    "label": 0
                },
                {
                    "sent": "And.",
                    "label": 0
                }
            ]
        },
        "clip_5": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Actually, the point cloud is obtained from structure for motion, so we can associate every sweetie point with multiple image descriptors.",
                    "label": 1
                },
                {
                    "sent": "So we basically have to solve a descriptor matching problem.",
                    "label": 1
                },
                {
                    "sent": "There are two popular ways to do so.",
                    "label": 0
                },
                {
                    "sent": "First one is to do an intermediate material step which benefits from the scalability.",
                    "label": 0
                }
            ]
        },
        "clip_6": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Retrieval, but it has been shown that not the results that you get are not optimal or not.",
                    "label": 0
                }
            ]
        },
        "clip_7": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "If you are an what's currently done in most works, is direct connection like you directly try to match the descriptors from the image against scripters of the three points.",
                    "label": 0
                },
                {
                    "sent": "And this does not scale well, but it gives you state of the art performance.",
                    "label": 0
                }
            ]
        },
        "clip_8": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "I have this scalable method, so this talk will have a look at the cost for this gap in performance and how to.",
                    "label": 0
                }
            ]
        },
        "clip_9": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So first I will give you a short overview about two image based localization techniques, one image retrieval based on direction based.",
                    "label": 0
                },
                {
                    "sent": "Then we will look at the reasons forces captain forms and I will show you simple way how to close it.",
                    "label": 0
                },
                {
                    "sent": "In the end I will quickly talk about efficiently establishing correspondences between a query image in a database image.",
                    "label": 0
                }
            ]
        },
        "clip_10": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Now image retrieval for localization.",
                    "label": 1
                },
                {
                    "sent": "This is the pipeline proposed Bashar and others at CPR 2009.",
                    "label": 0
                },
                {
                    "sent": "Starters query image.",
                    "label": 1
                },
                {
                    "sent": "And assign its features to visual words.",
                    "label": 0
                }
            ]
        },
        "clip_11": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "For every visual word you have the inverted file entry and he used that inverted file index to add.",
                    "label": 0
                }
            ]
        },
        "clip_12": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Weights or score?",
                    "label": 0
                }
            ]
        },
        "clip_13": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Stupid databases.",
                    "label": 0
                }
            ]
        },
        "clip_14": {
            "is_summarization_sample": false,
            "summarization_data": []
        },
        "clip_15": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So there's one specialty here, because every inverted file entry corresponds to 3D point and see.",
                    "label": 1
                },
                {
                    "sent": "So all the features in the database images that during Reconstruction did not yield a 3D point or ignored.",
                    "label": 0
                },
                {
                    "sent": "Now, as soon as you have.",
                    "label": 0
                }
            ]
        },
        "clip_16": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Finish scoring you rank the images based on this course and.",
                    "label": 0
                }
            ]
        },
        "clip_17": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Only the top K rank images are considered for further processing.",
                    "label": 0
                },
                {
                    "sent": "And also.",
                    "label": 0
                }
            ]
        },
        "clip_18": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We will see a top ranked image.",
                    "label": 0
                },
                {
                    "sent": "You do a feature match.",
                    "label": 0
                }
            ]
        },
        "clip_19": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In between the query image and the database image, and since you know that every feature in database image corresponds.",
                    "label": 0
                }
            ]
        },
        "clip_20": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So sweetie, point, you end up with those 2D to 3D correspondences that you need to run post estimation or just.",
                    "label": 0
                }
            ]
        },
        "clip_21": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Using ransack and an endpoint post output.",
                    "label": 0
                },
                {
                    "sent": "And you repeat that.",
                    "label": 0
                }
            ]
        },
        "clip_22": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Same procedure for all toprank images and.",
                    "label": 0
                }
            ]
        },
        "clip_23": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Post of the fairy images and the post was the most in lives.",
                    "label": 0
                },
                {
                    "sent": "All.",
                    "label": 0
                }
            ]
        },
        "clip_24": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Or image direct matching approach from CI CD last year is similar in the sense that also used visual vocabulary.",
                    "label": 1
                },
                {
                    "sent": "Some offline stage we first assign the descriptors of the 3D points to the visual words and now every inverted file entry also contains a safe trip.",
                    "label": 1
                },
                {
                    "sent": "So all the black points inside this visual world are representative descriptors.",
                    "label": 0
                },
                {
                    "sent": "If we have another query image, we again assign its feature to visual word.",
                    "label": 0
                }
            ]
        },
        "clip_25": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Then try to do try to find its nearest neighbor.",
                    "label": 0
                }
            ]
        },
        "clip_26": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "3D points which you can easily do because you have the.",
                    "label": 0
                }
            ]
        },
        "clip_27": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Descriptors so.",
                    "label": 0
                }
            ]
        },
        "clip_28": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We then spent devilish correspondence between the query feature F and its nearest neighboring through the point P. If the descriptor distance to nearest neighbor is sufficiently smaller than the descriptor distance to 2nd nearest neighbor, which is the well known sift ratio test and again.",
                    "label": 0
                }
            ]
        },
        "clip_29": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The post is estimated using ransack and endpoint post output.",
                    "label": 0
                },
                {
                    "sent": "Now.",
                    "label": 0
                }
            ]
        },
        "clip_30": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The drawback.",
                    "label": 0
                }
            ]
        },
        "clip_31": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Of direct matching is that we have to keep those sift descriptors in memory of all times, which in the scalability.",
                    "label": 1
                },
                {
                    "sent": "Also we have to do descriptive distance computations for every inverted file entry.",
                    "label": 1
                },
                {
                    "sent": "So what we would like to do as a torch in the beginning is we would like to have use image retrieval but to get good performance we have to close this registration form and scan.",
                    "label": 0
                },
                {
                    "sent": "The reason for this gap is very simple because he only can estimate a valid camera pose.",
                    "label": 0
                }
            ]
        },
        "clip_32": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Or create image if one of the top ranked images depict.",
                    "label": 0
                }
            ]
        },
        "clip_33": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Same scene.",
                    "label": 0
                },
                {
                    "sent": "If image retrieval is not able to rank relevant image high enough, we will miss.",
                    "label": 1
                },
                {
                    "sent": "We cannot estimate the pose.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_34": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Let's look at our voting stage of image retrieval, because this is responsible for the ranking.",
                    "label": 0
                },
                {
                    "sent": "So we have now this.",
                    "label": 0
                }
            ]
        },
        "clip_35": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Red stock very feature and we can basically classify all descriptors on inverted file entries in its original word into two category.",
                    "label": 0
                }
            ]
        },
        "clip_36": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "These first one are those descriptors belonging to the same 3 point, so their inverted file entries will yield votes for relevant images.",
                    "label": 0
                },
                {
                    "sent": "So votes that we would like to use.",
                    "label": 0
                }
            ]
        },
        "clip_37": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "All the other descriptors belong to different 3D points, so if we use those inverted file entries to vote.",
                    "label": 0
                },
                {
                    "sent": "We will vote for images that are not relevant to the query, so we would like to get rid of those.",
                    "label": 0
                },
                {
                    "sent": "So what we would like to do is some sort of selective voting keep only.",
                    "label": 0
                }
            ]
        },
        "clip_38": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "Correct votes discard the incorrect ones.",
                    "label": 1
                },
                {
                    "sent": "That's a very simple idea.",
                    "label": 0
                },
                {
                    "sent": "So how can we do that in practice?",
                    "label": 0
                },
                {
                    "sent": "I will present you two possible approaches to possible implementations of selective voting.",
                    "label": 0
                }
            ]
        },
        "clip_39": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "First one is called correspondence voting and inspired by direct matching.",
                    "label": 1
                },
                {
                    "sent": "The idea here is that we again use descriptors and we use the idea that every query feature can correspond to at most one 3D point in C, and we try to find that point now it might happen, or in this case it happens that.",
                    "label": 0
                },
                {
                    "sent": "Of the.",
                    "label": 0
                },
                {
                    "sent": "Multiple descriptors of same 3 point are meant to say magic word.",
                    "label": 0
                },
                {
                    "sent": "To simplify things we see.",
                    "label": 0
                }
            ]
        },
        "clip_40": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "To replace him by the mean descriptor.",
                    "label": 0
                },
                {
                    "sent": "Not you.",
                    "label": 0
                }
            ]
        },
        "clip_41": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Sing all descriptors.",
                    "label": 0
                }
            ]
        },
        "clip_42": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Stored in this special word, we find the two nearest neighbors again apply the SIFT ratio test and.",
                    "label": 0
                }
            ]
        },
        "clip_43": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The situation test is passed.",
                    "label": 0
                },
                {
                    "sent": "We will simply vote for those images observing the nearest neighboring 3.0 and we use a very very simple weighting scheme by simply adding a weight of 1 to those database images.",
                    "label": 0
                },
                {
                    "sent": "So nothing fancy here.",
                    "label": 0
                },
                {
                    "sent": "Um, OK.",
                    "label": 0
                },
                {
                    "sent": "This assumes that.",
                    "label": 0
                },
                {
                    "sent": "The incorrect votes are really the cause for this performance gap, so let's evaluate that experimentally.",
                    "label": 0
                },
                {
                    "sent": "We do that.",
                    "label": 0
                }
            ]
        },
        "clip_44": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Two datasets on Novolog data set which was reconstructed using around 3000 images taking in the historical inner city of often in Germany.",
                    "label": 0
                },
                {
                    "sent": "What you can see here, all the red points correspond to camera positions.",
                    "label": 0
                },
                {
                    "sent": "And the Vienna data set, which was first introduced by Sharad others and has since then been used in multiple works on image based localization and the data set will be available at our website.",
                    "label": 0
                },
                {
                    "sent": "The links on the paper so you don't have to memorize it for the on data set we took around, we took 369 images using a mobile phone and you set up the query.",
                    "label": 0
                }
            ]
        },
        "clip_45": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "So let's first compare all the performance of direct matching with image retrieval using TF IDF weighting for A to get the RE ranking can see there is there's significant gap in the number of images that can be reduced it using direct matching and imagery.",
                    "label": 0
                },
                {
                    "sent": "So for example for the entire data set, 9% of all the query images can be reduced with using direct matching but not with image retrieval.",
                    "label": 0
                },
                {
                    "sent": "Shar at all proposed different scoring scheme, which I'm not going to explain.",
                    "label": 0
                }
            ]
        },
        "clip_46": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Here, which gives you better results, but still are still.",
                    "label": 0
                }
            ]
        },
        "clip_47": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Significant gap even when considering the top 10 ranked images.",
                    "label": 0
                },
                {
                    "sent": "Now if we use correspondence voting to get rid of many wrong or incorrect votes, we are not only able to close this gap in performance, actually get better performance in direct match, so this clearly shows that handling incorrect words is crucial together.",
                    "label": 0
                },
                {
                    "sent": "Good ranking.",
                    "label": 0
                },
                {
                    "sent": "And you what you also see said.",
                    "label": 0
                },
                {
                    "sent": "Image retrieval works better with a large vocabulary.",
                    "label": 0
                },
                {
                    "sent": "The reason is very simple, because using a large vocabulary you can get rid of many incorrect votes.",
                    "label": 0
                },
                {
                    "sent": "That's one thing that's interesting to see here is that.",
                    "label": 0
                },
                {
                    "sent": "What that corresponds voting does is it uses those correspondences harmed by direct matching and use them to vote for images.",
                    "label": 0
                },
                {
                    "sent": "So it's at first glance surprising that it performs better than direct match.",
                    "label": 0
                },
                {
                    "sent": "But the reason I said after the voting stage we map we matched the features in the query image against the features in the relevant database images and the way that we implemented that.",
                    "label": 0
                },
                {
                    "sent": "We're able to recover correspondence.",
                    "label": 0
                },
                {
                    "sent": "Is that our loss to direct matching due to quantization, so there's reason why it performs better.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                },
                {
                    "sent": "Everything is fine.",
                    "label": 0
                },
                {
                    "sent": "We're showing you I've shown you how to get better rankings.",
                    "label": 0
                },
                {
                    "sent": "We're done here.",
                    "label": 0
                }
            ]
        },
        "clip_48": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Unfortunately, it's not that easy.",
                    "label": 0
                },
                {
                    "sent": "'cause corresponds.",
                    "label": 0
                },
                {
                    "sent": "Voting is in terms of scalability.",
                    "label": 0
                },
                {
                    "sent": "In in no way better than direct matching because we basically do the same thing we do.",
                    "label": 0
                },
                {
                    "sent": "We have to keep the sifter scripter.",
                    "label": 0
                }
            ]
        },
        "clip_49": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "In memory we have to do distance computations, so we do not gain scalability.",
                    "label": 0
                },
                {
                    "sent": "And as I said in the beginning, very interested in scalable method and it turns out solution to get scalable selective folding scheme has.",
                    "label": 0
                }
            ]
        },
        "clip_50": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "It's already been presented in 2008.",
                    "label": 0
                },
                {
                    "sent": "She grew it all an the buzzword here is having better idea said.",
                    "label": 0
                },
                {
                    "sent": "Instead of using SIFT descriptors, use small binary strings which you obtain by projecting sift descriptors to a smaller dimensional space using a random projection function and then thresholding them for every visual works.",
                    "label": 0
                },
                {
                    "sent": "In this case all descriptors below.",
                    "label": 0
                }
            ]
        },
        "clip_51": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "This threshold have their first bit set to 0, all the features to the right of that which threshold has the second bit set to 0.",
                    "label": 0
                },
                {
                    "sent": "Now to restrict the votes, we simply compare the binary strings using Hamming distances so.",
                    "label": 0
                },
                {
                    "sent": "This example setting in Hamming distance threshold of zero, we would only vote for images observing those having those four inverted file entries so.",
                    "label": 0
                }
            ]
        },
        "clip_52": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Simply add a way to form to those four images.",
                    "label": 0
                },
                {
                    "sent": "Notice here that we actually also do an incorrect vote because we cannot distinguish that anymore, so.",
                    "label": 0
                }
            ]
        },
        "clip_53": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Let's look at the performance of Hemming voting compared to correspondence voting to hear, see see here is if you do not use enough dimensions, get much worse.",
                    "label": 0
                }
            ]
        },
        "clip_54": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Thoughts, but finally?",
                    "label": 0
                }
            ]
        },
        "clip_55": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "When you use.",
                    "label": 0
                }
            ]
        },
        "clip_56": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "64 dimensions or 64 bits.",
                    "label": 0
                },
                {
                    "sent": "You get results that are nearly the same as correspondence vote, and there is 1 interesting thing to see here based, and this is that for 32 bits and 64 bits you get better performance if you use 100,000 bushel words then when you use the final vocabulary.",
                    "label": 0
                },
                {
                    "sent": "The reason here said having embedding or having votings able to get rid of most incorrect vote so you benefit from the fewer quantization errors that are introduced by the course of vocabulary.",
                    "label": 0
                }
            ]
        },
        "clip_57": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Now if you compare Hemming voting in correspondence voting when we use 64 bits, we need 16 times less memory.",
                    "label": 0
                },
                {
                    "sent": "So this method will scale to larger datasets more easy.",
                    "label": 0
                },
                {
                    "sent": "Now we still have to do a distance computation, But the nice thing is that modern CPUs can do Hemming distance computations really fast, so we can do about a million distance computations into milliseconds.",
                    "label": 0
                },
                {
                    "sent": "So we do not really use lose time.",
                    "label": 0
                }
            ]
        },
        "clip_58": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Um?",
                    "label": 0
                },
                {
                    "sent": "There is a small additional cost for Hemming voting because we have to project and threshold the features found in our test cases.",
                    "label": 0
                },
                {
                    "sent": "Those were on average 23 milliseconds so we can still live with that.",
                    "label": 0
                },
                {
                    "sent": "There is a small drop in performance.",
                    "label": 0
                },
                {
                    "sent": "But if, since we're interested in scalability, we're glad to praise the price.",
                    "label": 0
                }
            ]
        },
        "clip_59": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "OK, so so far we have looked at the voting part of retrieval of showing you how to get better rankings using selective folding, but the overall performance and runtime costs also depends on the feature missing and post estimation stage.",
                    "label": 0
                },
                {
                    "sent": "So far we've done a very costly feature matching which builds a KD tree.",
                    "label": 0
                }
            ]
        },
        "clip_60": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Other features in the query image and use that KD tree to establish the matches which.",
                    "label": 0
                },
                {
                    "sent": "Introduce additional times when we are interested in fast execution times.",
                    "label": 0
                },
                {
                    "sent": "Would like to get something faster and more simple.",
                    "label": 0
                },
                {
                    "sent": "And I do.",
                    "label": 0
                }
            ]
        },
        "clip_61": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "We would reuse matches that we found in the voting stage, but the problem here said for many database images that are relevant, we do not find enough chorus.",
                    "label": 0
                }
            ]
        },
        "clip_62": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The reason is that we do this quantized matching only search for the query feature.",
                    "label": 0
                },
                {
                    "sent": "We only search its visual word for corresponding points.",
                    "label": 0
                }
            ]
        },
        "clip_63": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And if the same 3D point is mapped to a different word for database image, we will lose that correspondence.",
                    "label": 0
                },
                {
                    "sent": "But still we would like to reuse this data structure of Qantas matching 'cause very simple.",
                    "label": 0
                },
                {
                    "sent": "You don't have to build special tree or anything so.",
                    "label": 0
                }
            ]
        },
        "clip_64": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "There's a simple solution to that.",
                    "label": 0
                },
                {
                    "sent": "Simply use the cause of Cavaleri and if you build that on top of the final one, you have no additional assignment costs because you know that that very feature here belongs to the smaller visual word.",
                    "label": 1
                },
                {
                    "sent": "On the final level, thus automatically belongs to the larger which word on the corsola.",
                    "label": 0
                },
                {
                    "sent": "So let's compare the performance, but.",
                    "label": 0
                }
            ]
        },
        "clip_65": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Queen's analysis matching and quantized matching using SIFT descriptors and binary strings.",
                    "label": 0
                },
                {
                    "sent": "Here we use 100 words.",
                    "label": 0
                }
            ]
        },
        "clip_66": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And what you can see is that there's nearly no difference between the number of images can be registered using regular sift matching Qantas if matching my quantized Hamming matching is 3 to 4% worse.",
                    "label": 0
                }
            ]
        },
        "clip_67": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "At the same time, Qantas matching is much faster, so especially if you use binary strings, nearly three orders of magnitude faster, but unfortunately.",
                    "label": 0
                }
            ]
        },
        "clip_68": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "The speedup comes at the price of finding more incorrect votes which drive up your answer times.",
                    "label": 0
                },
                {
                    "sent": "In case that post can be estimated or cannot be estimated but still quantized.",
                    "label": 0
                },
                {
                    "sent": "Sift matching is in most cases faster than regular suspension.",
                    "label": 0
                },
                {
                    "sent": "So before I conclude the talk I want to show you an observation that we had when comparing quanta sifting.",
                    "label": 0
                }
            ]
        },
        "clip_69": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Test having match 'cause what you?",
                    "label": 0
                }
            ]
        },
        "clip_70": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "It's used if you use cost vocabulary.",
                    "label": 0
                },
                {
                    "sent": "Get about Qantas if matching is much better than contest image.",
                    "label": 0
                },
                {
                    "sent": "If you use 1000 words they performed about.",
                    "label": 0
                }
            ]
        },
        "clip_71": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Same.",
                    "label": 0
                }
            ]
        },
        "clip_72": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "And if you use 10,000 visual words and Qantas Heming matching suddenly much better than Qantas if match.",
                    "label": 0
                },
                {
                    "sent": "The reason for that is.",
                    "label": 0
                }
            ]
        },
        "clip_73": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "At Qantas, if matching tends to find more incorrect course correspondence is when you use the final vocabulary when she can see when looking at the in liar ratios.",
                    "label": 0
                },
                {
                    "sent": "In case it post could be estimated.",
                    "label": 0
                },
                {
                    "sent": "While you get the opposite behavior for.",
                    "label": 0
                }
            ]
        },
        "clip_74": {
            "is_summarization_sample": false,
            "summarization_data": [
                {
                    "sent": "Quantized Hemming matching 'cause here you get?",
                    "label": 0
                },
                {
                    "sent": "More incorrect matches when you use the final vocabulary.",
                    "label": 0
                },
                {
                    "sent": "So.",
                    "label": 0
                }
            ]
        },
        "clip_75": {
            "is_summarization_sample": true,
            "summarization_data": [
                {
                    "sent": "So to conclude the talk, but I've shown you said the major reason for the gap in performance between direct matching and image retrieval based say handling of incorrect bolts.",
                    "label": 0
                },
                {
                    "sent": "If you try to avoid them, you get much better performance for image retrieval and having voting or hamming embedding is a very simple way to do so.",
                    "label": 1
                },
                {
                    "sent": "It's very fast, you have little additional computational overhead, little memory overhead, so can only advise you to use that if you do image retrieval.",
                    "label": 1
                },
                {
                    "sent": "So you end up with a scalable image based localization method.",
                    "label": 1
                },
                {
                    "sent": "Also talked a little bit about.",
                    "label": 0
                },
                {
                    "sent": "Making the correspondence selection more efficient, but clearly we need some of future research on that to get better matches to speed up transactions.",
                    "label": 0
                },
                {
                    "sent": "Yeah, thank you for your attention.",
                    "label": 0
                },
                {
                    "sent": "Do you have any questions?",
                    "label": 0
                }
            ]
        }
    }
}